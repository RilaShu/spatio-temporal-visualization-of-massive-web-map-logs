(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.tiles = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    module.exports = {

        // Binning
        AreaOfInterestTilePyramid: require('./binning/AreaOfInterestTilePyramid'),
        TileIterator: require('./binning/TileIterator'),
        WebMercatorTilePyramid: require('./binning/WebMercatorTilePyramid'),

        // Layer
        AnnotationLayer: require('./layer/AnnotationLayer'),
        AxisLayer: require('./layer/AxisLayer'),
        BaseLayer: require('./layer/BaseLayer'),
        KMLLayer: require('./layer/KMLLayer'),
        ServerLayer: require('./layer/ServerLayer'),
        ClientLayer: require('./layer/ClientLayer'),
        MultiUrlClientLayer: require('./layer/MultiUrlClientLayer'),
        Carousel: require('./layer/Carousel'),
        LayerUtil: require('./layer/LayerUtil'),
        VectorLayer: require('./layer/VectorLayer'),
        HtmlMarker: require('./layer/HtmlMarker'),
        HtmlMarkerLayer: require('./layer/HtmlMarkerLayer'),
        Layer: require('./layer/Layer'),

        // Renderer
        Renderer: require('./layer/renderer/Renderer'),
        Aggregator: require('./layer/renderer/aggregator/Aggregator'),
        TopicCountAggregator: require('./layer/renderer/aggregator/TopicCountAggregator'),
        TopicCountArrayAggregator: require('./layer/renderer/aggregator/TopicCountArrayAggregator'),
        TopicFrequencyAggregator: require('./layer/renderer/aggregator/TopicFrequencyAggregator'),
        TweetsByTopicAggregator: require('./layer/renderer/aggregator/TweetsByTopicAggregator'),
        FrequenciesByTopicAggregator: require('./layer/renderer/aggregator/FrequenciesByTopicAggregator'),
        FrequencyArraysByTopicAggregator: require('./layer/renderer/aggregator/FrequencyArraysByTopicAggregator'),
        RendererUtil: require('./layer/renderer/RendererUtil'),
        GraphLabelRenderer: require('./layer/renderer/GraphLabelRenderer'),
        GraphNodeRenderer: require('./layer/renderer/GraphNodeRenderer'),
        PointAggregateRenderer: require('./layer/renderer/PointAggregateRenderer'),
        PointRenderer: require('./layer/renderer/PointRenderer'),
        TextByFrequencyRenderer: require('./layer/renderer/TextByFrequencyRenderer'),
        TextScoreWeightedRenderer: require('./layer/renderer/TextScoreWeightedRenderer'),
		TextByTopicRenderer: require('./layer/renderer/TextByTopicRenderer'),
        WordCloudRenderer: require('./layer/renderer/WordCloudRenderer'),
        RenderTheme: require('./layer/renderer/RenderTheme'),

        // Map
        Map: require('./map/Map'),
        MapUtil: require('./map/MapUtil'),
        Marker: require('./map/Marker'),
        Axis: require('./map/Axis'),
        AxisUtil: require('./map/AxisUtil'),

        // REST
        AnnotationService: require('./rest/AnnotationService'),
        LayerService: require('./rest/LayerService'),
        LegendService: require('./rest/LegendService'),
        TileService: require('./rest/TileService'),

        // UI
        LayerControls: require('./ui/LayerControls'),

        // Util
        PubSub: require('./util/PubSub'),
        Util: require('./util/Util')
    };

}());

},{"./binning/AreaOfInterestTilePyramid":2,"./binning/TileIterator":3,"./binning/WebMercatorTilePyramid":4,"./layer/AnnotationLayer":5,"./layer/AxisLayer":6,"./layer/BaseLayer":7,"./layer/Carousel":8,"./layer/ClientLayer":9,"./layer/HtmlMarker":10,"./layer/HtmlMarkerLayer":11,"./layer/KMLLayer":14,"./layer/Layer":15,"./layer/LayerUtil":16,"./layer/MultiUrlClientLayer":17,"./layer/ServerLayer":20,"./layer/VectorLayer":23,"./layer/renderer/GraphLabelRenderer":24,"./layer/renderer/GraphNodeRenderer":25,"./layer/renderer/PointAggregateRenderer":26,"./layer/renderer/PointRenderer":27,"./layer/renderer/RenderTheme":28,"./layer/renderer/Renderer":29,"./layer/renderer/RendererUtil":30,"./layer/renderer/TextByFrequencyRenderer":31,"./layer/renderer/TextByTopicRenderer":32,"./layer/renderer/TextScoreWeightedRenderer":33,"./layer/renderer/WordCloudRenderer":34,"./layer/renderer/aggregator/Aggregator":35,"./layer/renderer/aggregator/FrequenciesByTopicAggregator":36,"./layer/renderer/aggregator/FrequencyArraysByTopicAggregator":37,"./layer/renderer/aggregator/TopicCountAggregator":38,"./layer/renderer/aggregator/TopicCountArrayAggregator":39,"./layer/renderer/aggregator/TopicFrequencyAggregator":40,"./layer/renderer/aggregator/TweetsByTopicAggregator":41,"./map/Axis":42,"./map/AxisUtil":43,"./map/Map":44,"./map/MapUtil":45,"./map/Marker":46,"./rest/AnnotationService":47,"./rest/LayerService":48,"./rest/LegendService":49,"./rest/TileService":50,"./ui/LayerControls":53,"./util/PubSub":59,"./util/Util":60}],2:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

	"use strict";

    /**
     * Instantiate an AreaOfInterestTilePyramid object.
     * @class AreaOfInterestTilePyramid
     * @classdesc A TilePyramid implementation, the equivalent of AOITilePyramid in
     *            tile-service/binning-utilities.
     *
     * @param {Object} spec - The specification object.
     */
	function AreaOfInterestTilePyramid( spec ) {
        this.minX = spec.minX;
        this.minY = spec.minY;
        this.maxX = spec.maxX;
        this.maxY = spec.maxY;
    }

    /**
     * Returns the projection code associated with the pyramid.
     * @memberof AreaOfInterestTilePyramid
     *
     * @returns {string} The projection code.
     */
    AreaOfInterestTilePyramid.prototype.getProjection = function() {
        return "EPSG:4326";
    };

    /**
     * Returns the tile scheme associated with the pyramid.
     * @memberof AreaOfInterestTilePyramid
     *
     * @returns {string} The scheme code.
     */
	AreaOfInterestTilePyramid.prototype.getTileScheme = function() {
        return "TMS";
    };

    /**
     * Maps a fractional tile coordinate to a point in the root coordinate system.
     * @memberof AreaOfInterestTilePyramid
     *
     * @param {Object} tile - The fractional tile coordinate.
     *
     * @returns {Object} The root coordinate.
     */
    AreaOfInterestTilePyramid.prototype.fractionalTileToRoot = function( tile ) {
        var pow2, tileXSize, tileYSize;
        pow2 = 1 << tile.level;
        tileXSize = (this.maxX - this.minX) / pow2;
        tileYSize = (this.maxY - this.minY) / pow2;
        return {
            x: this.minX + tileXSize * tile.xIndex,
            y: this.minY + tileYSize * tile.yIndex
        };
    };

    /**
     * Maps a point from the root coordinate system to a fractional tile coordinate.
     * @memberof AreaOfInterestTilePyramid
     *
     * @param {number} x - The x root coordinate value.
     * @param {number} y - The y root coordinate value.
     * @param {integer} level - The zoom level.
     * @param {integer} bins - The number of bins per dimension in a tile.
     *
     * @returns {Object} The fractional tile coordinate.
     */
	AreaOfInterestTilePyramid.prototype.rootToFractionalTile = function( x, y, level, bins ) {
		bins = bins || 256;
        var numDivs, tileX, tileY;
        numDivs = 1 << level;
        tileX = numDivs * (x - this.minX) / (this.maxX - this.minX);
        tileY = numDivs * (y - this.minY) / (this.maxY - this.minY);
        return {
            'level': level,
            'xIndex': tileX,
            'yIndex': tileY,
            xBinCount: bins,
            yBinCount: bins
        };
    };

    /**
     * Maps a point from the root coordinate system to a tile coordinate.
     * @memberof AreaOfInterestTilePyramid
     *
     * @param {number} x - The x root coordinate value.
     * @param {number} y - The y root coordinate value.
     * @param {integer} level - The zoom level.
     * @param {integer} bins - The number of bins per dimension in a tile.
     *
     * @returns {Object} The tile coordinate.
     */
    AreaOfInterestTilePyramid.prototype.rootToTile = function( x, y, level, bins ) {
		var result = this.rootToFractionalTile( x, y, level, bins );
		result.xIndex = Math.floor( result.xIndex );
		result.yIndex = Math.floor( result.yIndex );
		return result;
    };

	/**
     * Maps a point from the root coordinate system to a specific bin fractional
	 * coordinate.
     * @memberof AreaOfInterestTilePyramid
     *
     * @param {number} x - The x root coordinate value.
     * @param {number} y - The y root coordinate value.
     * @param {Object} tile - The tile coordinate that holds the target bin.
     *
     * @returns {Object} The bin coordinate.
     */
    AreaOfInterestTilePyramid.prototype.rootToFractionalBin = function( x, y, tile ) {
        var pow2, tileXSize, tileYSize, xInTile, yInTile, binX, binY;
        pow2 = 1 << tile.level;
        tileXSize = (this.maxX - this.minX) / pow2;
        tileYSize = (this.maxY - this.minY) / pow2;
        xInTile = x - this.minX - tile.xIndex * tileXSize;
        yInTile = y - this.minY - tile.yIndex * tileYSize;
        binX = xInTile * tile.xBinCount / tileXSize;
        binY = yInTile * tile.yBinCount / tileYSize;
        return {
            x: binX,
            y: tile.yBinCount - 1 - binY
        };
    };

	/**
     * Maps a point from the root coordinate system to a specific bin coordinate.
     * @memberof AreaOfInterestTilePyramid
     *
     * @param {number} x - The x root coordinate value.
     * @param {number} y - The y root coordinate value.
     * @param {Object} tile - The tile coordinate that holds the target bin.
     *
     * @returns {Object} The bin coordinate.
     */
    AreaOfInterestTilePyramid.prototype.rootToBin = function( x, y, tile ) {
		var result = this.rootToFractionalBin( x, y, tile );
		result.x = Math.floor( result.x );
		result.y = Math.floor( result.y );
        return result;
    };

    /**
     * Maps a point from the root coordinate system to a specific bin coordinate.
     * @memberof AreaOfInterestTilePyramid
     *
     * @param {number} x - The x root coordinate value.
     * @param {number} y - The y root coordinate value.
     * @param {Object} tile - The tile coordinate that holds the target bin.
     *
     * @returns {Object} The bin coordinate.
     */
    AreaOfInterestTilePyramid.prototype.rootToBin = function( x, y, tile ) {
        var pow2, tileXSize, tileYSize, xInTile, yInTile, binX, binY;
        pow2 = 1 << tile.level;
        tileXSize = (this.maxX - this.minX) / pow2;
        tileYSize = (this.maxY - this.minY) / pow2;
        xInTile = x - this.minX - tile.xIndex * tileXSize;
        yInTile = y - this.minY - tile.yIndex * tileYSize;
        binX = Math.floor(xInTile * tile.xBinCount / tileXSize);
        binY = Math.floor(yInTile * tile.yBinCount / tileYSize);
        return {
            x: binX,
            y: tile.yBinCount - 1 - binY
        };
    };

    /**
     * Returns the bounds of a particular tile in the root coordinate system.
     * @memberof AreaOfInterestTilePyramid
     *
     * @param {Object} tile - The tile coordinate.
     *
     * @returns {Object} The bounds object.
     */
    AreaOfInterestTilePyramid.prototype.getTileBounds = function( tile ) {
        var pow2, tileXSize, tileYSize;
        pow2 = 1 << tile.level;
        tileXSize = (this.maxX - this.minX) / pow2;
        tileYSize = (this.maxY - this.minY) / pow2;
        return {
            minX: this.minX + tileXSize * tile.xIndex,
            minY: this.minY + tileYSize * tile.yIndex,
            maxX: this.minX + tileXSize * (tile.xIndex + 1),
            maxY: this.minY + tileYSize * (tile.yIndex + 1),
            centerX: this.minX + tileXSize * (tile.xIndex + 0.5),
            centerY: this.minY + tileYSize * (tile.yIndex + 0.5),
            width: tileXSize,
            height: tileYSize
        };
    };

    /**
     * Returns the bounds of a particular bin in the root coordinate system.
     * @memberof AreaOfInterestTilePyramid
     *
     * @param {Object} tile - The tile coordinate.
     * @param {Object} bin - The bin coordinate.
     *
     * @returns {Object} The bounds object.
     */
    AreaOfInterestTilePyramid.prototype.getBinBounds = function( tile, bin ) {
        var pow2, tileXSize, tileYSize, binXSize, binYSize, adjustedY,
            left, bottom;
        pow2 = 1 << tile.level;
        tileXSize = (this.maxX - this.minX) / pow2;
        tileYSize = (this.maxY - this.minY) / pow2;
        binXSize = tileXSize / tile.xBinCount;
        binYSize = tileYSize / tile.yBinCount;
        adjustedY = tile.yBinCount - 1 - bin.y;
        left = this.minX + tileXSize * tile.xIndex;
        bottom = this.minY + tileYSize * tile.yIndex;
        return {
            minX: left + binXSize * bin.x,
            minY: bottom + binYSize * adjustedY,
            maxX: left + binXSize * (bin.x + 1),
            maxY: bottom + binYSize * (adjustedY + 1),
            centerX: left + binXSize * (bin.x + 0.5),
            centerY: bottom + binYSize * (adjustedY + 0.5),
            width: binXSize,
            height: binYSize
        };
    };

    /**
     * Returns the JSON representation of this tile pyramid as a string.
     * @memberof AreaOfInterestTilePyramid
     *
     * @returns {String} The bounds object.
     */
    AreaOfInterestTilePyramid.prototype.toJSON = function() {
        return '{'+
            '"type": "AreaOfInterest",' +
            '"minX": this.minX,' +
            '"maxX": this.maxX,' +
            '"minY": this.minY,' +
            '"maxY": this.maxY' +
        '}';
    };

	module.exports = AreaOfInterestTilePyramid;

}());

},{}],3:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * @package binning
 */
( function() {

    "use strict";

    /**
     * Instantiate a TileIterator object.

     * @class TileIterator
     * @classdesc A TileIterator class, the equivalent of TileIterator
     *            in tile-service/binning-utilities.
     *
     * @param {Object} spec - The specification object.
     */
    function TileIterator( spec ) {
        this.pyramid = spec.pyramid;
        this.level = spec.level;
        this.minTile = spec.pyramid.rootToTile( spec.minX, spec.minY, spec.level );
        this.maxTile = spec.pyramid.rootToTile( spec.maxX, spec.maxY, spec.level );
        this.curX = this.minTile.xIndex;
        this.curY = this.minTile.yIndex;
    }

    /**
     * Returns true if there is another tile, false if there isn't.
     * @memberof TileIterator
     *
     * @returns {boolean} Whether or not a next tile exists.
     */
    TileIterator.prototype.hasNext = function() {
        return (this.curX <= this.maxTile.xIndex &&
                this.curY <= this.maxTile.yIndex);
    };

    /**
     * Returns the next tile in the iterator.
     * @memberof TileIterator
     *
     * @returns {Object} The next tile object.
     */
    TileIterator.prototype.next = function() {
        var tile = {
            xIndex: this.curX,
            yIndex: this.curY,
            level: this.level,
            xBinCount: 256,
            yBinCount: 256
        };
        this.curX = this.curX + 1;
        if ( this.curX > this.maxTile.xIndex ) {
            this.curX = this.minTile.xIndex;
            this.curY = this.curY + 1;
        }
        return tile;
    };

    /**
     * Returns an array of all remaining tiles the iterator.
     * @memberof TileIterator
     *
     * @returns {Array} All tiles left in the iterator.
     */
    TileIterator.prototype.getRest = function () {
        var all = [];
        while (this.hasNext()) {
            all[all.length] = this.next();
        }
        return all;
    };

    /**
     * Returns a string containing all remaining tile indices in the iterator.
     * @memberof TileIterator
     *
     * @returns {String} The next tile object.
     */
    TileIterator.prototype.toString = function () {
        var srep = "", index;
        while ( this.hasNext() ) {
            if ( srep.length > 0 ) {
                srep = srep + "|";
            }
            index = this.next();
            srep = srep + "["+index.xIndex+"/"+index.xBinCount+","+index.yIndex+"/"+index.yBinCount+", lvl "+index.level+"]";
        }
        return srep;
    };

    /**
     * Returns the tile bounds of all tiles within the iterator.
     * @memberof TileIterator
     *
     * @returns {Object} The tile bounds of the iterator.
     */
    TileIterator.prototype.toTileBounds = function () {
        return {
            'minX': this.minTile.xIndex,
            'maxX': this.maxTile.xIndex,
            'minY': this.minTile.yIndex,
            'maxY': this.maxTile.yIndex,
            'minZ': this.level,
            'maxZ': this.level
        };
    };

    module.exports = TileIterator;
}());


},{}],4:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

	"use strict";

	var EPSG_900913_SCALE_FACTOR = 20037508.342789244,
	    EPSG_900913_LATITUDE = 85.05112878,
	    DEGREES_TO_RADIANS = Math.PI / 180.0,	// Factor for changing degrees to radians
	    RADIANS_TO_DEGREES = 180.0 / Math.PI;	// Factor for changing radians to degrees

	function rootToTileMercator( lon, lat, level ) {
		var latR = lat * DEGREES_TO_RADIANS,
		    pow2 = 1 << level,
		    x = (lon + 180.0) / 360.0 * pow2,
		    y = (pow2 * (1 - Math.log(Math.tan(latR) + 1 / Math.cos(latR)) / Math.PI) / 2);
		return {
            x: x,
            y: pow2 - y
        };
	}

    function sinh( arg ) {
        return (Math.exp(arg) - Math.exp(-arg)) / 2.0;
    }

	function tileToLon( x, level ) {
		var pow2 = 1 << level;
		return x / pow2 * 360.0 - 180.0;
	}

	function tileToLat( y, level ) {
		var pow2 = 1 << level,
		    n    = -Math.PI + (2.0 * Math.PI * y) / pow2;
		return Math.atan(sinh(n)) * RADIANS_TO_DEGREES;
	}

	function linearToGudermannian( value ) {
		function gudermannian( y ) {
			// converts a y value from -PI(bottom) to PI(top) into the
			// mercator projection latitude
			return Math.atan(sinh(y)) * RADIANS_TO_DEGREES;
		}
		return gudermannian( (value / EPSG_900913_LATITUDE) * Math.PI );
	}

	function gudermannianToLinear(value) {
		function gudermannianInv( latitude ) {
			// converts a latitude value from -EPSG_900913_LATITUDE to EPSG_900913_LATITUDE into
			// a y value from -PI(bottom) to PI(top)
			var sign = ( latitude !== 0 ) ? latitude / Math.abs(latitude) : 0,
			    sin = Math.sin(latitude * DEGREES_TO_RADIANS * sign);
			return sign * (Math.log((1.0 + sin) / (1.0 - sin)) / 2.0);
		}
		return (gudermannianInv( value ) / Math.PI) * EPSG_900913_LATITUDE;
	}

    /**
     * Instantiate a WebMercatorTilePyramid object.
     * @class WebMercatorTilePyramid
     * @classdesc A TilePyramid implementation, the equivalent of WebMercatorTilePyramid
     *            in tile-service/binning-utilities.
     */
	function WebMercatorTilePyramid() {
        this.minX = -180.0;
        this.minY = -85.05;
        this.maxX = 180.0;
        this.maxY = 85.05;
        return this;
    }

    /**
     * Returns the projection code associated with the pyramid.
     * @memberof WebMercatorTilePyramid
     *
     * @returns {string} The projection code.
     */
    WebMercatorTilePyramid.prototype.getProjection = function(){
        return "EPSG:900913";
    };

    /**
     * Returns the tile scheme associated with the pyramid.
     * @memberof WebMercatorTilePyramid
     *
     * @returns {string} The scheme code.
     */
    WebMercatorTilePyramid.prototype.getTileScheme = function() {
        return "TMS";
    };

    /**
     * Maps a fractional tile coordinate to a point in the root coordinate system.
     * @memberof WebMercatorTilePyramid
     *
     * @param {Object} tile - The fractional tile coordinate.
     *
     * @returns {Object} The root coordinate.
     */
    WebMercatorTilePyramid.prototype.fractionalTileToRoot = function( tile ) {
        return {
            lon: tileToLon( tile.xIndex, tile.level ),
            lat: tileToLat( tile.yIndex, tile.level )
        };
    };

    /**
     * Maps a point from the root coordinate system to a fractional tile coordinate.
     * @memberof WebMercatorTilePyramid
     *
     * @param {number} lon - The longitude coordinate value.
     * @param {number} lat - The latitude coordinate value.
     * @param {integer} level - The zoom level.
     * @param {integer} bins - The number of bins per dimension in a tile.
     *
     * @returns {Object} The fractional tile coordinate.
     */
    WebMercatorTilePyramid.prototype.rootToFractionalTile = function( lon, lat, level, bins ) {
		bins = bins || 256;
        var tileMercator = rootToTileMercator( lon, lat, level );
        return {
            level: level,
            xIndex: tileMercator.x,
            yIndex: tileMercator.y,
            xBinCount: bins,
            yBinCount: bins
        };
    };

    /**
     * Maps a point from the root coordinate system to a tile coordinate.
     * @memberof WebMercatorTilePyramid
     *
     * @param {number} lon - The longitude coordinate value.
     * @param {number} lat - The latitude coordinate value.
     * @param {integer} level - The zoom level.
     * @param {integer} bins - The number of bins per dimension in a tile.
     *
     * @returns {Object} The tile coordinate.
     */
    WebMercatorTilePyramid.prototype.rootToTile = function( lon, lat, level, bins ) {
		var result = this.rootToFractionalTile( lon, lat, level, bins );
		result.xIndex = Math.floor( result.xIndex );
		result.yIndex = Math.floor( result.yIndex );
		return result;
    };

	/**
     * Maps a point from the root coordinate system to a specific fractional
	 * bin coordinate.
     * @memberof WebMercatorTilePyramid
     *
     * @param {number} lon - The longitude coordinate value.
     * @param {number} lat - The latitude coordinate value.
     * @param {Object} tile - The tile coordinate that holds the target bin.
     *
     * @returns {Object} The bin coordinate.
     */
    WebMercatorTilePyramid.prototype.rootToFractionalBin = function( lon, lat, tile ) {
        var tileMercator = rootToTileMercator( lon, lat, tile.level );
        return {
            x: (tileMercator.x - tile.xIndex) * tile.xBinCount,
            y: tile.yBinCount - 1 - (tileMercator.y - tile.yIndex ) * tile.yBinCount
        };
    };

    /**
     * Maps a point from the root coordinate system to a specific bin coordinate.
     * @memberof WebMercatorTilePyramid
     *
     * @param {number} lon - The longitude coordinate value.
     * @param {number} lat - The latitude coordinate value.
     * @param {Object} tile - The tile coordinate that holds the target bin.
     *
     * @returns {Object} The bin coordinate.
     */
    WebMercatorTilePyramid.prototype.rootToBin = function( lon, lat, tile ) {
		var result = this.rootToFractionalBin( lon, lat, tile );
		result.x = Math.floor( result.x );
		result.y = Math.floor( result.y );
        return result;
    };

    /**
     * Returns the bounds of a particular tile in EPSG 900913 meter units.
     * @memberof WebMercatorTilePyramid
     *
     * @param {Object} tile - The tile coordinate.
     * @param {Object} bin - The bin coordinate.
     *
     * @returns {Object} The bounds object.
     */
    WebMercatorTilePyramid.prototype.getEPSG900913Bounds = function( tile, bin ) {
        var pow2 = 1 << tile.level,
            tileIncrement = 1.0/pow2,
            minX = tile.xIndex * tileIncrement - 0.5,
            minY = tile.yIndex * tileIncrement - 0.5,
            maxX,
            maxY,
            linMinY,
            linMaxY,
            binXInc,
            binYInc,
            centerY;

        if ( bin ) {
            maxX = minX + tileIncrement;
            maxY = minY + tileIncrement;
        } else {
            binXInc = tileIncrement / tile.xBinCount;
            binYInc = tileIncrement / tile.yBinCount;
            minX = minX + bin.x * binXInc;
            minY = minY + (tile.yBinCount - bin.y - 1) * binYInc;
            maxX = minX + binXInc;
            maxY = minY + binYInc;
        }

        // as mercator latitude cannot be linearly interpolated, convert the gudermannian
        // coordinates back into their equivalent linear counterparts. Interpolate these,
        // then convert to the equivalent gudermannian coordinate.
        linMaxY = gudermannianToLinear( maxY );
        linMinY = gudermannianToLinear( minY );
        centerY = linearToGudermannian( (linMaxY+linMinY)/2 );

        return {
            minX:    minX * 2.0 * EPSG_900913_SCALE_FACTOR,
            minY:    minY * 2.0 * EPSG_900913_SCALE_FACTOR,
            maxX:    maxX * 2.0 * EPSG_900913_SCALE_FACTOR,
            maxY:    maxY * 2.0 * EPSG_900913_SCALE_FACTOR,
            centerX: (minX + maxX) * EPSG_900913_SCALE_FACTOR, // (minX+maxX)/2.0*2.0 optimized to (minX+maxX)
            centerY: centerY * 2.0 * EPSG_900913_SCALE_FACTOR,
            width:   (maxX - minX) * 2.0 * EPSG_900913_SCALE_FACTOR,
            height:  (maxY - minY) * 2.0 * EPSG_900913_SCALE_FACTOR
        };
    };

    /**
     * Returns the bounds of a particular tile in the root coordinate system.
     * @memberof WebMercatorTilePyramid
     *
     * @param {Object} tile - The tile coordinate.
     *
     * @returns {Object} The bounds object.
     */
    WebMercatorTilePyramid.prototype.getTileBounds = function( tile ) {
        var level = tile.level,
            north = tileToLat( tile.yIndex+1, level ),
            south = tileToLat( tile.yIndex, level ),
            east = tileToLon( tile.xIndex+1, level ),
            west = tileToLon( tile.xIndex, level ),
            // as mercator latitude cannot be linearly interpolated, convert the gudermannian
            // coordinates back into their equivalent linear counterparts. Interpolate these,
            // then convert to the equivalent gudermannian coordinate.
            linNorth = gudermannianToLinear( north ),
            linSouth = gudermannianToLinear( south ),
            centerY = linearToGudermannian( (linNorth+linSouth)/2.0 );
        return {
            minX: west,
            minY: south,
            maxX: east,
            maxY: north,
            centerX: (east+west)/2.0,
            centerY: centerY,
            width: (east-west),
            height: (north-south)
        };
    };

    /**
     * Returns the bounds of a particular bin in the root coordinate system.
     * @memberof WebMercatorTilePyramid
     *
     * @param {Object} tile - The tile coordinate.
     * @param {Object} bin - The bin coordinate.
     *
     * @returns {Object} The bounds object.
     */
    WebMercatorTilePyramid.prototype.getBinBounds = function( tile, bin ) {
        var level = tile.level,
            binXInc = 1.0 / tile.xBinCount,
            baseX = tile.xIndex + bin.x * binXInc,
            binYInc = 1.0 / tile.yBinCount,
            baseY = tile.yIndex + (tile.yBinCount - 1 - bin.y) * binYInc,
            north = tileToLat(baseY + binYInc, level),
            south = tileToLat(baseY, level),
            east = tileToLon(baseX + binXInc, level),
            west = tileToLon(baseX, level),
            // as mercator latitude cannot be linearly interpolated, convert the gudermannian
            // coordinates back into their equivalent linear counterparts. Interpolate these,
            // then convert to the equivalent gudermannian coordinate.
            linNorth = gudermannianToLinear(north),
            linSouth = gudermannianToLinear(south),
            centerY = linearToGudermannian( (linNorth+linSouth)/2.0 );
        return {
            minX: west,
            minY: south,
            maxX: east,
            maxY: north,
            centerX: (east+west)/2.0,
            centerY: centerY,
            width: (east-west),
            height: (north-south)
        };
    };

    /**
     * Returns the JSON representation of this tile pyramid as a string.
     * @memberof WebMercatorTilePyramid
     *
     * @returns {String} The bounds object.
     */
    WebMercatorTilePyramid.prototype.toJSON = function () {
        return '{'+
            '"type": "WebMercator"'+
        '}';
    };

	module.exports = WebMercatorTilePyramid;
}());

},{}],5:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Layer = require('./Layer'),
        LayerUtil = require('./LayerUtil'),
        Util = require('../util/Util'),
        AnnotationService = require('../rest/AnnotationService'),
        HtmlTileLayer = require('./HtmlTileLayer'),
        PubSub = require('../util/PubSub');

    /**
     * Ensures an annotation object meets the minimum attribute requirements.
     *
     * @param {Object} annotation - The annotation object.
     *
     * @returns {boolean} Whether or not the input is valid.
     */
    function isAnnotationInputValid( annotation ) {
        if ( annotation.x === undefined ) {
            console.error( "Annotation argument is missing the 'x' attribute");
            return false;
        }
        if ( annotation.y === undefined ) {
            console.error( "Annotation argument is missing the 'y' attribute");
            return false;
        }
        if ( annotation.level === undefined ) {
            console.error( "Annotation argument is missing the 'level' attribute");
            return false;
        }
        if ( annotation.range === undefined ) {
            console.error( "Annotation argument is missing the 'range' attribute");
            return false;
        }
        if ( annotation.group === undefined ) {
            console.error( "Annotation argument is missing the 'group' attribute");
            return false;
        }
        if ( annotation.data === undefined ) {
            console.error( "Annotation argument is missing the 'data' attribute");
            return false;
        }
        return true;
    }

    /**
     * Instantiate an AnnotationLayer object.
     * @class AnnotationLayer
     * @augments Layer
     * @classdesc A client rendered layer object. Uses JSON data retrieved from the
     *            server in conjunction with a Renderer object or html function to
     *            create interactable DOM elements. AnnotationLayers differ from
     *            ClientLayers in that the data they represent is mutable.
     *
     * @param {Object} spec - The specification object.
     * <pre>
     * {
     *     opacity  {float}    - The opacity of the layer. Default = 1.0
     *     enabled  {boolean}  - Whether the layer is visible or not. Default = true
     *     zIndex   {integer}  - The z index of the layer. Default = 1000
     *     renderer {Renderer} - The tile renderer object.
     * }
     * </pre>
     */
    function AnnotationLayer( spec ) {
        var that = this,
            getURL = spec.getURL || LayerUtil.getURL;
        // call base constructor
        Layer.call( this, spec );
        // set reasonable defaults
        this.zIndex = ( spec.zIndex !== undefined ) ? parseInt( spec.zIndex, 10 ) : 500;
        this.filter = spec.filter || {};
        this.domain = "annotation";
        this.source = spec.source;
        this.getURL = function( bounds ) {
            return getURL.call( this, bounds ) + that.getQueryParamString();
        };
        if ( spec.tileClass) {
            this.tileClass = spec.tileClass;
        }
        if ( spec.renderer ) {
            this.setRenderer( spec.renderer );
        }
    }

    AnnotationLayer.prototype = Object.create( Layer.prototype );

    /**
     * Activates the layer object. This should never be called manually.
     * @memberof AnnotationLayer
     * @private
     */
    AnnotationLayer.prototype.activate = function() {
        // add the new layer
        this.olLayer = new HtmlTileLayer(
            'Annotation Tile Layer',
            this.source.tms,
            {
                layername: this.source.id,
                type: 'json',
                maxExtent: new OpenLayers.Bounds(-20037500, -20037500,
                    20037500,  20037500),
                isBaseLayer: false,
                getURL: this.getURL,
                tileClass: this.tileClass,
                renderer: this.renderer
            });
        // set whether it is enabled or not before attaching, to prevent
        // needless tile requests
        this.setEnabled( this.isEnabled() );
        this.setTheme( this.map.getTheme() );
        this.setOpacity( this.getOpacity() );
        this.setBrightness( this.getBrightness() );
        this.setContrast( this.getContrast() );
        // publish activate event before appending to map
        PubSub.publish( this.getChannel(), { field: 'activate', value: true } );
        // attach to map
        this.map.olMap.addLayer( this.olLayer );
        // set z-index after
        this.setZIndex( this.zIndex );
        // publish add event
        PubSub.publish( this.getChannel(), { field: 'add', value: true } );
    };

    /**
     * Dectivates the layer object. This should never be called manually.
     * @memberof AnnotationLayer
     * @private
     */
    AnnotationLayer.prototype.deactivate = function() {
        if ( this.olLayer ) {
            this.map.olMap.removeLayer( this.olLayer );
            PubSub.publish( this.getChannel(), { field: 'remove', value: true } );
            this.olLayer.destroy();
            this.olLayer = null;
        }
        PubSub.publish( this.getChannel(), { field: 'deactivate', value: true } );
    };

    /**
     * Sets the current renderer of the layer.
     * @memberof AnnotationLayer
     *
     * @param {Renderer} renderer - The renderer to attach to the layer.
     */
     AnnotationLayer.prototype.setRenderer = function( renderer ) {
        this.renderer = renderer;
        this.renderer.attach( this );
    };

    /**
     * Updates the theme associated with the layer.
     * @memberof AnnotationLayer
     *
     * @param {String} theme - The theme identifier string.
     */
    AnnotationLayer.prototype.setTheme = function( theme ) {
        this.theme = theme;
    };

    /**
     * Get the current theme for the layer.
     * @memberof AnnotationLayer
     *
     * @returns {String} The theme identifier string.
     */
    AnnotationLayer.prototype.getTheme = function() {
        return this.theme;
    };

    /**
     * Set the z index of the layer.
     * @memberof AnnotationLayer
     *
     * @param {integer} zIndex - The new z-order value of the layer, where 0 is front.
     */
    AnnotationLayer.prototype.setZIndex = function ( zIndex ) {
        // we by-pass the OpenLayers.Map.setLayerIndex() method and manually
        // set the z-index of the layer dev. setLayerIndex sets a relative
        // index based on current map layers, which then sets a z-index. This
        // caused issues with async layer loading.
        this.zIndex = zIndex;
        if ( this.olLayer ) {
            $( this.olLayer.div ).css( 'z-index', zIndex );
        }
        PubSub.publish( this.getChannel(), { field: 'zIndex', value: zIndex });
    };

    /**
     * Get the layers zIndex.
     * @memberof AnnotationLayer
     *
     * @returns {integer} The zIndex for the layer.
     */
    AnnotationLayer.prototype.getZIndex = function () {
        return this.zIndex;
    };

    /**
     * Write the a new annotation to the layer.
     * @memberof AnnotationLayer
     *
     * @param {Object} annotation - The target annotation.
     * @param {Function} callback - The callback function executing on success.
     */
    AnnotationLayer.prototype.write = function( annotation, callback ) {
        if ( !isAnnotationInputValid( annotation ) ) {
            return;
        }
        AnnotationService.writeAnnotation(
            this.source.id,
            annotation,
            function() {
                // TODO: refresh tile
                callback();
            });
    };

    /**
     * Modify an existing annotation in the layer.
     * @memberof AnnotationLayer
     *
     * @param {Object} annotation - The target annotation.
     * @param {Function} callback - The callback function executing on success.
     */
    AnnotationLayer.prototype.modify = function( annotation, callback ) {
        if ( !isAnnotationInputValid( annotation ) ) {
            return;
        }
        AnnotationService.modifyAnnotation(
            this.source.id,
            annotation,
            function() {
                // TODO: refresh tile
                callback();
            });
    };

    /**
     * Remove an existing annotation from the layer.
     * @memberof AnnotationLayer
     *
     * @param {Object} certificate - The target annotation certificate.
     * @param {Function} callback - The callback function executing on success.
     */
    AnnotationLayer.prototype.remove = function( certificate, callback ) {
        AnnotationService.removeAnnotation(
            this.source.id,
            certificate,
            function() {
               // TODO: refresh tile
                callback();
            });
    };

	/**
     * Set the layer's filter function type.
     * @memberof AnnotationLayer
     *
     * @param {String} filterType - The annotation filter type.
     */
    AnnotationLayer.prototype.setFilterType = function ( filterType ) {
        if ( this.filter.type !== filterType ) {
            this.filter.type = filterType;
            this.redraw();
            PubSub.publish( this.getChannel(), {field: 'filterType', value: filterType} );
        }
    };

    /**
     * Get the layers filter type.
     * @memberof AnnotationLayer
     *
     * @return {String} The tile filter type.
     */
    AnnotationLayer.prototype.getFilterType = function () {
        return this.filter.type;
    };


	/**
     * Set the annotation filter data attribute
     * @memberof AnnotationLayer
     *
     * @param {Object} filterData - The filter data attribute.
     */
    AnnotationLayer.prototype.setFilterData = function ( filterData ) {
        if ( this.filter.data !== filterData ) {
            this.filter.data = filterData;
            this.redraw();
            PubSub.publish( this.getChannel(), {field: 'filterData', value: filterData} );
        }
    };

	/**
     * Get the filter data attribute.
     * @memberof AnnotationLayer
     *
     * @returns {Object} The tile filter data attribute.
     */
    AnnotationLayer.prototype.getFilterData = function () {
        return this.filter.data || {};
    };

    /**
     * Generate query parameters based on state of layer
     * @memberof AnnotationLayer
     *
     * @returns {String} The query parameter string based on the attributes of this layer.
     */
     AnnotationLayer.prototype.getQueryParamString = function() {
        var query = {
            filter: this.filter
        };
        return Util.encodeQueryParams( query );
    };

    /**
     * Redraws the entire layer.
     * @memberof ServerLayer
     */
    AnnotationLayer.prototype.redraw = function () {
        if ( this.olLayer ) {
            this.olLayer.redraw();
            // If we're using the TileManager we need to force it into a refresh. There is no nice way to
            // do this as of 2.13.1, so we fake the expiry of the move/zoom timeout.
            if ( this.olLayer.map && this.olLayer.map.tileManager ) {
                this.olLayer.map.tileManager.updateTimeout(
                    this.olLayer.map,
                    this.olLayer.map.tileManager.zoomDelay,
                    true );
            }
        }
    };

    module.exports = AnnotationLayer;
}());

},{"../rest/AnnotationService":47,"../util/PubSub":59,"../util/Util":60,"./HtmlTileLayer":13,"./Layer":15,"./LayerUtil":16}],6:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Layer = require('./Layer'),
        LayerUtil = require('./LayerUtil'),
        UnivariateTileLayer = require('./UnivariateTileLayer'),
        PubSub = require('../util/PubSub');

    /**
     * Instantiate a AxisLayer object.
     * @class AxisLayer
     * @augments Layer
     * @classdesc A axis rendered layer object. Uses data received from the server and
     *            renders it over the axis.
     *
     * @param {Object} spec - The specification object.
     * <pre>
     * {
     *     opacity  {float}    - The opacity of the layer. Default = 1.0
     *     enabled  {boolean}  - Whether the layer is visible or not. Default = true
     *     zIndex   {integer}  - The z index of the layer. Default = 1000
     *     renderer {Renderer} - The tile renderer object.
     * }
     * </pre>
     */
    function AxisLayer( spec ) {
        // call base constructor
        Layer.call( this, spec );
        // set reasonable defaults
        this.zIndex = ( spec.zIndex !== undefined ) ? parseInt( spec.zIndex, 10 ) : 1500;
        this.domain = "axis";
        this.source = spec.source;
        this.getURL = spec.getURL || LayerUtil.getURL;
        this.dimension = spec.dimension || 'x';
        if ( spec.tileClass) {
            this.tileClass = spec.tileClass;
        }
        if ( spec.renderer ) {
            this.setRenderer( spec.renderer );
        }
    }

    AxisLayer.prototype = Object.create( Layer.prototype );

    /**
     * Activates the layer object. This should never be called manually.
     * @memberof AxisLayer
     * @private
     */
    AxisLayer.prototype.activate = function() {
        // add the new layer
        this.olLayer = new UnivariateTileLayer(
            'Axis Rendered Tile Layer',
            this.source.tms,
            {
                layername: this.source.id,
                type: 'json',
                maxExtent: new OpenLayers.Bounds(-20037500, -20037500,
                    20037500,  20037500),
                isBaseLayer: false,
                getURL: this.getURL,
                tileClass: this.tileClass,
                renderer: this.renderer,
                dimension: this.dimension
            });
        // set whether it is enabled or not before attaching, to prevent
        // needless tile requests
        this.setEnabled( this.isEnabled() );
        this.setTheme( this.map.getTheme() );
        this.setOpacity( this.getOpacity() );
        this.setBrightness( this.getBrightness() );
        this.setContrast( this.getContrast() );
        // publish activate event before appending to map
        PubSub.publish( this.getChannel(), { field: 'activate', value: true } );
        // attach to map
        this.map.olMap.addLayer( this.olLayer );
        // set z-index after
        this.setZIndex( this.zIndex );
        // publish add event
        PubSub.publish( this.getChannel(), { field: 'add', value: true } );
    };

    /**
     * Dectivates the layer object. This should never be called manually.
     * @memberof AxisLayer
     * @private
     */
    AxisLayer.prototype.deactivate = function() {
        if ( this.olLayer ) {
            this.map.olMap.removeLayer( this.olLayer );
            PubSub.publish( this.getChannel(), { field: 'remove', value: true } );
            this.olLayer.destroy();
            this.olLayer = null;
        }
        PubSub.publish( this.getChannel(), { field: 'deactivate', value: true } );
    };

    /**
     * Sets the current renderer of the layer.
     * @memberof AxisLayer
     *
     * @param {Renderer} renderer - The renderer to attach to the layer.
     */
     AxisLayer.prototype.setRenderer = function( renderer ) {
        this.renderer = renderer;
        this.renderer.attach( this );
    };

    /**
     * Updates the theme associated with the layer.
     * @memberof AxisLayer
     *
     * @param {String} theme - The theme identifier string.
     */
    AxisLayer.prototype.setTheme = function( theme ) {
        this.theme = theme;
    };

    /**
     * Get the current theme for the layer.
     * @memberof AxisLayer
     *
     * @returns {String} The theme identifier string.
     */
    AxisLayer.prototype.getTheme = function() {
        return this.theme;
    };

    /**
     * Set the z index of the layer.
     * @memberof AxisLayer
     *
     * @param {integer} zIndex - The new z-order value of the layer, where 0 is front.
     */
    AxisLayer.prototype.setZIndex = function ( zIndex ) {
        // we by-pass the OpenLayers.Map.setLayerIndex() method and manually
        // set the z-index of the layer dev. setLayerIndex sets a relative
        // index based on current map layers, which then sets a z-index. This
        // caused issues with async layer loading.
        this.zIndex = zIndex;
        if ( this.olLayer ) {
            $( this.olLayer.div ).css( 'z-index', zIndex );
        }
        PubSub.publish( this.getChannel(), { field: 'zIndex', value: zIndex });
    };

    /**
     * Get the layers zIndex.
     * @memberof AxisLayer
     *
     * @returns {integer} The zIndex for the layer.
     */
    AxisLayer.prototype.getZIndex = function () {
        return this.zIndex;
    };

    /**
     * Redraws the entire layer.
     * @memberof AxisLayer
     */
    AxisLayer.prototype.redraw = function () {
        if ( this.olLayer ) {
            this.olLayer.redraw();
            // If we're using the TileManager we need to force it into a refresh. There is no nice way to
            // do this as of 2.13.1, so we fake the expiry of the move/zoom timeout.
            if ( this.olLayer.map && this.olLayer.map.tileManager ) {
                this.olLayer.map.tileManager.updateTimeout(
                    this.olLayer.map,
                    this.olLayer.map.tileManager.zoomDelay,
                    true );
            }
        }
    };

    module.exports = AxisLayer;
}());

},{"../util/PubSub":59,"./Layer":15,"./LayerUtil":16,"./UnivariateTileLayer":22}],7:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

	"use strict";

	var Layer = require('./Layer'),
		PubSub = require('../util/PubSub');

    /**
     * Instantiate a BaseLayer object.
     * @class BaseLayer
     * @augments Layer
     * @classdesc A base layer object that serves as the underlying layer of the
     *            map. Supports blank baselayers that are simply a color, geographic
     *            baselayers using the Google Maps API, or standard TMS layers.
     *
     * @param spec {Object} The specification object.
     * <pre>
     * {
     *     type    {String}  - The type of baselayer, ["Blank", "Google", "TMS"]. Default = "Blank"
     *     opacity {float}   - The opacity of the layer. Default = 1.0
     *     enabled {boolean} - Whether the layer is visible or not. Default = true
     *     url     {String}  - if TMS layer, the url for tile requests. Default = undefined
     *     options {Object}  - type specific instantiation attributes. Default = {color:rgb(0,0,0)}
     * }
     *</pre>
     */
	 /*
	 * Edit By RilaShu 2018/03/06
	 * case addtion "WMTS"
	 * @param spec Addtion for WMTS (Tianditu)
	 * layername	{String} The layer identifier.  See the layer property.
     * style	{String} The layer style identifier.  See the style property.
     * matrixSet	{String} The tile matrix set identifier.  See the matrixSet property.
	 */
	function BaseLayer( spec ) {
        spec = spec || {};
        // call base constructor
        Layer.call( this, spec );
        // set defaults
        this.type = spec.type || "blank";
		this.url = spec.url;
		this.attribution = spec.attribution;
        this.options = spec.options || {
            color : "rgb(0,0,0)"
        };
        this.domain = "base";
		//set defaults addtion for WMTS
		this.layername = spec.layername || "vec";
		this.style = spec.style || "default";
		this.matrixSet = spec.matrixSet || "c";
    }

    BaseLayer.prototype = Object.create( Layer.prototype );

    /**
     * Activates the layer object. This should never be called manually.
     * @memberof BaseLayer
     * @private
     */
    BaseLayer.prototype.activate = function() {
        var styledMapType;
		// create base layer based on input type
        switch ( this.type.toLowerCase() ) {
            case "blank":
				// blank layer
                this.olLayer = new OpenLayers.Layer.Vector( "BaseLayer", {} );
				var mapElem = $( this.map.getElement() );
				mapElem.css( 'background-color', '' );
				mapElem.attr( 'style', mapElem.attr('style') + "; background-color: " + this.options.color +" !important" );
                break;
            case "google":
				// google maps layer
                if ( this.options.styles ) {
                    this.options.type = "styled";
                }
                this.olLayer = new OpenLayers.Layer.Google( "BaseLayer", this.options );
                break;
            case "tms":
				// tms layer
                this.olLayer = new OpenLayers.Layer.TMS( "BaseLayer", this.url, this.options );
                break;
			case "xyz":
				// xyz layer
                this.olLayer = new OpenLayers.Layer.XYZ( "BaseLayer", this.url, this.options );
                break;
			case "wmts":
			    // wmts layer
				this.olLayer = new OpenLayers.Layer.WMTS({name:"BaseLayer",url:this.url,layer:this.layername,style:this.style,matrixSet:this.matrixSet});
				break;
        }
		if ( this.attribution ) {
			$( this.map.getElement() ).append(
				'<div class=baselayer-attribution>' +
				this.attribution +
				'</div>' );
		}
        // publish activate event before appending to map
        PubSub.publish( this.getChannel(), { field: 'activate', value: true } );
		// create baselayer and set as baselayer
        this.map.olMap.addLayer( this.olLayer );
        this.map.olMap.setBaseLayer( this.olLayer );
		// if google maps layer, set styles according to spec
        if ( this.options.styles ) {
            styledMapType = new google.maps.StyledMapType( this.options.styles, {name: 'Styled Map'} );
            this.olLayer.mapObject.mapTypes.set( 'styled', styledMapType );
        }
		if ( this.olLayer.mapObject ) {
			var gmapContainer = this.olLayer.mapObject.getDiv();
			$( gmapContainer ).css( "background-color", "rgba(0,0,0,0)" );
		}
        // ensure baselayer remains bottom layer
		$( this.olLayer.div ).css( 'z-index', -1 );
        // reset visibility / opacity
        this.setOpacity( this.getOpacity() );
        this.setEnabled( this.isEnabled() );
        this.setBrightness( this.getBrightness() );
        this.setContrast( this.getContrast() );
        // publish add event
        PubSub.publish( this.getChannel(), { field: 'add', value: true } );
    };

    /**
     * Dectivates the layer object. This should never be called manually.
     * @memberof BaseLayer
     * @private
     */
    BaseLayer.prototype.deactivate = function() {
        if ( this.olLayer ) {
            this.map.olMap.removeLayer( this.olLayer );
            PubSub.publish( this.getChannel(), { field: 'remove', value: true } );
            this.olLayer.destroy();
        }
		if ( this.attribution ) {
			$( this.map.getElement() ).find('.baselayer-attribution').remove();
		}
        this.map.getElement().style['background-color'] = '';
        PubSub.publish( this.getChannel(), { field: 'deactivate', value: true } );
    };

	/**
     * Set the z index of the layer.
     * @memberof BaseLayer
     *
     * @param {integer} zIndex - The new z-order value of the layer, where 0 is front.
     */
	BaseLayer.prototype.resetZIndex = function () {
        // we by-pass the OpenLayers.Map.setLayerIndex() method and manually
        // set the z-index of the layer dev. setLayerIndex sets a relative
        // index based on current map layers, which then sets a z-index. This
        // caused issues with async layer loading.
        if ( this.olLayer ) {
            $( this.olLayer.div ).css( 'z-index', -1 );
        }
        PubSub.publish( this.getChannel(), { field: 'zIndex', value: -1 });
    };

	module.exports = BaseLayer;
}());

},{"../util/PubSub":59,"./Layer":15}],8:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Layer = require('./Layer'),
        ClientLayer = require('./ClientLayer'),
        LayerUtil = require('./LayerUtil'),
        Util = require('../util/Util'),
        HtmlTileLayer = require('./HtmlTileLayer'),
        PubSub = require('../util/PubSub');

    /**
     * Returns a function which, based on the carousel index for the particular
     * tile, will use the specification values from the associated layer to
     * pull tile data from the server.
     *
     * @param {Carousel} carousel - The carousel object.
     *
     * @returns {Function} The getURL function for the carousel.
     */
    function getURLFunction( carousel ) {
        return function( bounds ) {
            var tileIndex = LayerUtil.getTileIndex( this, bounds ),
                x = tileIndex.xIndex,
                y = tileIndex.yIndex,
                z = tileIndex.level,
                tilekey = z + "," + x + "," + y,
                layerIndex = carousel.getLayerIndexForTile( tilekey ),
                layerSpec = carousel.layerSpecs[ layerIndex ],
                type = layerSpec.type,
                url = layerSpec.url,
                layername = layerSpec.layername;
            if ( x >= 0 && y >= 0 ) {
                return url + layername + "/" + z + "/" + x + "/" + y + "." + type;
            }
        };
    }

    /**
     * Returns a function which, based on the carousel index for the particular
     * tile, will use the renderer from the associated layer.
     *
     * @param {Carousel} carousel - The carousel object.
     *
     * @returns {Function} The renderer function for the carousel.
     */
    function getRendererFunction( carousel ) {
        return function( bounds ) {
            var tilekey = LayerUtil.getTilekey( this, bounds ),
                layerIndex = carousel.getLayerIndexForTile( tilekey ),
                layerSpec = carousel.layerSpecs[ layerIndex ];
            return layerSpec.renderer;
        };
    }

    /**
     * OpenLayers stores tiles in a double array. To redraw an individual tile we
     * iterate through until we find the matching tilekey ( which is appended to
     * the tile in the HtmlTile class ).
     *
     * @param {OpenLayers.Layer} olLayer - The openlayers layer object.
     * @param {String} tilekey - The tile key string.
     */
    function redrawTile( olLayer, tilekey ) {
        var grid,
            i, j;
        for ( i=0; i<olLayer.grid.length; i++ ) {
            grid = olLayer.grid[i];
            for ( j=0; j<grid.length; j++ ) {
                if ( grid[j].tilekey === tilekey ) {
                    grid[j].draw( true );
                    return;
                }
            }
        }
    }

    /**
     * Patches the get/set functions of the attached layer in order to delegate
     * behaviour to and from the carousel.
     *
     * @param {Carousel} carousel - The carousel object.
     * @param {Layer} layer - The layer object to patch.
     */
    function patchLayer( carousel, layer ) {
        // override the layers opacity functions, setting the opacity of the carousel
        // will update the opacity of ALL layers.
        layer.setOpacity = function( opacity ) {
            var i;
            carousel.setOpacity( opacity );
            for ( i=0; i<carousel.layers.length; i++ ) {
                PubSub.publish( carousel.layers[i].getChannel(), { field: 'opacity', value: opacity } );
            }
        };
        layer.getOpacity = function() {
            return carousel.getOpacity();
        };
        // override the layers enable functions, enabling a particular layer
        // will disable all other layers attached to the carousel.
        layer.isEnabled = function() {
            if ( !carousel.isEnabled() ) {
                return false;
            }
            return carousel.layers.indexOf( layer ) === carousel.defaultIndex;
        };
        layer.setEnabled = function( enabled ) {
            var i;
            if ( enabled ) {
                carousel.setEnabled( true );
                carousel.setTileLayerIndices( carousel.layers.indexOf( layer ) );
                PubSub.publish( layer.getChannel(), { field: 'enabled', value: enabled } );
                for ( i=0; i<carousel.layers.length; i++ ) {
                    if ( carousel.layers[i] !== layer ) {
                        PubSub.publish( carousel.layers[i].getChannel(), { field: 'enabled', value: false } );
                    }
                }
            } else {
                carousel.setEnabled( false );
                PubSub.publish( layer.getChannel(), { field: 'enabled', value: false } );
            }
        };
        // override the layers z index functions
        layer.setZIndex = function( zIndex ) {
            carousel.setZIndex( zIndex );
        };
        layer.getZIndex = function() {
            return carousel.getZIndex();
        };
        // override the layers theme function
        layer.setTheme = function( theme ) {
            carousel.setTheme( theme );
        };
        // override redraw function
        layer.redraw = function() {
            carousel.olLayer.redraw();
        };
    }

        /**
         * Returns the layer to its original state be repairing the previously
         * patched methods.
         *
         * @param {Layer} layer - The layer object to patch.
         * @param {Object} layerSpec - The object containing the original methods.
         */
    function unpatchLayer( layer, layerSpec ) {
        // return all the layers functions to thier previous state
        layer.setOpacity = layerSpec.setOpacity;
        layer.getOpacity = layerSpec.getOpacity;
        layer.isEnabled = layerSpec.isEnabled;
        layer.setEnabled = layerSpec.setEnabled;
        layer.setZIndex = layerSpec.setZIndex;
        layer.setTheme = layerSpec.setTheme;
        layer.redraw = layerSpec.redraw;
    }

    /**
     * Instantiate a Carousel object to allow tile-by-tile control for all layers in
     * the carousel 'bundle'.
     * This object modifies the functionality from its bundled layer objects as follows:
     * <pre>
     *     1) Opacity is shared across all bundled layers.
     *     2) Z-Index is shared across all bundled layers.
     *     3) Theme is shared across all bundled layers.
     *     4) Enabling / disabling a layer will switch all tiles to that particular layer.
     * </pre>
     * @class Carousel
     * @augments Layer
     * @classdesc A carousel object to allow changing individual client renderered tiles.
     */
    function Carousel() {
        // call base constructor
        Layer.call( this, {} );
        // set reasonable defaults
        this.zIndex = 1500;
        this.domain = "carousel";
        this.layers = [];
        this.layerSpecs = [];
        this.indicesByTile = {};
        this.defaultIndex = 0;
    }

    Carousel.prototype = Object.create( ClientLayer.prototype );

    /**
     * Adds a client rendered layer to the carousel object. This involves
     * 'patching' the methods of the layer with those from the carousel to
     * give the required functionality.
     * @memberof Carousel
         *
     * @param {Layer} layer - The client rendered layer object.
     */
    Carousel.prototype.addLayer = function( layer ) {

        if ( !( layer instanceof ClientLayer ) ) {
            console.log( "Only ClientLayers can be added to a carousel object." );
            return;
        }

        if ( !this.map ) {
            // if there is no map it means that the carousel
            // has not been added yet, or the map is not ready
            // store the layer for later adding
            this.deferreds = this.deferreds || [];
            this.deferreds.push( layer );
            return;
        }

        // store the layer specification
        var layerSpec = {
                url: layer.source.tms,
                type: 'json',
                layername: layer.source.id,
                setOpacity: layer.setOpacity,
                getOpacity: layer.getOpacity,
                isEnabled: layer.isEnabled,
                setEnabled: layer.setEnabled,
                setZIndex: layer.setZIndex,
                setTheme: layer.setTheme,
                redraw: layer.redraw
            };
        // set the renderer parent to the carousel
        if ( layer.renderer ) {
            layerSpec.renderer = layer.renderer;
            layerSpec.renderer.meta = layer.source.meta.meta;
            layerSpec.renderer.parent = this;
        }
        layer.carousel = this;
        // store the layer and its specification
        this.layerSpecs.push( layerSpec );
        this.layers.push( layer );
        // patch the layer
        patchLayer( this, layer );
    };

    /**
     * Remove a layer from the carousel. This will 'unpatch' the
     * layers and return them to their original state.
     * @memberof Carousel
         *
     * @param {Layer} layer - The layer object.
     */
    Carousel.prototype.removeLayer = function( layer ) {

        if ( !this.map && this.deferreds ) {
            // if there is no map it means that the carousel
            // has not been added yet, so simply remove it from
            // the deferreds array.
            this.deferreds.splice( this.deferreds.indexOf( layer ), 1 );
            return;
        }

        var index = this.layers.indexOf( layer );
        if ( index !== -1 ) {
            if ( this.layers.length === 1 && this.map ) {
                console.log( 'A carousel must have at least one layer to be ' +
                             'attached to a map, remove the carousel from the map first.' );
                return;
            }
            if ( layer.renderer ) {
                // restore parent property of the renderer
                layer.renderer.parent = layer;
            }
            delete layer.carousel;
            unpatchLayer( layer, this.layerSpecs[ index ] );
            this.layers.splice( index, 1 );
            this.layerSpecs.splice( index, 1 );
            // set the default index accordingly
            if ( index < this.defaultIndex || this.defaultIndex === this.layers.length ) {
                this.defaultIndex--;
            }
            // reset view
            this.setTileLayerIndices( this.defaultIndex );
        }
    };

        /**
     * Activates the carousel object. This should never be called manually.
     * @memberof Carousel
     * @private
     */
    Carousel.prototype.activate = function() {

        if ( this.layers.length === 0 &&
            ( !this.deferreds || this.deferreds.length === 0 ) ) {
            console.log( 'A carousel must have at least one layer attached ' +
                         'before it can be added to a map.');
            return;
        }

        // add the new layer
        this.olLayer = new HtmlTileLayer(
            'Client Rendered Carousel Tile Layer',
            null,
            {
                layername: null,
                type: 'json',
                maxExtent: new OpenLayers.Bounds(-20037500, -20037500,
                    20037500,  20037500),
                isBaseLayer: false,
                getURL: getURLFunction( this ),
                renderer: getRendererFunction( this )
            });

        this.map.olMap.addLayer( this.olLayer );

        this.setZIndex( this.zIndex );
        this.setOpacity( this.opacity );
        this.setEnabled( this.enabled );
        this.setTheme( this.map.getTheme() );

        // if the layers are already attached to the map, remove them first.
        var i;
        for ( i=0; i<this.layers.length; i++ ) {
            this.map.remove( this.layers[i] );
        }

        // add all deferred layers, if they exist
        if ( this.deferreds ) {
            for ( i=0; i<this.deferreds.length; i++ ) {
                this.addLayer( this.deferreds[i] );
            }
            delete this.deferreds;
        }
    };

    /**
     * Increment which layer index the current tile points to. This will
     * redraw the modified tile.
     * @memberof Carousel
         *
     * @param {String} tilekey - The tile key string.
     */
    Carousel.prototype.incrementTileLayerIndex = function( tilekey ) {
        if ( this.indicesByTile[ tilekey ] === undefined ) {
            this.indicesByTile[ tilekey ] = ( this.defaultIndex + 1 ) % this.layers.length;
        } else {
            this.indicesByTile[ tilekey ] = ( this.indicesByTile[ tilekey ] + 1 ) % this.layers.length;
            if ( this.indicesByTile[ tilekey ] === this.defaultIndex ) {
                delete this.indicesByTile[ tilekey ];
            }
        }
        redrawTile( this.olLayer, tilekey );
    };

    /**
     * Decrement which layer index the current tile points to. This will
     * redraw the modified tile.
     * @memberof Carousel
         *
     * @param {String} tilekey - The tile key string.
     */
    Carousel.prototype.decrementTileLayerIndex = function( tilekey ) {
        if ( this.indicesByTile[ tilekey ] === undefined ) {
            this.indicesByTile[ tilekey ] = Util.mod( this.defaultIndex -1, this.layers.length );
        } else {
            this.indicesByTile[ tilekey ] = Util.mod( this.indicesByTile[ tilekey ] - 1,  this.layers.length );
            if ( this.indicesByTile[ tilekey ] === this.defaultIndex ) {
                delete this.indicesByTile[ tilekey ];
            }
        }
        redrawTile( this.olLayer, tilekey );
    };

    /**
     * Set which layer index the current tile points to. This will
     * redraw the modified tile.
     * @memberof Carousel
         *
     * @param {String} tilekey - The tile key string.
     * @param {number} index - The new layer index for the tile.
     */
    Carousel.prototype.setTileLayerIndex = function( tilekey, index ) {
        if ( index === this.defaultIndex ) {
            delete this.indicesByTile[ tilekey ];
        } else {
            this.indicesByTile[ tilekey ] = index;
        }
        redrawTile( this.olLayer, tilekey );
    };

    /**
     * Set the layer index for all tiles. This will redraw the entire
     * layer.
     * @memberof Carousel
         *
     * @param {String} index - The layer index for all tiles.
     */
    Carousel.prototype.setTileLayerIndices = function( index ) {
        this.defaultIndex = Util.mod( index, this.layers.length );
        this.indicesByTile = {};
        this.olLayer.redraw();
    };

    /**
     * Returns the layer index for a particular tile.
     * @memberof Carousel
         *
     * @param {String} tilekey - The tile key string.
     *
     * @returns {number} The layer index for the tile.
     */
    Carousel.prototype.getLayerIndexForTile = function( tilekey ) {
        var layerIndex = this.indicesByTile[ tilekey ];
        return layerIndex !== undefined ? layerIndex : this.defaultIndex;
    };

    /**
     * Returns the renderer for a particular tile.
     * @memberof Carousel
         *
     * @param {String} tilekey - The tile key string.
     *
     * @returns {number} The renderer for the tile.
     */
    Carousel.prototype.getRendererForTile = function( tilekey ) {
        var layerIndex = this.getLayerIndexForTile( tilekey );
        return this.layers[ layerIndex ].renderer;
    };

    module.exports = Carousel;
}());

},{"../util/PubSub":59,"../util/Util":60,"./ClientLayer":9,"./HtmlTileLayer":13,"./Layer":15,"./LayerUtil":16}],9:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Layer = require('./Layer'),
        LayerUtil = require('./LayerUtil'),
        Util = require('../util/Util'),
        HtmlTileLayer = require('./HtmlTileLayer'),
        PubSub = require('../util/PubSub');

    /**
     * Private: Returns the zoom callback function to update level min and maxes.
     *
     * @param layer {ServerLayer} The layer object.
     */
    function zoomCallback( layer ) {
        return function() {
            if ( layer.olLayer ) {
                layer.setLevelMinMax();
            }
        };
    }

    /**
     * Instantiate a ClientLayer object.
     * @class ClientLayer
     * @augments Layer
     * @classdesc A client rendered layer object. Uses JSON data retrieved from the
     *            server in conjunction with a Renderer object or html function to
     *            create interactable DOM elements.
     *
     * @param {Object} spec - The specification object.
     * <pre>
     * {
     *     opacity  {float}    - The opacity of the layer. Default = 1.0
     *     enabled  {boolean}  - Whether the layer is visible or not. Default = true
     *     zIndex   {integer}  - The z index of the layer. Default = 1000
     *     renderer {Renderer} - The tile renderer object.
     * }
     * </pre>
     */
    function ClientLayer( spec ) {
        var that = this,
            getURL = spec.getURL || LayerUtil.getURL;
        // call base constructor
        Layer.call( this, spec );
        // set reasonable defaults
        this.zIndex = ( spec.zIndex !== undefined ) ? parseInt( spec.zIndex, 10 ) : 1000;
        this.tileTransform = spec.tileTransform || {};
        this.domain = "client";
        this.source = spec.source;
        this.getURL = function( bounds ) {
            return getURL.call( this, bounds ) + that.getQueryParamString();
        };
        if ( spec.tileClass ) {
            this.tileClass = spec.tileClass;
        }
        if ( spec.renderer ) {
            this.setRenderer( spec.renderer );
        }
        if ( spec.aggregators ) {
            _.forIn( spec.aggregators, function( agg, key ) {
                this.addAggregator( key, agg );
            });
        }
    }

    ClientLayer.prototype = Object.create( Layer.prototype );

    /**
     * Activates the layer object. This should never be called manually.
     * @memberof ClientLayer
     * @private
     */
    ClientLayer.prototype.activate = function() {
        // set callback here so it can be removed later
        this.zoomCallback = zoomCallback( this );
        // set callback to update ramp min/max on zoom
        this.map.on( "zoomend", this.zoomCallback );
        // add the new layer
        this.olLayer = new HtmlTileLayer(
            'Client Rendered Tile Layer',
            this.source.tms,
            {
                layername: this.source.id,
                type: 'json',
                maxExtent: new OpenLayers.Bounds(-20037500, -20037500,
                    20037500,  20037500),
                isBaseLayer: false,
                getURL: this.getURL,
                tileClass: this.tileClass,
                renderer: this.renderer
            });
        // set whether it is enabled or not before attaching, to prevent
        // needless tile reqeests
        this.setEnabled( this.isEnabled() );
        this.setTheme( this.map.getTheme() );
        this.setOpacity( this.getOpacity() );
        this.setBrightness( this.getBrightness() );
        this.setContrast( this.getContrast() );
        // publish activate event before appending to map
        PubSub.publish( this.getChannel(), { field: 'activate', value: true } );
        // attach to map
        this.map.olMap.addLayer( this.olLayer );
        // set z-index after
        this.setZIndex( this.zIndex );
        this.setLevelMinMax(); // set level min / max
        // publish add event
        PubSub.publish( this.getChannel(), { field: 'add', value: true } );
    };

    /**
     * Dectivates the layer object. This should never be called manually.
     * @memberof ClientLayer
     * @private
     */
    ClientLayer.prototype.deactivate = function() {
        if ( this.olLayer ) {
            this.map.olMap.removeLayer( this.olLayer );
            PubSub.publish( this.getChannel(), { field: 'remove', value: true } );
            this.olLayer.destroy();
            this.olLayer = null;
        }
        this.map.off( "zoomend", this.zoomCallback );
        this.zoomCallback = null;
        PubSub.publish( this.getChannel(), { field: 'deactivate', value: true } );
    };

    /**
     * Sets the current renderer of the layer.
     * @memberof ClientLayer
     *
     * @param {Renderer} renderer - The renderer to attach to the layer.
     */
    ClientLayer.prototype.setRenderer = function( renderer ) {
        this.renderer = renderer;
        this.renderer.attach( this );
    };

    /**
     * Adds an aggregator to the layer.
     * @memberof ClientLayer
     *
     * @param {String} id - The aggregator id.
     * @param {Renderer} renderer - The renderer to attach to the layer.
     */
    ClientLayer.prototype.addAggregator = function( id, aggregator ) {
        this.aggregators = this.aggregators || {};
        this.aggregators[ id ] = aggregator;
        this.aggregators[ id ].attach( this );
    };

    /**
     * Gets an aggregator by id.
     * @memberof ClientLayer
     *
     * @param {String} id - The aggregator id.
     */
    ClientLayer.prototype.getAggregator = function( id ) {
        return this.aggregators[ id ];
    };

    /**
     * Updates the theme associated with the layer.
     * @memberof ClientLayer
     *
     * @param {String} theme - The theme identifier string.
     */
    ClientLayer.prototype.setTheme = function( theme ) {
        this.theme = theme;
    };

    /**
     * Get the current theme for the layer.
     * @memberof ClientLayer
     *
     * @returns {String} The theme identifier string.
     */
    ClientLayer.prototype.getTheme = function() {
        return this.theme;
    };

    /**
     * Set the z index of the layer.
     * @memberof ClientLayer
     *
     * @param {integer} zIndex - The new z-order value of the layer, where 0 is front.
     */
    ClientLayer.prototype.setZIndex = function ( zIndex ) {
        // we by-pass the OpenLayers.Map.setLayerIndex() method and manually
        // set the z-index of the layer dev. setLayerIndex sets a relative
        // index based on current map layers, which then sets a z-index. This
        // caused issues with async layer loading.
        this.zIndex = zIndex;
        if ( this.olLayer ) {
            $( this.olLayer.div ).css( 'z-index', zIndex );
        }
        PubSub.publish( this.getChannel(), { field: 'zIndex', value: zIndex });
    };

    /**
     * Get the layers zIndex.
     * @memberof ClientLayer
     *
     * @returns {integer} The zIndex for the layer.
     */
    ClientLayer.prototype.getZIndex = function () {
        return this.zIndex;
    };

    /**
     * Set the layers tile transform function type.
     * @memberof ClientLayer
     *
     * @param {String} transformType - The tile transformer type.
     */
    ClientLayer.prototype.setTileTransformType = function ( transformType ) {
        if ( this.tileTransform.type !== transformType ) {
            this.tileTransform.type = transformType;
            this.redraw();
            PubSub.publish( this.getChannel(), {field: 'tileTransformType', value: transformType} );
        }
    };

    /**
     * Get the layers transformer type.
     * @memberof ClientLayer
     *
     * @return {String} The tile transform type.
     */
    ClientLayer.prototype.getTileTransformType = function () {
        return this.tileTransform.type;
    };

    /**
     * Set the tile transform data based on the time range passed in
     * @memberof ClientLayer
     *
     * @param {number} start - A unix timestamp representing the start of the time range
     * @param {number} end - A unix timestamp representing the end of the time range
     */
    ClientLayer.prototype.setTileTransformRange = function ( start, end ) {
		var meta = this.source.meta.meta,
			rangeMin = meta.rangeMin,
			rangeMax = meta.rangeMax,
			numBuckets = meta.bucketCount,
            bucketSize = ( rangeMax - rangeMin ) / numBuckets;
        if ( start > rangeMax && end < rangeMin ) {
            // outside range completely, send empty request
			this.setTileTransformData({
    			startBucket: -1,
    			endBucket: -1
            });
		}
		this.setTileTransformData({
			startBucket: Math.max( 0, Math.floor( ( start - rangeMin ) / bucketSize ) ),
			endBucket: Math.min( numBuckets - 1, Math.floor( ( end - rangeMin ) / bucketSize ) )
        });
	};

    /**
     * Set the tile transform data attribute internally
     * @memberof ClientLayer
     *
     * @param {Object} transformData - The tile transform data attribute.
     */
	ClientLayer.prototype.setTileTransformData = function( transformData ) {
        if ( !_.isEqual( this.tileTransform.data, transformData ) ) {
            this.tileTransform.data = transformData;
            this.redraw();
            PubSub.publish( this.getChannel(), {field: 'tileTransformData', value: transformData} );
        }
    };

    /**
     * Get the transformer data attribute.
     * @memberof ClientLayer
     *
     * @returns {Object} The tile transform data attribute.
     */
    ClientLayer.prototype.getTileTransformData = function () {
        return this.tileTransform.data || {};
    };

    /**
     * Get the current minimum and maximum values for the current zoom level.
     * @memberof ClientLayer
     *
     * @param {Object} The min and max of the level.
     */
    ClientLayer.prototype.getLevelMinMax = function() {
        return this.levelMinMax;
    };

    /**
     * Generate query parameters based on state of layer
     * @memberof ClientLayer
     *
     * @returns {String} The query parameter string based on the attributes of this layer.
     */
     ClientLayer.prototype.getQueryParamString = function() {
        var query = {
            tileTransform: this.tileTransform
        };
        return Util.encodeQueryParams( query );
    };

    /**
     * Redraws the entire layer.
     * @memberof ClientLayer
     */
    ClientLayer.prototype.redraw = function () {
        if ( this.olLayer ) {
            this.setLevelMinMax();
            this.olLayer.redraw();
            this.setZIndex(this.zIndex);
            // If we're using the TileManager we need to force it into a refresh. There is no nice way to
            // do this as of 2.13.1, so we fake the expiry of the move/zoom timeout.
            if ( this.olLayer.map && this.olLayer.map.tileManager ) {
                this.olLayer.map.tileManager.updateTimeout(
                    this.olLayer.map,
                    this.olLayer.map.tileManager.zoomDelay,
                    true );
            }
        }
    };

    /**
     * Sets the layers min and max values for the given zoom level.
     * @memberof ClientLayer
     * @private
     * @param layer {Object} the layer object.
     */
    ClientLayer.prototype.setLevelMinMax = function() {
        var zoomLevel = this.map.getZoom(),
            source = this.source,
            meta = source.meta && source.meta.meta ? source.meta.meta[ zoomLevel ] : null,
            transformData = this.tileTransform.data || {},
            levelMinMax = meta,
            renderer = this.renderer,
            aggregated;
        if ( meta ) {
            // aggregate the data if there is an aggregator attached
            if ( renderer && renderer.aggregator ) {
                // aggregate the meta data buckets
                aggregated = renderer.aggregator.aggregate(
                    meta.bins || [],
                    transformData.startBucket,
                    transformData.endBucket );
                if ( aggregated instanceof Array ) {
                    // take the first and last index, which correspond to max / min
                    levelMinMax = {
                        minimum: aggregated[aggregated.length - 1] || null,
                        maximum: aggregated[0] || null
                    };
                } else {
                    //
                    levelMinMax = {
                        minimum: aggregated,
                        maximum: aggregated
                    };
                }
            }
        } else {
            levelMinMax = {
                minimum: null,
                maximum: null
            };
        }
        this.levelMinMax = levelMinMax;
        PubSub.publish( this.getChannel(), { field: 'levelMinMax', value: levelMinMax });
    };

    module.exports = ClientLayer;
}());

},{"../util/PubSub":59,"../util/Util":60,"./HtmlTileLayer":13,"./Layer":15,"./LayerUtil":16}],10:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var MapUtil = require('../map/MapUtil');

    /**
     * Instantiate a HtmlMarker object.
     * @class HtmlMarker
     * @classdesc A HtmlMarker object that is pinned to an HtmlMarkerLayer.
     */
    function HtmlMarker( x, y, html, dimension ) {
        this.x = x;
        this.y = y;
        this.html = html;
        this.dimension = dimension;
        this.icon = new OpenLayers.Icon(
            null,
            new OpenLayers.Size( 2, 2 ),
            new OpenLayers.Pixel( -1, -2 ) );
    }

    HtmlMarker.prototype = {

        /**
         * Activates the HtmlMarker object. This should never be called manually.
         * @memberof HtmlMarker
         * @private
         */
        activate: function() {
            var viewportPx = MapUtil.getViewportPixelFromCoord( this.map, this.x, this.y ),
                lonlat = this.map.olMap.getLonLatFromViewPortPx( viewportPx );
            this.olMarker = new OpenLayers.Marker( lonlat, this.icon.clone() );
            this.layer.olLayer.addMarker( this.olMarker );
            // get marker elem
            var $parent = $( this.olMarker.icon.imageDiv );
            // hide icon element
            $parent.children().css( 'display', 'none' );
            this.$elem = $( this.html );
            this.$container = $parent.parent();
            this.$olContainer = this.$container.parent();
            if (this.dimension) {
                // If the marker is restricted to move in one direction register move handlers
                this.updatePosition = this.updatePosition.bind(this);
                this.map.olMap.events.register( 'move', this.map.olMap, this.updatePosition );
            }
            // add marker
            $parent.append( this.html );
        },

        /**
         * De-activates the HtmlMarker object. This should never be called manually.
         * @memberof HtmlMarker
         * @private
         */
        deactivate: function() {
            if ( this.olMarker && this.layer.olLayer ) {
                this.layer.olLayer.removeMarker( this.olMarker );
                this.map.olMap.events.unregister( 'move', this.map.olMap, this.updatePosition );
                this.olMarker.destroy();
                this.olMarker = null;
                this.$elem = null;
            }
        },

        /**
         * Removes event listeners on marker when i
         * @memberof HtmlMarker
         * @publice
         */
        disable: function () {
            this.map.olMap.events.unregister( 'move', this.map.olMap, this.updatePosition );
        },

        /**
         * Moves the marker to a new x and y coordinate.
         * @memberof HtmlMarker
         *
         * @param {number} x - The x coordinate.
         * @param {number} y - The y coordinate.
         */
        moveTo: function( x, y ) {
            this.x = x;
            this.y = y;
            var viewportPx = MapUtil.getViewportPixelFromCoord( this.map, this.x, this.y ),
                lonlat = this.map.olMap.getLonLatFromViewPortPx( viewportPx ),
                px = this.map.olMap.getLayerPxFromLonLat( lonlat );
            this.olMarker.moveTo( px );
        },

        /**
         * Called on map move to fix marker along a configured axis
         * @memberof HtmlMarker
         */
        updatePosition: function () {
            var $container = this.$olContainer,
                offset = $container.position();
            if ( this.dimension === "x" ) {
                // Set the marker y position
                this.$elem.parent().css( 'top', -offset.top + "px" );
            }
        }
    };

    module.exports = HtmlMarker;
}());

},{"../map/MapUtil":45}],11:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

(function() {

	"use strict";

	var Layer = require('./Layer'),
		PubSub = require('../util/PubSub');

	function addMarkerToLayer( layer, marker ) {
		marker.layer = layer;
		marker.map = layer.map;
		marker.activate();
	}

	function removeMarkerFromLayer( marker ) {
		marker.deactivate();
		marker.map = null;
		marker.layer = null;
	}

	/**
	 * Instantiate a HtmlMarkerLayer object.
	 * @class HtmlMarkerLayer
	 * @augments Layer
	 * @classdesc A client rendered marker layer object.
	 *
	 * @param {Object} spec - The specification object.
	 */
	function HtmlMarkerLayer( spec ) {
		spec = spec || {};
		// call base constructor
		Layer.call( this, spec );
		// set reasonable defaults
		this.zIndex = ( spec.zIndex !== undefined ) ? spec.zIndex : 749;
		this.domain = "marker";
		this.source = spec.source;
		this.markers = spec.markers || [];
	}

	HtmlMarkerLayer.prototype = Object.create( Layer.prototype );

	/**
	 * Activates the layer object. This should never be called manually.
	 * @memberof HtmlMarkerLayer
	 * @private
	 */
	HtmlMarkerLayer.prototype.activate = function() {
		this.olLayer = new OpenLayers.Layer.Markers( "Markers" );
		this.setOpacity( this.opacity );
		this.setEnabled( this.enabled );
		this.setTheme( this.map.getTheme() );
		this.map.olMap.addLayer( this.olLayer );
		this.markers.forEach( function( marker ) {
			addMarkerToLayer( this, marker );
		}, this );
		this.setZIndex( this.zIndex );
		PubSub.publish( this.getChannel(), { field: 'activate', value: true } );
	};

	/**
	 * Dectivates the layer object. This should never be called manually.
	 * @memberof HtmlMarkerLayer
	 * @private
	 */
	HtmlMarkerLayer.prototype.deactivate = function() {
		if ( this.olLayer ) {
			this.olLayer.clearMarkers();
			this.map.olMap.removeLayer( this.olLayer );
			this.olLayer.destroy();
			this.olLayer = null;
			PubSub.publish( this.getChannel(), { field: 'deactivate', value: true } );
		}
	};

	HtmlMarkerLayer.prototype.addMarker = function( marker ) {
		if ( this.olLayer ) {
			// add marker
			addMarkerToLayer( this, marker );
		}
		this.markers.push( marker );
	};

	HtmlMarkerLayer.prototype.addMarkers = function( markers, chunkSize, pause ) {
		var that = this;
		if ( chunkSize ) {
			// adding large quantities of markers to the map is slow, so
			// break it into async chunks to let the app breath in between
			_.chunk( markers, chunkSize ).forEach( function( chunk, index ) {
				setTimeout( function() {
					chunk.forEach( function( marker ) {
						that.addMarker( marker );
					});
				}, pause * index || 0 );
			});
		} else {
			markers.forEach( function( marker ) {
				that.addMarker( marker );
			});
		}
	};

	HtmlMarkerLayer.prototype.disableMarkers = function() {
		this.markers.forEach( function( marker ) {
			marker.disable();
		});
	};

	HtmlMarkerLayer.prototype.removeMarker = function( marker ) {
		if ( this.olLayer ) {
			removeMarkerFromLayer( marker );
		}
	};

	HtmlMarkerLayer.prototype.clearMarkers = function() {
		if ( this.olLayer ) {
			this.disableMarkers();
			this.olLayer.clearMarkers();
		}
		this.markers = [];
	};

	/**
	 * Updates the theme associated with the layer.
	 * @memberof HtmlMarkerLayer
	 *
	 * @param {String} theme - The theme identifier string.
	 */
	HtmlMarkerLayer.prototype.setTheme = function( theme ) {
		this.theme = theme;
	};

	/**
	 * Set the z index of the layer.
	 * @memberof HtmlMarkerLayer
	 *
	 * @param {integer} zIndex - The new z-order value of the layer, where 0 is front.
	 */
	HtmlMarkerLayer.prototype.setZIndex = function( zIndex ) {
		// we by-pass the OpenLayers.Map.setLayerIndex() method and manually
		// set the z-index of the layer dev. setLayerIndex sets a relative
		// index based on current map layers, which then sets a z-index. This
		// caused issues with async layer loading.
		this.zIndex = zIndex;
		if ( this.olLayer ) {
			$( this.olLayer.div ).css( 'z-index', zIndex );
			PubSub.publish( this.getChannel(), {
				field: 'zIndex',
				value: zIndex
			});
		}
	};

	/**
	 * Get the layers zIndex.
	 * @memberof HtmlMarkerLayer
	 *
	 * @returns {integer} The zIndex for the layer.
	 */
	HtmlMarkerLayer.prototype.getZIndex = function() {
		return this.zIndex;
	};

	module.exports = HtmlMarkerLayer;
}());

},{"../util/PubSub":59,"./Layer":15}],12:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * An overridden OpenLayers.Tile object to create DOM elements based on
 * tile data. Used by HtmlTileLayers for client rendered layers. Uses
 * either Renderer objects or html functions to generate the DOM elements
 * or html strings.
 */
( function() {

    "use strict";

    OpenLayers.Tile.HTML = function() {
        this.url = null;
        this.imgDiv = null;
        this.imageReloadAttempts = null;
        OpenLayers.Tile.apply( this, arguments );
    };

    OpenLayers.Tile.HTML.prototype = Object.create( OpenLayers.Tile.prototype );

    OpenLayers.Tile.HTML.prototype.destroy = function() {
        if ( this.imgDiv )  {
            this.clear();
            this.imgDiv = null;
        }
        OpenLayers.Tile.prototype.destroy.apply( this, arguments );
    };

    OpenLayers.Tile.HTML.prototype.draw = function() {
        var shouldDraw = OpenLayers.Tile.prototype.draw.apply( this, arguments );
        if ( shouldDraw ) {
            if ( this.isLoading ) {
                //if we're already loading, send 'reload' instead of 'loadstart'.
                this._loadEvent = "reload";
            } else {
                this.isLoading = true;
                this._loadEvent = "loadstart";
            }
            this.renderTile();
            this.positionTile();
        } else if ( shouldDraw === false ) {
            this.unload();
        }
        return shouldDraw;
    };

    OpenLayers.Tile.HTML.prototype.getURL = function() {
        var url = this.layer.getURL( this.bounds );
        if ( url instanceof Array ) {
            url = url.join('|');
        }
        return url;
    };

    OpenLayers.Tile.HTML.prototype.renderTile = function() {
        this.url = this.getURL();
        this.initImage();
    };

    OpenLayers.Tile.HTML.prototype.positionTile = function() {
        var style = this.getTile().style,
            size = this.layer.getImageSize( this.bounds ),
            ratio = 1;
        if ( this.layer instanceof OpenLayers.Layer.Grid ) {
            ratio = this.layer.getServerResolution() / this.layer.map.getResolution();
        }
        style.left = this.position.x + "px";
        style.top = this.position.y + "px";
        style.width = Math.round( ratio * size.w ) + "px";
        style.height = Math.round( ratio * size.h ) + "px";
    };

    OpenLayers.Tile.HTML.prototype.clear = function() {
        OpenLayers.Tile.prototype.clear.apply( this, arguments );
        var img = this.imgDiv;
        if ( img ) {
            var tile = this.getTile();
            if ( tile.parentNode === this.layer.div ) {
                this.layer.div.removeChild( tile );
            }
            this.setImgSrc();
            OpenLayers.Element.removeClass(img, "olImageLoadError");
        }
    };

    OpenLayers.Tile.HTML.prototype.getImage = function() {
        if ( !this.imgDiv ) {
            this.imgDiv = document.createElement( 'div' );
            this.imgDiv.className = 'olTileHtml';
            var style = this.imgDiv.style;
            style.visibility = "hidden";
            style.opacity = 0;
            if ( this.layer.opacity < 1 ) {
                style.filter = 'alpha(opacity=' + (this.layer.opacity * 100) + ')';
            }
            style.position = "absolute";
        }
        return this.imgDiv;
    };

    OpenLayers.Tile.HTML.prototype.setImage = function( img ) {
        this.imgDiv = img;
    };

    OpenLayers.Tile.HTML.prototype.initImage = function() {
        if ( !this.url && !this.imgDiv ) {
            // fast path out - if there is no tile url and no previous image
            this.isLoading = false;
            return;
        }
        this.events.triggerEvent('beforeload');
        this.layer.div.appendChild( this.getTile() );
        this.events.triggerEvent( this._loadEvent );
        var img = this.getImage();
        var dataUrl = img.getAttribute('data-url') || '';
        if ( dataUrl === this.url ) {
            this._loadTimeout = window.setTimeout(
                OpenLayers.Function.bind( this.onImageLoad, this ),
                0 );
        } else {
            this.stopLoading();
            this.imageReloadAttempts = 0;
            this.setImgSrc( this.url );
        }
    };

    OpenLayers.Tile.HTML.prototype.setImgSrc = function( url ) {
        var that  = this,
            img = this.imgDiv;
        if ( url ) {
            var urls = url.split('|');
            img.style.visibility = 'hidden';
            img.style.opacity = 0;
            img.setAttribute( "data-url", url );
            var pendingRequests = urls.map( function( url ) {
                var deferred = $.Deferred();
                $.ajax({
                    url: url
                }).then(
                    function( results ) {
                        deferred.resolve( results );
                    },
                    function( xhr ) {
                        deferred.reject();
                        console.error( xhr.responseText );
                        console.error( xhr );
                    }
                );
                return deferred;
            });
            $.when.apply( $, pendingRequests ).then(
                function() {
                    if ( url === that.url ) {
                        that.onImageLoad.apply( that, arguments );
                    }
                },
                function() {
                    if ( url === that.url ) {
                        that.onImageError();
                    }
                }
            );
        } else {
            // Remove reference to the image, and leave it to the browser's
            // caching and garbage collection.
            this.stopLoading();
            this.imgDiv = null;
            if ( img.parentNode ) {
                img.parentNode.removeChild( img );
            }
        }
    };

    OpenLayers.Tile.HTML.prototype.getTile = function() {
        return this.getImage();
    };

    OpenLayers.Tile.HTML.prototype.createBackBuffer = function() {
        return;
    };

    OpenLayers.Tile.HTML.prototype.renderHtml = function() {
        var imgDiv = this.imgDiv,
            tileData = imgDiv._tileData,
            renderer = this.getRenderer(),
            aggregator,
            html,
            render;
        // clear tile contents
        imgDiv.innerHTML = "";
        // hide standard tile hover interaction
        if ( renderer.spec.hideTile ) {
            imgDiv.className = imgDiv.className + " hideTile";
        }
        if ( !tileData || tileData.length === 0 ) {
            // no data, exit
            return;
        }
        // ensure there is at least one set of data
        // tile data is under 'tile', elasticsearch is under 'hits'
        var hasTileOrHits = false;
        tileData.forEach( function( datum ) {
            if ( datum.tile || datum.hits ) {
                hasTileOrHits = true;
            }
        });
        // no content in data, exit
        if ( !hasTileOrHits ) {
            return;
        }
        // if aggregator, aggregate the data
        aggregator = renderer.aggregator;
        if ( aggregator ) {
            var outOfRangeCount = 0;
            tileData.forEach( function( datum ) {
                if ( datum.tile ) {
                    // only aggregate the data if it hasn't already been aggregated
                    if ( !datum.tile.meta.aggregated || datum.tile.meta.aggregationType !== aggregator ) {
                        var rawData = datum.tile.meta.map ? datum.tile.meta.map.bins : datum.tile.meta.raw;
                        datum.tile.meta = {
                            raw: rawData,
                            aggregated: aggregator.aggregate( rawData )
                        };
                        datum.tile.meta.aggregationType = aggregator;
                    }
                    // check if requested range is outside of available range
                    if ( datum.tile.meta.aggregated.length === 0 ) {
                        // no data, flag as out of range
                        outOfRangeCount++;
                    }
                }
            });
            // if all data is outside the range, exit early
            if ( outOfRangeCount === tileData.length ) {
                // data outside of range, exit
                return;
            }
        }
        var data = tileData.length === 1 ? tileData[0] : tileData;
        // render data
        render = renderer.render( data );
        html = render.html;
        this.entries = render.entries;
        // add html to the tile div
        if ( html instanceof $ ) {
            // if generated a jquery object, append it
            $( imgDiv ).append( html );
        } else if ( html instanceof HTMLElement ) {
            // if generated an HTMLElement, get html text
            imgDiv.appendChild( html );
        } else {
            // if generated string, set inner html
            imgDiv.innerHTML = html;
        }
        // inject selected entry classes
        renderer.injectEntries( imgDiv.children, this.entries );
        // call renderer hook function
        renderer.executeHooks( imgDiv.children, this.entries, data );
    };

    OpenLayers.Tile.HTML.prototype.getRenderer = function() {
        var renderer = this.layer.renderer;
        if ( typeof renderer === "function" ) {
            renderer = renderer.call( this.layer, this.bounds );
        }
        return renderer;
    };

    OpenLayers.Tile.HTML.prototype.onImageLoad = function() {
        var img = this.imgDiv;
        this.stopLoading();
        if ( img ) {
            img.style.visibility = 'inherit';
            img.style.opacity = this.layer.opacity;
            if ( arguments.length > 0 ) {
                // only set the data if there is new data to set
                var data = [],
                    i;
                for ( i=0; i<arguments.length; i++ ) {
                    data.push( arguments[i] );
                }
                img._tileData = data;
            }
            // render the data
            this.renderHtml();
            // trigger load end
            this.isLoading = false;
            this.events.triggerEvent("loadend");
        }
    };

    OpenLayers.Tile.HTML.prototype.onImageError = function() {
        var img = this.imgDiv;
        if ( img && img.getAttribute('data-url') ) {
            this.imageReloadAttempts++;
            if ( this.imageReloadAttempts <= OpenLayers.IMAGE_RELOAD_ATTEMPTS ) {
                this.setImgSrc( this.getURL() );
            } else {
                OpenLayers.Element.addClass( img, "olImageLoadError" );
                this.events.triggerEvent("loaderror");
                this.onImageLoad();
            }
        }
    };

    OpenLayers.Tile.HTML.prototype.stopLoading = function() {
        window.clearTimeout( this._loadTimeout );
        delete this._loadTimeout;
    };

    OpenLayers.Tile.HTML.prototype.getCanvasContext = function() {
        return undefined;
    };

    /**
     * OpenLayers overrides
     */

    if ( OpenLayers.TileManager ) {

        OpenLayers.TileManager.prototype.addTile = function(evt) {
            if ( evt.tile instanceof OpenLayers.Tile.Image ||
                evt.tile instanceof OpenLayers.Tile.HTML ||
                evt.tile instanceof OpenLayers.Tile.Univariate ) {
                if ( !evt.tile.layer.singleTile ) {
                    evt.tile.events.on({
                        beforedraw: this.queueTileDraw,
                        beforeload: this.manageTileCache,
                        loadend: this.addToCache,
                        unload: this.unloadTile,
                        scope: this
                    });
                }
            } else {
                // Layer has the wrong tile type, so don't handle it any longer
                this.removeLayer({layer: evt.tile.layer});
            }
        };

        OpenLayers.TileManager.prototype.queueTileDraw = function( evt ) {
            var tile = evt.object;
            var queued = false;
            var layer = tile.layer;
            var url = tile.getURL ? tile.getURL() : layer.getURL( tile.bounds );
            var img = this.tileCache[url];
            if ( img &&
                !OpenLayers.Element.hasClass( img, 'olTileImage' ) &&
                !OpenLayers.Element.hasClass( img, 'olTileHtml' ) &&
                !OpenLayers.Element.hasClass( img, 'olTileUnivariate' ) ) {
                // cached image no longer valid, e.g. because we're olTileReplacing
                delete this.tileCache[ url ];
                OpenLayers.Util.removeItem( this.tileCacheIndex, url );
                img = null;
            }
            // queue only if image with same url not cached already
            if ( layer.url && ( layer.async || !img ) ) {
                // add to queue only if not in queue already
                var tileQueue = this.tileQueue[ layer.map.id ];
                if ( !~OpenLayers.Util.indexOf( tileQueue, tile ) ) {
                    tileQueue.push(tile);
                }
                queued = true;
            }
            return !queued;
        };

    }

    OpenLayers.Tile.Image.prototype.createBackBuffer = function() {
        return;
    };

    module.exports = OpenLayers.Tile.HTML;
}());

},{}],13:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * An overridden OpenLayers.Layer object to use the HtmlTile object to
 * create client rendered elements. Uses either a Renderer or html function
 * to generate the html.
 */
( function() {

    "use strict";

    var HtmlTile = require('./HtmlTile');

    OpenLayers.Layer.HTML = function( name, url, options ) {
        OpenLayers.Layer.Grid.call( this, name, url, options );
        this.getURL = options.getURL;
        this.layername = options.layername;
        this.type = options.type;
        this.tileClass = options.tileClass || HtmlTile;
        this.html = options.html;
        this.renderer = options.renderer;
        this.CLASS_NAME = 'OpenLayers.Layer.HTML';
    };

    OpenLayers.Layer.HTML.prototype = Object.create( OpenLayers.Layer.Grid.prototype );

    OpenLayers.Layer.HTML.prototype.setOpacity = function( opacity ) {
        if ( opacity !== this.opacity ) {
            this.opacity = Math.max( Math.min( opacity, 1 ), 0 );
            var childNodes = this.div.childNodes;
            for( var i = 0, len = childNodes.length; i < len; ++i ) {
                childNodes[i].style.opacity = this.opacity;
            }
            if ( this.map !== null ) {
                this.map.events.triggerEvent( "changelayer", {
                    layer: this,
                    property: "opacity"
                });
            }
        }
    };

    module.exports = OpenLayers.Layer.HTML;
}());

},{"./HtmlTile":12}],14:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

(function() {

	"use strict";

	var Layer = require('./Layer'),
		PubSub = require('../util/PubSub');

	/**
	 * Instantiate a KMLLayer object.
	 * @class KMLLayer
	 * @augments Layer
	 * @classdesc A client rendered layer object.
	 *
	 * @param {Object} spec - The specification object.
	 */
	function KMLLayer( spec ) {
		// call base constructor
		Layer.call(this, spec);
		// set reasonable defaults
		this.zIndex = ( spec.zIndex !== undefined ) ? spec.zIndex : 749;
		this.domain = "kml";
		this.source = spec.source;
		this.id = spec.id;
		this.kml = spec.kml || [];
	}

	KMLLayer.prototype = Object.create(Layer.prototype);

	/**
	 * Activates the layer object. This should never be called manually.
	 * @memberof KMLLayer
	 * @private
	 */
	KMLLayer.prototype.activate = function() {
		this.olLayers = [];

		this.kml.forEach( function( kml ) {
			var projection;
			var units = kml.units;

			if (typeof units === "object") {
				units = units[kml.url.split("/").pop()];
			}

			switch ( units ) {
				case "meter":
				case "meters":
				case "metres":
				case "metre":
				case "m":
					projection = new OpenLayers.Projection("EPSG:900913");
					break;
				case "degrees":
				case "degree":
					projection = new OpenLayers.Projection("EPSG:4326");
					break;
				default:
					projection = new OpenLayers.Projection("EPSG:4326");
					break;
			}
			kml.olLayer = new OpenLayers.Layer.Vector( "Vector Layer", {
				projection: projection,
				strategies: [
					new OpenLayers.Strategy.Fixed()
				],
                protocol: new OpenLayers.Protocol.HTTP({
                    url: kml.url,
                    format: new OpenLayers.Format.KML({
                        extractStyles: true,
                        extractAttributes: true
                    })
                })
			});
			this.olLayers.push( kml.olLayer );
		}, this );
        this.setEnabled( this.isEnabled() );
        this.setOpacity( this.getOpacity() );
        this.setBrightness( this.getBrightness() );
        this.setContrast( this.getContrast() );
    	// publish activate event before appending to map
        PubSub.publish( this.getChannel(), { field: 'activate', value: true } );
		this.olLayers.forEach( function( olLayer ) {
			this.map.olMap.addLayer( olLayer );
		}, this );
		this.setZIndex( this.zIndex );
        // publish add event
        PubSub.publish( this.getChannel(), { field: 'add', value: true } );
	};

	/**
	 * Dectivates the layer object. This should never be called manually.
	 * @memberof KMLLayer
	 * @private
	 */
	KMLLayer.prototype.deactivate = function() {
		if ( this.olLayers ) {
			this.olLayers.forEach( function( olLayer ) {
				this.map.olMap.removeLayer( olLayer );
				olLayer.destroy();
				olLayer = null;
			}, this );
            PubSub.publish( this.getChannel(), { field: 'remove', value: true } );
			this.kml.forEach( function( kml ) {
				kml.olLayer = null;
			});
			this.olLayers = [];
		}
        PubSub.publish( this.getChannel(), { field: 'deactivate', value: true } );
	};

	/**
	 * Set the z index of the layer.
	 * @memberof KMLLayer
	 *
	 * @param {integer} zIndex - The new z-order value of the layer, where 0 is front.
	 */
	KMLLayer.prototype.setZIndex = function( zIndex ) {
		// we by-pass the OpenLayers.Map.setLayerIndex() method and manually
		// set the z-index of the layer dev. setLayerIndex sets a relative
		// index based on current map layers, which then sets a z-index. This
		// caused issues with async layer loading.
		this.zIndex = zIndex;
		if ( this.olLayers ) {
			this.olLayers.forEach( function( olLayer, index ) {
				$( olLayer.div ).css( 'z-index', zIndex + ( this.olLayers.length - index ) );
			}, this );
		}
		PubSub.publish( this.getChannel(), {
			field: 'zIndex',
			value: zIndex
		});
	};

	/**
	 * Get the layers zIndex.
	 * @memberof KMLLayer
	 *
	 * @returns {integer} The zIndex for the layer.
	 */
	KMLLayer.prototype.getZIndex = function() {
		return this.zIndex;
	};

	/**
	* Set the opacity of the layer.
	* @memberof KMLLayer
	*
	* @param {float} opacity - opacity value from 0 to 1.
	*/
	KMLLayer.prototype.setOpacity = function( opacity ) {
		this.opacity = opacity;
		if ( this.olLayers ) {
			this.olLayers.forEach( function( olLayer ) {
				olLayer.setOpacity( opacity );
			}, this );
		}
		PubSub.publish( this.getChannel(), { field: 'opacity', value: opacity } );
	};

	/**
	* Set whether or not the layer is enabled.
	* @memberof KMLLayer
	*
	* @param enabled {boolean} whether the layer is visible or not
	*/
	KMLLayer.prototype.setEnabled = function( enabled ) {
		this.enabled = enabled;
		if ( this.olLayers ) {
			this.olLayers.forEach( function( olLayer ) {
				olLayer.setVisibility( enabled );
			}, this );
		}
		PubSub.publish( this.getChannel(), { field: 'enabled', value: enabled } );
	};

	KMLLayer.prototype.setTileTransformRange = function( start ) {
		var kmlDate = start;
		if (kmlDate >= this.source.meta.meta.rangeMax) {
			kmlDate = this.source.meta.meta.rangeMax;
		} else if (kmlDate <= this.source.meta.meta.rangeMin) {
			kmlDate = this.source.meta.meta.rangeMin;
		}
		if ( kmlDate !== this.kmlDate ) {
			this.kmlDate = kmlDate;
			this.updateKMLData( true );
		}
	};

	KMLLayer.prototype.setTileTransformData = function() {
		// Set kml data to the most recent
		if ( this.source.meta.meta.rangeMax !== this.kmlDate ) {
			this.kmlDate = this.source.meta.meta.rangeMax;
			this.updateKMLData(true);
		}
	};

    KMLLayer.prototype.updateKMLData = function (updateView) {
	    var self = this;
	    var date = this.kmlDate;
	    if (updateView) {
	        this.deactivate();
	    }
	    this.kml.forEach( function( kml, kmlIndex ) {
	        if (kml.files) {
		        // Find closest month before
		        var smallestFile = null;
		        var minDiff;

		        kml.files.forEach(function (file) {
		            if (!smallestFile || Math.abs(file.date - date) < minDiff) {
		                minDiff = Math.abs(file.date - date);
		                smallestFile = file;
		            }
		        });
		        self.name = self.source.name + " (" + moment(smallestFile.date).format("MMM YYYY") + ")";

		        if (smallestFile) {
		            kml.url = "rest/layers/" + self.id + "/kml/" + kmlIndex + "/" + smallestFile.fileName;
		        }
	        }
	    });
	    if (updateView) {
			this.activate();
		}
    };

	module.exports = KMLLayer;
}());

},{"../util/PubSub":59,"./Layer":15}],15:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Util = require('../util/Util'),
        PubSub = require('../util/PubSub');

    /**
     * Instantiate a Layer object.
     * @class Layer
     * @classdesc A Layer class, the base class for all layer implementations.
     *
     * @param {Object} spec - The specification object.
     */
    function Layer( spec ) {
        spec = spec || {};
        this.uuid = Util.generateUuid();
        this.name = spec.name || "Unnamed Layer";
        this.domain = spec.domain;
        this.map = spec.map;
        this.showPendingTiles = spec.showPendingTiles !== undefined ? spec.showPendingTiles : true;
        this.opacity = ( spec.opacity !== undefined ) ? spec.opacity : 1.0;
        this.brightness = ( spec.brightness !== undefined ) ? spec.brightness : 1.0;
        this.contrast = ( spec.brightness !== undefined ) ? spec.brightness : 1.0;
        this.enabled = ( spec.enabled !== undefined ) ? spec.enabled : true;
    }

    Layer.prototype = {

        /**
         * Set the opacity of the layer.
         * @memberof Layer.prototype
         *
         * @param {float} opacity - opacity value from 0 to 1.
         */
        setOpacity: function( opacity ) {
            this.opacity = opacity;
            if ( this.olLayer ) {
                this.olLayer.setOpacity( opacity );
            }
            PubSub.publish( this.getChannel(), { field: 'opacity', value: opacity } );
        },

        /**
         * Returns the opacity of the layer.
         * @memberof Layer.prototype
         *
         * @returns {float} The opacity of the layer.
         */
        getOpacity: function() {
            return this.opacity;
        },

        /**
         * Set the brightness of the layer.
         * @memberof Layer.prototype
         *
         * @param {float} brightness - normalized brightness value.
         */
        setBrightness: function( brightness ) {
            this.brightness = brightness;
            if ( this.olLayer ) {
                $( this.olLayer.div ).css( '-webkit-filter', "brightness("+ (this.brightness*100) +"%) contrast("+ (this.contrast*100) +"%)" );
            }
            PubSub.publish( this.getChannel(), { field: 'brightness', value: brightness } );
        },

        /**
         * Returns the brightness of the layer.
         * @memberof Layer.prototype
         *
         * @returns {float} The brightness of the layer.
         */
        getBrightness: function() {
            return this.brightness;
        },

        /**
         * Set the contrast of the layer.
         * @memberof Layer.prototype
         *
         * @param {float} contrast - normalized contrast value.
         */
        setContrast: function( contrast ) {
            this.contrast = contrast;
            if ( this.olLayer ) {
                $( this.olLayer.div ).css( '-webkit-filter', "brightness("+ (this.brightness*100) +"%) contrast("+ (this.contrast*100) +"%)" );
            }
            PubSub.publish( this.getChannel(), { field: 'contrast', value: contrast } );
        },

        /**
         * Returns the contrast of the layer.
         * @memberof Layer.prototype
         *
         * @returns {float} The contrast of the layer.
         */
        getContrast: function() {
            return this.contrast;
        },

        /**
         * Set whether or not the layer is enabled.
         * @memberof Layer.prototype
         *
         * @param enabled {boolean} whether the layer is visible or not
         */
        setEnabled: function( enabled ) {
            this.enabled = enabled;
            if ( this.olLayer ) {
                this.olLayer.setVisibility( enabled );
            }
            PubSub.publish( this.getChannel(), { field: 'enabled', value: enabled } );
        },

        /**
         * Get whether or not the layer is enabled.
         * @memberof Layer.prototype
         *
         * @returns {boolean} If the layer is visible or not.
         */
        isEnabled: function() {
            return this.enabled;
        },

        /**
         * Returns the UUID that uniquely identifies this layer.
         * @memberof Layer.prototype
         *
         * @returns {String} The UUID of the layer.
         */
        getUUID: function() {
            return this.uuid;
        },

        /**
         * Returns the publish/subscribe channel id of this specific layer.
         * @memberof Layer.prototype
         *
         * @returns {String} The publish/subscribe channel for the layer.
         */
        getChannel: function () {
            return 'layer.' + this.domain + '.' + this.uuid;
        }
    };

    module.exports = Layer;
}());

},{"../util/PubSub":59,"../util/Util":60}],16:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * @namespace LayerUtil
 * @classdesc A utility namespace containing layer related functionality.
 */
( function() {

    "use strict";

    /**
     * Parses a meta data extremum.
     * @private
     *
     * @param {*} The parsed extremum value.
     */
    function parseExtremum( extremum ) {
        var parsed;
        if ( typeof extremum === 'string' ) {
            parsed = JSON.parse( extremum );
        } else if ( extremum instanceof Array ) {
            if ( extremum.length === 1 &&
                typeof extremum[0] === 'string' ) {
                // graph meta data edge case, graph layer meta data
                // is a JSON string wrapped in an array
                parsed = JSON.parse( extremum[0] );
            } else if ( extremum.length > 0 &&
                extremum[0].maximum !== undefined ||
                extremum[0].minimum !== undefined ) {
                // bucketed tile data
                parsed = [];
                extremum.forEach( function( value ) {
                    var result = value.minimum !== undefined ? value.minimum : value.maximum;
                    parsed.push( result );
                });
            } else {
                parsed = [];
                extremum.forEach( function( value ) {
                    parsed.push( value );
                });
            }
        } else {
            parsed = extremum;
        }
        return parsed;
    }

    /**
     * Parse a given layers meta data min and max.
     * @private
     *
     * @param meta {Object} the layers meta data object.
     */
    function parseMetaMinMaxJson( meta ) {
        var minimum,
            maximum;
        try {
            // if meta value is a string, assume it is valid json
            if ( typeof meta === 'string' ) {
                // new meta data is valid json, hurray!
                return JSON.parse( meta );
            }
            if ( meta ) {
                maximum = parseExtremum( meta.maximum );
                minimum = parseExtremum( meta.minimum );
            }
            // sometimes the parsed value is also wrapped in an array
            return {
                maximum: maximum,
                minimum: minimum,
                bins: meta.bins
            };
        } catch ( e ) {
            console.error( "Error occured parsing layer meta data.");
            return null;
        }
        console.error( "Layer meta data format unrecognized.");
        return null;
    }

    /**
     * Meta data minimum and maximums are stored as malformed json
     * strings, but are usually accessed at a high frequency ( multiple
     * times per tile render ). This parses them all and stores them
     * as actual objects.
     * @private
     *
     * @param layerMeta {Object} the .meta node of the data returned for a layer
     *                           service call
     */
    function parseLevelsMinMax( layerMeta ) {
        var meta = layerMeta.meta,
            key;
        for ( key in meta ) {
            if ( meta.hasOwnProperty( key ) ) {
                if ( key !== "bucketCount" &&
                    key !== "rangeMin" &&
                    key !== "rangeMax" &&
                    key !== "topicType" &&
                    key !== "translatedTopics" ) {
                    meta[ key ] = parseMetaMinMaxJson( meta[key] );
                }
            }
        }
        return meta;
    }

    var LayerUtil = {

        /**
         * Parses a layer or an array of layer data objects, formats meta data
         * min and max and returns either the single layer, or a map of layers
         * keyed by layerId.
         * @memberof LayerUtil
         *
         * @param {Object|Array} layerData - layer data object or array of layer data objects.
         */
        parse: function( layerData ) {
            var layerMap,
                i;
            if ( !(layerData instanceof Array) ) {
                if ( layerData.meta ) {
                    parseLevelsMinMax( layerData.meta );
                }
                return layerData;
            }
            // if given an array, convert it into a map keyed by layerId
            layerMap = {};
            for ( i=0; i<layerData.length; i++ ) {
                if ( layerData[i].meta ) {
                    parseLevelsMinMax( layerData[i].meta );
                }
                layerMap[ layerData[i].id ] = layerData[i];
            }
            return layerMap;
        },

        /**
         * Given an OpenLayers.Layer class and a bounds object, return the x,
         * y, and y components of the tile.
         *
         * @param {OpenLayers.Layer) olLayer - The OpenLayers Layer object.
         * @param {OpenLayers.Bounds} bounds - The OpenLayers Bounds object.
         *
         * @returns {{x: (number), y: (number), z: integer}} The tile index.
         */
        getTileIndex: function( olLayer, bounds ) {
            var res = olLayer.map.getResolution(),
                maxBounds = olLayer.maxExtent,
                tileSize = olLayer.tileSize;
            return {
                xIndex: Math.round( (bounds.left - maxBounds.left) / (res * tileSize.w) ),
                yIndex: Math.round( (bounds.bottom - maxBounds.bottom) / (res * tileSize.h) ),
                level: olLayer.map.getZoom()
            };
        },

        /**
         * Given an OpenLayers.Layer class and a OpenLayers.Bounds object, return the
         * tilekey.
         *
         * @param {OpenLayers.Layer) olLayer - The OpenLayers Layer object.
         * @param {OpenLayers.Bounds} bounds - The OpenLayers Bounds object.
         *
         * @returns {String} The tilekey from the bounds.
         */
        getTilekey: function( olLayer, bounds ) {
            var tileIndex = LayerUtil.getTileIndex( olLayer, bounds ),
                x = tileIndex.xIndex,
                y = tileIndex.yIndex,
                z = tileIndex.level;
            return z + "," + x + "," + y;
        },

        /**
         * The getURL function passed to a OpenLayers TMS / Grid Layer to generate the
         * tile urls. Can be passed as is, or appended by using 'call'. The 'this'
         * context is set to the context of the OpenLayers layer.
         * @memberof LayerUtil
         *
         * @param {Object} bounds - The bounds object for the current tile.
         */
        getURL: function( bounds ) {
            var tileIndex = LayerUtil.getTileIndex( this, bounds ),
                x = tileIndex.xIndex,
                y = tileIndex.yIndex,
                z = tileIndex.level;
            if ( x >= 0 && y >= 0 ) {
                return this.url + this.layername + "/" + z + "/" + x + "/" + y + "." + this.type;
            }
        }
    };

    module.exports = LayerUtil;
}());

},{}],17:[function(require,module,exports){
/*
 * Copyright © 2013-2015 Uncharted Software Inc.
 *
 * Property of Uncharted™, formerly Oculus Info Inc.
 * http://uncharted.software/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
( function() {

    "use strict";

    var ClientLayer = require('./ClientLayer'),
        PubSub = require('../util/PubSub');

    function getURLFunc( layers ) {
        return function( bounds ) {
            return layers.map( function( layer ) {
                return layer.olLayer.getURL( bounds );
            });
        };
    }

    function MultiUrlClientLayer(spec) {
        ClientLayer.call( this, spec );
        this.getURL = getURLFunc( spec.source.layers );
    }

    MultiUrlClientLayer.prototype = Object.create( ClientLayer.prototype );

    // CDB: Not working properly yet.
    MultiUrlClientLayer.prototype.setLevelMinMax = function() {
        var zoomLevel = this.map.getZoom(),
            renderer = this.renderer;
        // apply this aggregator to child laeyrs
        var levelMinMax = this.source.layers.map( function( layer ) {
            var source = layer.source,
                meta = source.meta && source.meta.meta ? source.meta.meta[ zoomLevel ] : null,
                transformData = layer.tileTransform.data || {},
                levelMinMax = meta,
                aggregated;
            if ( meta ) {
                // aggregate the data if there is an aggregator attached
                if ( renderer && renderer.aggregator ) {
                    // aggregate the meta data buckets
                    aggregated = renderer.aggregator.aggregate(
                        meta.bins || [],
                        transformData.startBucket,
                        transformData.endBucket );
                    if ( aggregated instanceof Array ) {
                        // take the first and last index, which correspond to max / min
                        levelMinMax = {
                            minimum: aggregated[aggregated.length - 1],
                            maximum: aggregated[0]
                        };
                    } else {
                        //
                        levelMinMax = {
                            minimum: aggregated,
                            maximum: aggregated
                        };
                    }
                }
            } else {
                levelMinMax = {
                    minimum: null,
                    maximum: null
                };
            }
            return levelMinMax;
        });
        this.levelMinMax = levelMinMax;
        PubSub.publish( this.getChannel(), { field: 'levelMinMax', value: levelMinMax });
    };

    module.exports = MultiUrlClientLayer;
}());

},{"../util/PubSub":59,"./ClientLayer":9}],18:[function(require,module,exports){
( function() {

    'use strict';

    var Layer = require('./Layer'),
        LayerUtil = require('./LayerUtil'),
        PendingTile = require('./PendingTile'),
        HtmlTileLayer = require('./HtmlTileLayer'),
        PubSub = require('../util/PubSub'),
        DEBOUNCE_DELAY = 400,
        _animations = {},
        _counts = {},
        _prevTilekeys = {};

    function getTileHash( tile ) {
        return LayerUtil.getTilekey( tile.layer, tile.bounds ).replace( /,/g, "-" );
    }

    function clearPendingTile( tilekey ) {
        delete _counts[ tilekey ];
        clearTimeout( _animations[ tilekey ] );
        _animations[ tilekey ] = setTimeout( function() {
            $( '.olTilePending_' + tilekey ).css('opacity', 0);
            delete _animations[ tilekey ];
        }, DEBOUNCE_DELAY );
    }

    function flagPendingTile( tilekey ) {
        _counts[ tilekey ] = 0;
        if ( _animations[ tilekey ] ) {
            clearTimeout( _animations[ tilekey ] );
            delete _animations[ tilekey ];
        }
        $( '.olTilePending_' + tilekey ).css('opacity', 1);
    }

    function incrementRequestCount( tilekey, tileId ) {
        if ( !_counts[ tilekey ] ) {
            flagPendingTile( tilekey );
        }
        _counts[ tilekey ]++;
        _prevTilekeys[ tileId ] = tilekey;
    }

    function decrementRequestCount( tilekey, tileId ) {
        if ( !_counts[ tilekey ] ) {
            // this can occur if an 'unload' event occurs while pending
            return;
        }
        _counts[ tilekey ]--;
        if ( _counts[ tilekey ] === 0 ) {
            clearPendingTile( tilekey );
        }
        _prevTilekeys[ tileId ] = null;
    }

    function reloadTile( newKey, tileId ) {
        var oldKey = _prevTilekeys[ tileId ];
        decrementRequestCount( oldKey, tileId );
        incrementRequestCount( newKey, tileId );
    }

    function trackTiles( layer ) {
        return function( message ) {
            if ( layer.olLayer && message.field === "activate" ) {
                layer.olLayer.events.register( 'addtile', layer.olLayer, function( data ) {
                    // Add listeners to tile
                    data.tile.events.register( 'loadstart', data.tile, function( arg ) {
                        incrementRequestCount( getTileHash( arg.object ), arg.object.id );
                    });
                    data.tile.events.register( 'loadend', data.tile, function( arg ) {
                        decrementRequestCount( getTileHash( arg.object ), arg.object.id );
                    });
                    data.tile.events.register( 'loaderror', data.tile, function( arg ) {
                        decrementRequestCount( getTileHash( arg.object ), arg.object.id );
                    });
                    data.tile.events.register( 'reload', data.tile, function( arg ) {
                        reloadTile( getTileHash( arg.object ), arg.object.id );
                    });
                    data.tile.events.register( 'unload', data.tile, function( arg ) {
                        var tileId = arg.object.id;
                        decrementRequestCount( _prevTilekeys[ tileId ], tileId );
                    });
                });
            }
        };
    }

    function PendingLayer( spec ) {
        Layer.call( this, spec );
        this.zIndex = 9999;
        this.domain = "pending";
        this.source = {};
        this.tileClass = PendingTile;
    }

    PendingLayer.prototype = Object.create( Layer.prototype );

    PendingLayer.prototype.activate = function() {
        // add the new layer
        this.olLayer = new HtmlTileLayer(
            'Pending Tile Layer',
            this.source.tms,
            {
                layername: this.source.id,
                type: 'json',
                maxExtent: new OpenLayers.Bounds(
                    -20037500, -20037500,
                    20037500,  20037500),
                isBaseLayer: false,
                getURL: null,
                tileClass: this.tileClass
            });
        // set whether it is enabled or not before attaching, to prevent
        // needless tile reqeests
        this.setEnabled( this.isEnabled() );
        // publish activate event before appending to map
        PubSub.publish( this.getChannel(), { field: 'activate', value: true } );
        // attach to map
        this.map.olMap.addLayer( this.olLayer );
        // set z-index after
        this.setZIndex( this.zIndex );
        // publish add event
        PubSub.publish( this.getChannel(), { field: 'add', value: true } );
    };

    PendingLayer.prototype.deactivate = function() {
        if ( this.olLayer ) {
            this.map.olMap.removeLayer( this.olLayer );
            PubSub.publish( this.getChannel(), { field: 'remove', value: true } );
            this.olLayer.destroy();
            this.olLayer = null;
        }
        PubSub.publish( this.getChannel(), { field: 'deactivate', value: true } );
    };

    PendingLayer.prototype.setZIndex = function ( zIndex ) {
        // we by-pass the OpenLayers.Map.setLayerIndex() method and manually
        // set the z-index of the layer dev. setLayerIndex sets a relative
        // index based on current map layers, which then sets a z-index. This
        // caused issues with async layer loading.
        this.zIndex = zIndex;
        if ( this.olLayer ) {
            $( this.olLayer.div ).css( 'z-index', zIndex );
        }
        PubSub.publish( this.getChannel(), { field: 'zIndex', value: zIndex });
    };

    PendingLayer.prototype.getZIndex = function () {
        return this.zIndex;
    };

    PendingLayer.prototype.register = function( layer ) {
        layer.pendingFunc = trackTiles( layer );
        PubSub.subscribe( layer.getChannel(), layer.pendingFunc );
    };

    PendingLayer.prototype.unregister = function( layer ) {
        PubSub.unsubscribe( layer.getChannel(), layer.pendingFunc );
        delete layer.pendingFunc;
    };

    module.exports = PendingLayer;

}());

},{"../util/PubSub":59,"./HtmlTileLayer":13,"./Layer":15,"./LayerUtil":16,"./PendingTile":19}],19:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * An overridden OpenLayers.Tile object to create DOM elements based on
 * tile data. Used by HtmlTileLayers for client rendered layers. Uses
 * either Renderer objects or html functions to generate the DOM elements
 * or html strings.
 */

 ( function() {

    "use strict";

    var LayerUtil = require('./LayerUtil');

    function PendingTile() {
        OpenLayers.Tile.apply( this, arguments );
    }

    PendingTile.prototype = Object.create( OpenLayers.Tile.HTML.prototype );

    PendingTile.prototype.getURL = function() {
        return LayerUtil.getTilekey( this.layer, this.bounds ).replace( /,/g, "-" );
    };

    PendingTile.prototype.setImgSrc = function( url ) {
        var that  = this,
            img = this.imgDiv;
        if ( url ) {
            img.setAttribute( "data-url", url );
            that.onImageLoad.apply( that );
        } else {
            this.stopLoading();
            this.imgDiv = null;
            if ( img.parentNode ) {
                img.parentNode.removeChild( img );
            }
        }
    };

    PendingTile.prototype.onImageLoad = function() {
        var img = this.imgDiv;
        this.stopLoading();
        if ( img ) {
            // render the data
            this.renderHtml();
            // trigger load end
            this.events.triggerEvent("loadend");
            this.isLoading = false;
        }
    };

    PendingTile.prototype.getImage = function() {
        if ( !this.imgDiv ) {
            this.imgDiv = document.createElement( 'div' );
            this.imgDiv.className = 'olTileHtml olTilePending';
            this.imgDiv.style.position = "absolute";
        }
        return this.imgDiv;
    };

    PendingTile.prototype.renderHtml = function() {
        var imgDiv = this.imgDiv,
            url = imgDiv.getAttribute( "data-url", url );
        // clear tile contents
        imgDiv.className = 'olTileHtml olTilePending olTilePending_' + url;
		/*
		*Edit By RilaShu
		*将div内容修改为空，这样可以使得加载(css-loader)不再出现，治标了
		*/
        imgDiv.innerHTML = '<div>' +
        '</div>';
    };

    module.exports = PendingTile;

}());

},{"./LayerUtil":16}],20:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Util = require('../util/Util'),
        Layer = require('./Layer'),
        LayerUtil = require('./LayerUtil'),
        PubSub = require('../util/PubSub'),
        LegendService = require('../rest/LegendService');

    /**
     * Private: Request colour ramp image from server and set layer property when received.
     *
     * @param {Object} layer - The layer object
     * @param {Function} callback - Optional callback function.
     */
    function setRampImageUrl( layer, callback ) {
        LegendService.getEncodedImage( layer.source.id, {
                renderer: layer.renderer
            }, function ( url ) {
                layer.rampImageUrl = url;
                PubSub.publish( layer.getChannel(), { field: 'rampImageUrl', value: url });
                if ( callback ) {
                    callback( url );
                }
            });
    }

    /**
     * Private: Sets the layers min and max values for the given zoom level.
     *
     * @param layer {Object} the layer object.
     */
    function setLevelMinMax( layer ) {
        var zoomLevel = layer.map.getZoom(),
            coarseness = layer.renderer.coarseness,
            adjustedZoom = Math.max( zoomLevel - ( coarseness-1 ), 0 ),
            meta =  layer.source.meta,
            levelMinMax = meta.meta[ adjustedZoom ],
            minMax = levelMinMax ? levelMinMax : {
                minimum: null,
                maximum: null
            };
        layer.levelMinMax = minMax;
        PubSub.publish( layer.getChannel(), { field: 'levelMinMax', value: minMax });
    }

    /**
     * Private: Returns the zoom callback function to update level min and maxes.
     *
     * @param layer {ServerLayer} The layer object.
     */
    function zoomCallback( layer ) {
        return function() {
            if ( layer.olLayer ) {
                setLevelMinMax( layer );
            }
        };
    }

    /**
     * Instantiate a ServerLayer object.
     * @class ServerLayer
     * @classdesc A server rendered image layer that displays images retrieved from the server.
     *            Respective server side rendering parameters may be modified using the interface
     *            of the object.
     *
     * @param spec {Object} The Specification object.
     * <pre>
     * {
     *     opacity {float}   - The opacity of the layer. Default = 1.0.
     *     enabled {boolean} - Whether the layer is visible or not. Default = true.
     *     zIndex  {integer} - The z index of the layer. Default = 1.
     *     renderer: {
     *         coarseness {integer} - The pixel by pixel coarseness. Default based on server configuration.
     *         ramp       {String}  - The color ramp type. Default based on server configuration.
     *         rangeMin   {integer} - The minimum percentage to clamp the low end of the color ramp. Default based on server configuration.
     *         rangeMax   {integer} - The maximum percentage to clamp the high end of the color ramp. Default based on server configuration.
     *     },
     *     valueTransform: {
     *         type {String} - Value transformer type. Default based on server configuration.
     *     },
     *     tileTransform: {
     *         type {String} - Tile transformer type. Default based on server configuration.
     *         data {Object} - The tile transformer data initialization object. Default based on server configuration.
     *     }
     * }
     * </pre>
     */
    function ServerLayer( spec ) {
        var that = this,
            getURL = spec.getURL || LayerUtil.getURL;
        // call base constructor
        Layer.call( this, spec );
        // set reasonable defaults
        this.zIndex = ( spec.zIndex !== undefined ) ? parseInt( spec.zIndex, 10 ) : 1;
        spec.renderer = spec.renderer || {};
        this.renderer = spec.renderer;
        this.renderer.coarseness = ( spec.renderer.coarseness !== undefined ) ? parseInt( spec.renderer.coarseness, 10 ) : 1;
        this.renderer.rangeMin = ( spec.renderer.rangeMin !== undefined ) ? parseInt( spec.renderer.rangeMin, 10 ) : 0;
        this.renderer.rangeMax = ( spec.renderer.rangeMax !== undefined ) ? parseInt( spec.renderer.rangeMax, 10 ) : 100;
        this.valueTransform = spec.valueTransform || {};
        this.tileTransform = spec.tileTransform || {};
        this.domain = "server";
        this.source = spec.source;
        this.getURL = function( bounds ) {
            return getURL.call( this, bounds ) + that.getQueryParamString();
        };
    }

    ServerLayer.prototype = Object.create( Layer.prototype );

    /**
     * Activates the layer object. This should never be called manually.
     * @memberof ServerLayer
     * @private
     */
    ServerLayer.prototype.activate = function() {
        // set callback here so it can be removed later
        this.zoomCallback = zoomCallback( this );
        // set callback to update ramp min/max on zoom
        this.map.on( "zoomend", this.zoomCallback );
        // add the new layer
        this.olLayer = new OpenLayers.Layer.TMS(
            'Server Rendered Tile Layer',
            this.source.tms,
            {
                layername: this.source.id,
                type: 'png',
                maxExtent: new OpenLayers.Bounds(-20037500, -20037500,
                    20037500,  20037500),
                transparent: true,
                isBaseLayer: false,
                getURL: this.getURL
            });
        // set whether it is enabled or not before attaching, to prevent
        // needless tile requests
        this.setEnabled( this.isEnabled() );
        this.setTheme( this.map.getTheme() );  // sends initial request for ramp image
        this.setOpacity( this.getOpacity() );
        this.setBrightness( this.getBrightness() );
        this.setContrast( this.getContrast() );
        // publish activate event before appending to map
        PubSub.publish( this.getChannel(), { field: 'activate', value: true } );
        // attach to map
        this.map.olMap.addLayer( this.olLayer );
        // set z-index after
        this.setZIndex( this.zIndex );
        // publish add event
        PubSub.publish( this.getChannel(), { field: 'add', value: true } );
    };

    /**
     * Dectivates the layer object. This should never be called manually.
     * @memberof ServerLayer
     * @private
     */
    ServerLayer.prototype.deactivate = function() {
        if ( this.olLayer ) {
            this.map.olMap.removeLayer( this.olLayer );
            PubSub.publish( this.getChannel(), { field: 'remove', value: true } );
            this.olLayer.destroy();
            this.olLayer = null;
        }
        this.map.off( "zoomend", this.zoomCallback );
        this.zoomCallback = null;
        PubSub.publish( this.getChannel(), { field: 'deactivate', value: true } );
    };

    /**
     * Updates the theme associated with the layer.
     * @memberof ServerLayer
     *
     * @param {String} theme - The theme identifier string.
     */
    ServerLayer.prototype.setTheme = function( theme ) {
        var that = this;
        this.renderer.theme = theme;
        setRampImageUrl( that );
        this.redraw();
    };

    /**
     * Get the current theme for the layer.
     * @memberof ServerLayer
     *
     * @returns {String} The theme identifier string.
     */
    ServerLayer.prototype.getTheme = function() {
        return this.renderer.theme;
    };

    /**
     * Set the z index of the layer.
     * @memberof ServerLayer
     *
     * @param {integer} zIndex - The new z-order value of the layer, where 0 is front.
     */
    ServerLayer.prototype.setZIndex = function ( zIndex ) {
        // we by-pass the OpenLayers.Map.setLayerIndex() method and manually
        // set the z-index of the layer dev. setLayerIndex sets a relative
        // index based on current map layers, which then sets a z-index. This
        // caused issues with async layer loading.
        this.zIndex = zIndex;
        if ( this.olLayer ) {
            $( this.olLayer.div ).css( 'z-index', zIndex );
        }
        PubSub.publish( this.getChannel(), { field: 'zIndex', value: zIndex });
    };

    /**
     * Get the layers zIndex.
     * @memberof ServerLayer
     *
     * @returns {integer} The zIndex for the layer.
     */
    ServerLayer.prototype.getZIndex = function () {
        return this.zIndex;
    };

    /**
     * Set the ramp type associated with the layer.
     * @memberof ServerLayer
     *
     * @param {String} rampType - The ramp type used to render the images.
     * @param {Function} callback - Optional callback function.
     */
    ServerLayer.prototype.setRampType = function ( rampType, callback ) {
        if ( this.renderer.ramp !== rampType ) {
            this.renderer.ramp = rampType;
            setRampImageUrl( this, callback );
            this.redraw();
            PubSub.publish( this.getChannel(), {field: 'rampType', value: rampType} );
        }
    };

    /**
     * Get ramp type for layer.
     * @memberof ServerLayer
     *
     * @returns {String} The ramp identification string.
     */
    ServerLayer.prototype.getRampType = function() {
        return this.renderer.ramp;
    };

    /**
     * Get the current minimum and maximum values for the current zoom level.
     * @memberof ServerLayer
     *
     * @param {Object} The min and max of the level.
     */
    ServerLayer.prototype.getLevelMinMax = function() {
        var minMax = this.levelMinMax;

        if (this.valueTransform.layerMin && this.valueTransform.layerMin ) { // Give precedence to config override
            return {
                minimum: this.valueTransform.layerMin,
                maximum: this.valueTransform.layerMax
            };
        } else if ( minMax.maximum instanceof Array ) {
            var data = this.tileTransform.data,
                start = data.startBucket !== undefined ? data.startBucket : 0,
                stop = data.endBucket !== undefined ? data.endBucket : minMax.maximum.length-1,
                minimum = 0,
                maximum = 0,
                i;
            for ( i=start; i<=stop; i++ ) {
                minimum += minMax.minimum[i] || 0;
                maximum += minMax.maximum[i] || 0;
            }
            return {
                minimum: minimum,
                maximum: maximum
            };
        }
        return this.levelMinMax;
    };

    /**
     * Get the current ramp image URL string.
     * @memberof ServerLayer
     *
     * @returns {String} The encoded ramp image url.
     */
    ServerLayer.prototype.getRampImageUrl = function() {
        return this.rampImageUrl;
    };

    /**
     * Set the current value by which the minimum color ramp is clamped to by percentage
     * in the range [0-1].
     * @memberof ServerLayer
     *
     * @param {number} min - The range min in percentage.
     */
    ServerLayer.prototype.setRangeMinPercentage = function( min ) {
        min = Math.max( Math.min( min, 1 ), 0 ) * 100;
        if ( this.renderer.rangeMin !== min ) {
            this.renderer.rangeMin = min;
            this.redraw();
            PubSub.publish( this.getChannel(), { field: 'rangeMin', value: min });
        }
    };

    /**
     * Get the current value by which the minimum color ramp is clamped to by percentage
     * in the range [0-1].
     * @memberof ServerLayer
     *
     * @returns {number} The range max in percentage.
     */
    ServerLayer.prototype.getRangeMinPercentage = function() {
        return this.renderer.rangeMin / 100;
    };

    /**
     * Set the current value by which the maximum color ramp is clamped to by percentage
     * in the range [0-1].
     * @memberof ServerLayer
     *
     * @param {number} max - The range max in percentage.
     */
    ServerLayer.prototype.setRangeMaxPercentage = function( max ) {
        max = Math.max( Math.min( max, 1 ), 0 ) * 100;
        if ( this.renderer.rangeMax !== max ) {
            this.renderer.rangeMax = max;
            this.redraw();
            PubSub.publish( this.getChannel(), {field: 'rangeMax', value: max} );
        }
    };

    /**
     * Get the current value by which the maximum color ramp is clamped to by percentage
     * in the range [0-1].
     * @memberof ServerLayer
     *
     * @returns {number} The range min in percentage.
     */
    ServerLayer.prototype.getRangeMaxPercentage = function() {
        return this.renderer.rangeMax / 100;
    };

    /**
    * Set the current value by which the minimum color ramp is clamped to.
    * @memberof ServerLayer
    *
    * @param {number} min - The range min by value.
    */
    ServerLayer.prototype.setRangeMinValue = function( min ) {
        this.setRangeMinPercentage(
            Util.normalizeValue(
                min,
                this.getLevelMinMax(),
                this.getValueTransformType()
            )
        );
    };

    /**
    * Get the current value by which the minimum color ramp is clamped to.
    * @memberof ServerLayer
    *
    * @returns {number} The range min by value.
    */
    ServerLayer.prototype.getRangeMinValue = function() {
        return Util.denormalizeValue(
            this.getRangeMinPercentage(),
            this.getLevelMinMax(),
            this.getValueTransformType() );
    };

    /**
    * Set the current value by which the maximum color ramp is clamped to.
    * @memberof ServerLayer
    *
    * @param {number} max - The range max by value.
    */
    ServerLayer.prototype.setRangeMaxValue = function( max ) {
        this.setRangeMaxPercentage(
            Util.normalizeValue(
                max,
                this.getLevelMinMax(),
                this.getValueTransformType()
            )
        );
    };

    /**
    * Get the current value by which the maximum color ramp is clamped to.
    * @memberof ServerLayer
    *
    * @returns {number} The range max by value.
    */
    ServerLayer.prototype.getRangeMaxValue = function() {
        return Util.denormalizeValue(
            this.getRangeMaxPercentage(),
            this.getLevelMinMax(),
            this.getValueTransformType() );
    };

    /**
     * Updates the value transform function associated with the layer. Results in a POST
     * request to the server.
     * @memberof ServerLayer
     *
     * @param {String} transformType - The new new ramp function.
     */
    ServerLayer.prototype.setValueTransformType = function ( transformType ) {
        if ( this.valueTransform.type !== transformType ) {
            this.valueTransform.type = transformType;
            this.redraw();
            PubSub.publish( this.getChannel(), { field: 'valueTransformType', value: transformType });
        }
    };

    /**
     * Get the current value transform function type.
     * @memberof ServerLayer
     *
     * @return {String} The value transform type.
     */
    ServerLayer.prototype.getValueTransformType = function() {
        return this.valueTransform.type;
    };

    /**
     * Set the layers tile transform function type.
     * @memberof ServerLayer
     *
     * @param {String} transformType - The tile transformer type.
     */
    ServerLayer.prototype.setTileTransformType = function ( transformType ) {
        if ( this.tileTransform.type !== transformType ) {
            this.tileTransform.type = transformType;
            this.redraw();
            PubSub.publish( this.getChannel(), {field: 'tileTransformType', value: transformType} );
        }
    };

    /**
     * Get the layers transformer type.
     * @memberof ServerLayer
     *
     * @return {String} The tile transform type.
     */
    ServerLayer.prototype.getTileTransformType = function () {
        return this.tileTransform.type;
    };

	/**
     * Set the tile transform data based on the time range passed in
     * @memberof ServerLayer
     *
     * @param {number} start - A unix timestamp representing the start of the time range
     * @param {number} end - A unix timestamp representing the end of the time range
     */
    ServerLayer.prototype.setTileTransformRange = function ( start, end ) {
        var meta = this.source.meta.meta,
			rangeMin = meta.rangeMin,
			rangeMax = meta.rangeMax,
			numBuckets = meta.bucketCount,
            bucketSize = ( rangeMax - rangeMin ) / numBuckets;
        if ( start > rangeMax && end < rangeMin ) {
            // outside range completely, send empty request
			this.setTileTransformData({
    			startBucket: -1,
    			endBucket: -1
            });
		}
        this.setTileTransformData({
			startBucket: Math.max( 0, Math.floor( ( start - rangeMin ) / bucketSize ) ),
			endBucket: Math.min( numBuckets-1, Math.floor( ( end - rangeMin ) / bucketSize ) )
        });
	};

    /**
     * Set the tile transform data attribute
     * @memberof ServerLayer
     *
     * @param {Object} transformData - The tile transform data attribute.
     */
    ServerLayer.prototype.setTileTransformData = function ( transformData ) {
        if ( !_.isEqual( this.tileTransform.data, transformData ) ) {
            this.tileTransform.data = transformData;
            this.redraw();
            PubSub.publish( this.getChannel(), {field: 'tileTransformData', value: transformData} );
        }
    };

    /**
     * Get the transformer data attribute.
     * @memberof ServerLayer
     *
     * @returns {Object} The tile transform data attribute.
     */
    ServerLayer.prototype.getTileTransformData = function () {
        return this.tileTransform.data || {};
    };

    /**
     * Set the layers pixel coarseness.
     * @memberof ServerLayer
     *
     * @param coarseness {integer} The pixel by pixel coarseness of the layer
     */
    ServerLayer.prototype.setCoarseness = function( coarseness ) {
        if ( this.renderer.coarseness !== coarseness ) {
            this.renderer.coarseness = coarseness;
            setLevelMinMax( this ); // coarseness modifies the min/max
            this.redraw();
            PubSub.publish( this.getChannel(), { field: 'coarseness', value: coarseness });
        }
    };

    /**
     * Get the layers pixel coarseness.
     * @memberof ServerLayer
     *
     * @returns {integer} The layers coarseness in N by N pixels.
     */
    ServerLayer.prototype.getCoarseness = function() {
        return this.renderer.coarseness;
    };

    ServerLayer.prototype.setFilterParams = function( filter ) {
    	this.filterParams = filter;
    	this.redraw();
    };

    ServerLayer.prototype.getFilterParams = function(){
    	return this.filterParams ? this.filterParams : null;
    };

    /**
     * Generate query parameters based on state of layer
     * @memberof ServerLayer
     *
     * @returns {String} The query parameter string based on the attributes of this layer.
     */
    ServerLayer.prototype.getQueryParamString = function() {
        var query = {
            renderer: this.renderer,
            tileTransform: this.tileTransform,
            valueTransform: this.valueTransform,
            filter: this.getFilterParams()
        };
        return Util.encodeQueryParams( query );
    };

    /**
     * Redraws the entire layer.
     * @memberof ServerLayer
     */
    ServerLayer.prototype.redraw = function () {
        if ( this.olLayer ) {
            setLevelMinMax( this );
            this.olLayer.redraw();
            // If we're using the TileManager we need to force it into a refresh. There is no nice way to
            // do this as of 2.13.1, so we fake the expiry of the move/zoom timeout.
            if ( this.olLayer.map && this.olLayer.map.tileManager ) {
                this.olLayer.map.tileManager.updateTimeout(
                    this.olLayer.map,
                    this.olLayer.map.tileManager.zoomDelay,
                    true );
            }
        }
    };

    module.exports = ServerLayer;
}());

},{"../rest/LegendService":49,"../util/PubSub":59,"../util/Util":60,"./Layer":15,"./LayerUtil":16}],21:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var HtmlTile = require('./HtmlTile');

    function clampBounds( bounds, layer ) {
        bounds = bounds.clone();
        if ( layer.dimension === "x" ) {
            bounds.bottom = layer.map.getMaxExtent().bottom;
            bounds.top = layer.map.getMaxExtent().bottom + 1;
        } else {
            bounds.left = layer.map.getMaxExtent().left;
            bounds.right = layer.map.getMaxExtent().left + 1;
        }
        return bounds;
    }

    OpenLayers.Tile.Univariate = function() {
        OpenLayers.Tile.HTML.apply( this, arguments );
    };

    OpenLayers.Tile.Univariate.prototype = Object.create( HtmlTile.prototype );

    /**
     * Override this method to clamp the 'mapExtent' value for the map
     * object.
     */
    OpenLayers.Tile.Univariate.prototype.shouldDraw = function() {
        var withinMaxExtent = false,
            maxExtent = clampBounds( this.layer.maxExtent, this.layer );
        if ( maxExtent ) {
            var map = this.layer.map,
                bounds = map.getMaxExtent();
            var worldBounds = map.baseLayer.wrapDateLine && clampBounds( bounds, this.layer );
            if ( this.bounds.intersectsBounds( maxExtent, {inclusive: false, worldBounds: worldBounds} ) ) {
                withinMaxExtent = true;
            }
        }
        return withinMaxExtent || this.layer.displayOutsideMaxExtent;
    };

    /**
     * Override this method to inject the 'olUnivariateTile' class instead
     * of the usual olHtmlTile.
     */
    OpenLayers.Tile.Univariate.prototype.getImage = function() {
        if ( !this.imgDiv ) {
            this.imgDiv = document.createElement( 'div' );
            this.imgDiv.className = 'olTileUnivariate';
            var style = this.imgDiv.style;
            style.visibility = "hidden";
            style.opacity = 0;
            if ( this.layer.opacity < 1 ) {
                style.filter = 'alpha(opacity=' + (this.layer.opacity * 100) + ')';
            }
            style.position = "absolute";
        }
        return this.imgDiv;
    };

    /**
     * Override this method to inject the 'olUnivariateTile' class instead
     * of the usual olHtmlTile.
     */
    OpenLayers.Tile.Univariate.prototype.positionTile = function() {
        var style = this.getTile().style,
            size = this.layer.getImageSize(this.bounds),
            ratio = 1;
        if ( this.layer instanceof OpenLayers.Layer.Grid ) {
            ratio = this.layer.getServerResolution() / this.layer.map.getResolution();
        }
        style.left = this.position.x + "px";
        style.top = "-256px";
        style.width = Math.round(ratio * size.w) + "px";
        style.height = Math.round(ratio * size.h) + "px";
    };

    module.exports = OpenLayers.Tile.Univariate;
}());

},{"./HtmlTile":12}],22:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var UnivariateTile = require('./UnivariateTile');

    function clampBounds( bounds, layer ) {
        bounds = bounds.clone();
        if ( layer.dimension === "x" ) {
            bounds.bottom = layer.map.getMaxExtent().bottom;
            bounds.top = layer.map.getMaxExtent().bottom + 1;
        } else {
            bounds.left = layer.map.getMaxExtent().left;
            bounds.right = layer.map.getMaxExtent().left + 1;
        }
        return bounds;
    }

    function repositionLayer( map, layer ) {
        var $viewport = $( map.viewPortDiv ),
            $div = $( layer.div ),
            height = $viewport.height();
        if ( layer.dimension === "x" )  {
            $div.css( 'top', height );
        } else {
            $div.css( 'left', 0 );
        }
        updateTilePositions(map, layer);
    }

    function onMapMove( map, layer ) {
        return function() {
            updateTilePositions(map, layer);
        };
    }

    function updateTilePositions(map, layer) {
        var $container = $( layer.div ).parent(),
            $viewport = $( map.viewPortDiv ),
            $div = $( layer.div ),
            offset = $container.position(),
            height = $viewport.height();
        if ( layer.dimension === "x" ) {
            // reset tile position within the layer div
            $div.children().each( function() {
                $( this ).css( 'top', -256 );
            });
            // then set div position
            $div.css( 'top', height - offset.top );
        } else {
            // reset tile position within the layer div
            $div.children().each( function() {
                $( this ).css( 'left', 0 );
            });
            // then set div position
            $div.css( 'left', -offset.left );
        }
    }

    OpenLayers.Layer.Univariate = function( name, url, options ) {
        OpenLayers.Layer.Grid.call( this, name, url, options );
        this.getURL = options.getURL;
        this.layername = options.layername;
        this.dimension = options.dimension || 'x';
        this.type = options.type;
        this.tileClass = options.tileClass || UnivariateTile;
        this.html = options.html;
        this.renderer = options.renderer;
        this.CLASS_NAME = 'OpenLayers.Layer.Univariate';
    };

    OpenLayers.Layer.Univariate.prototype = Object.create( OpenLayers.Layer.Grid.prototype );

    /**
     * Override to set all children the opacity.
     */
    OpenLayers.Layer.Univariate.prototype.setOpacity = function( opacity ) {
        if ( opacity !== this.opacity ) {
            this.opacity = Math.max( Math.min( opacity, 1 ), 0 );
            var childNodes = this.div.childNodes;
            for( var i = 0, len = childNodes.length; i < len; ++i ) {
                childNodes[i].style.opacity = this.opacity;
            }
            if ( this.map !== null ) {
                this.map.events.triggerEvent( "changelayer", {
                    layer: this,
                    property: "opacity"
                });
            }
        }
    };

    /**
     * Override this method to add a positioning function to clamp
     * the layers tiles to the appropriate axis.
     */
    OpenLayers.Layer.Univariate.prototype.setMap = function( map ) {
        OpenLayers.Layer.Grid.prototype.setMap.apply( this, arguments );
        this.onMapMove = onMapMove( map, this );
        map.events.register( 'move', map, this.onMapMove );
        repositionLayer( map, this ); // set position
    };

    /**
     * Override this method to remove the positioning function to clamp
     * the layers tiles to the appropriate axis.
     */
    OpenLayers.Layer.Univariate.prototype.removeMap = function( map ) {
        OpenLayers.Layer.Grid.prototype.removeMap.apply( this, arguments );
        map.events.unregister( 'move', map, this.onMapMove );
        this.onMapMove = null;
    };

    /**
     * Override this method to re-position the layer and prevent a redraw which
     * will reposition the tiles.
     */
    OpenLayers.Layer.Univariate.prototype.setVisibility = function( visibility ) {
        OpenLayers.Layer.Grid.prototype.setVisibility.apply( this, arguments );
        if ( this.onMapMove && visibility ) {
            repositionLayer( this.map, this );
        }
    };

    OpenLayers.Layer.Univariate.prototype.getExtent = function() {
        return clampBounds( this.map.calculateBounds(), this );
    };

    OpenLayers.Layer.Univariate.prototype.redraw = function() {
        var redrawn = false;
        if (this.map) {
            // min/max Range may have changed
            this.inRange = this.calculateInRange();
            // map's center might not yet be set
            var extent = this.getExtent();
            if ( extent && this.inRange && this.visibility ) {
                var zoomChanged = true;
                this.moveTo( extent, zoomChanged, false );
                this.events.triggerEvent("moveend",
                    {"zoomChanged": zoomChanged});
                redrawn = true;
                repositionLayer( this.map, this );
            }
        }
        return redrawn;
    };

    /**
     * Override this method to clamp the 'maxExtents' value returned from the
     * map object.
     */
    OpenLayers.Layer.Univariate.prototype.moveTo = function( bounds, zoomChanged, dragging ) {

        if ( !bounds ) {
            bounds = this.map.getExtent();
        }

        if ( bounds !== null ) {

            bounds = clampBounds( bounds, this );

            // if grid is empty or zoom has changed, we *must* re-tile
            var forceReTile = !this.grid.length || zoomChanged;

            // total bounds of the tiles
            var tilesBounds = this.getTilesBounds();

            // the new map resolution
            var resolution = this.map.getResolution();

            // the server-supported resolution for the new map resolution
            var serverResolution = this.getServerResolution(resolution);

            if ( this.singleTile ) {

                // We want to redraw whenever even the slightest part of the
                //  current bounds is not contained by our tile.
                //  (thus, we do not specify partial -- its default is false)

                if ( forceReTile ||
                     ( !dragging && !tilesBounds.containsBounds( bounds ) ) ) {

                    // In single tile mode with no transition effect, we insert
                    // a non-scaled backbuffer when the layer is moved. But if
                    // a zoom occurs right after a move, i.e. before the new
                    // image is received, we need to remove the backbuffer, or
                    // an ill-positioned image will be visible during the zoom
                    // transition.

                    if ( zoomChanged && this.transitionEffect !== 'resize' ) {
                        this.removeBackBuffer();
                    }

                    if ( !zoomChanged || this.transitionEffect === 'resize' ) {
                        this.applyBackBuffer( serverResolution );
                    }

                    this.initSingleTile( bounds );
                }
            } else {

                // if the bounds have changed such that they are not even
                // *partially* contained by our tiles (e.g. when user has
                // programmatically panned to the other side of the earth on
                // zoom level 18), then moveGriddedTiles could potentially have
                // to run through thousands of cycles, so we want to reTile
                // instead (thus, partial true).
                forceReTile = forceReTile ||
                    !tilesBounds.intersectsBounds( bounds, {
                        worldBounds: this.map.baseLayer.wrapDateLine &&
                            clampBounds( this.map.getMaxExtent(), this )
                    });

                if ( resolution !== serverResolution ) {
                    bounds = this.map.calculateBounds( null, serverResolution );
                    bounds = clampBounds( bounds, this );
                    if( forceReTile ) {
                        // stretch the layer div
                        var scale = serverResolution / resolution;
                        this.transformDiv( scale );
                    }
                } else {
                    // reset the layer width, height, left, top, to deal with
                    // the case where the layer was previously transformed
                    this.div.style.width = '100%';
                    this.div.style.height = '100%';
                    this.div.style.left = '0%';
                    this.div.style.top = '0%';
                }

                if ( forceReTile ) {
                    if ( zoomChanged && this.transitionEffect === 'resize' ) {
                        this.applyBackBuffer( serverResolution );
                    }
                    this.initGriddedTiles( bounds );
                } else {
                    this.moveGriddedTiles();
                }
            }
        }
    };

    /**
     * Override this method to only shift the appropriate row or column
     * of the grid depending the the dimension this layer represents.
     */
    OpenLayers.Layer.Univariate.prototype.moveGriddedTiles = function() {
        var buffer = this.buffer + 1;
        while(true) {
            var tlTile = this.grid[0][0];
            var tlViewPort = {
                x: tlTile.position.x +
                this.map.layerContainerOriginPx.x,
                y: tlTile.position.y +
                this.map.layerContainerOriginPx.y
            };
            var ratio = this.getServerResolution() / this.map.getResolution();
            var tileSize = {
                w: Math.round(this.tileSize.w * ratio),
                h: Math.round(this.tileSize.h * ratio)
            };
            if (this.dimension === 'x') {
                if (tlViewPort.x > -tileSize.w * (buffer - 1)) {
                    this.shiftColumn(true, tileSize);
                } else if (tlViewPort.x < -tileSize.w * buffer) {
                    this.shiftColumn(false, tileSize);
                } else {
                    break;
                }
            } else {
                if (tlViewPort.y > -tileSize.h * (buffer - 1)) {
                    this.shiftRow(true, tileSize);
                } else if (tlViewPort.y < -tileSize.h * buffer) {
                    this.shiftRow(false, tileSize);
                } else {
                    break;
                }
            }
        }
    };
    module.exports = OpenLayers.Layer.Univariate;
}());

},{"./UnivariateTile":21}],23:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

(function() {

    "use strict";

    var Layer = require('./Layer'),
        PubSub = require('../util/PubSub');

    /**
     * Instantiate a VectorLayer object.
     * @class VectorLayer
     * @augments Layer
     * @classdesc A client rendered layer object.
     *
     * @param {Object} spec - The specification object.
     * <pre>
     * {
     *     opacity  {float}    - The opacity of the layer. Default = 1.0
     *     enabled  {boolean}  - Whether the layer is visible or not. Default = true
     *     zIndex   {integer}  - The z index of the layer. Default = 1000
     *     vectors {Array}     - Array of OpenLayers Vector objects to add to the map
     * }
     * </pre>
     */
    function VectorLayer(spec) {
        // call base constructor
        Layer.call(this, spec);
        // set reasonable defaults
        this.zIndex = spec.zIndex || 749;
        this.domain = spec.domain || "vector";
        this.source = spec.source;
        this.styleMap = spec.styleMap;
        this.strategies = spec.strategies;
        this.getData = spec.getData;
        this.teardown = spec.teardown;
        this.olFeatures = spec.olFeatures || [];
        this.group = spec.group || "";
    }

    VectorLayer.prototype = Object.create(Layer.prototype);

    /**
     * Activates the layer object. This should never be called manually.
     * @memberof VectorLayer
     * @private
     */
    VectorLayer.prototype.activate = function() {
        var layerSpec = {};
        if ( this.strategies ) {
            layerSpec.strategies = this.strategies;
        }
        if ( this.styleMap ) {
            layerSpec.styleMap = this.styleMap;
        }
        this.olLayer = new OpenLayers.Layer.Vector("Vector Layer", layerSpec);
        this.setEnabled( this.isEnabled() );
        this.setOpacity( this.getOpacity() );
        this.setBrightness( this.getBrightness() );
        this.setContrast( this.getContrast() );
        this.setTheme( this.map.getTheme() );
        // publish activate event before appending to map
        PubSub.publish( this.getChannel(), { field: 'activate', value: true } );
        this.map.olMap.addLayer( this.olLayer );
        if ( this.getData ) {
            this.getData( this );
        }
        if ( this.olFeatures ) {
            this.setFeatures( this.olFeatures );
        }
        this.setZIndex( this.zIndex );
        // publish add event
        PubSub.publish( this.getChannel(), { field: 'add', value: true } );
    };

    /**
     * Dectivates the layer object. This should never be called manually.
     * @memberof VectorLayer
     * @private
     */
    VectorLayer.prototype.deactivate = function() {
        if (this.teardown) {
            this.teardown();
        }
        if (this.olLayer) {
            if (this.olLayer.strategies) {
                this.olLayer.strategies.forEach(function(strategy) {
                    strategy.deactivate();
                });
            }
            this.olLayer.strategies = [];
            this.map.olMap.removeLayer(this.olLayer);
            PubSub.publish( this.getChannel(), { field: 'remove', value: true } );
            this.olLayer.destroyFeatures();
            this.olLayer.destroy();
            this.olLayer = null;
        }
        PubSub.publish( this.getChannel(), { field: 'deactivate', value: true } );
    };

    /**
     * Remove all features from the layer and add the new features
     * passed in
     *
     * @param {Array} featuresToAdd - Array of OpenLayers Features
     */
    VectorLayer.prototype.setFeatures = function(featuresToAdd) {
        if (this.olLayer) {
            this.olLayer.destroyFeatures();
            this.olFeatures = featuresToAdd;
            this.olLayer.addFeatures(featuresToAdd);
        }
    };

    /**
     * Updates the theme associated with the layer.
     * @memberof VectorLayer
     *
     * @param {String} theme - The theme identifier string.
     */
    VectorLayer.prototype.setTheme = function(theme) {
        this.theme = theme;
    };

    /**
     * Get the current theme for the layer.
     * @memberof VectorLayer
     *
     * @returns {String} The theme identifier string.
     */
    VectorLayer.prototype.getTheme = function() {
        return this.theme;
    };

    /**
     * Set the z index of the layer.
     * @memberof VectorLayer
     *
     * @param {integer} zIndex - The new z-order value of the layer, where 0 is front.
     */
    VectorLayer.prototype.setZIndex = function(zIndex) {
        // we by-pass the OpenLayers.Map.setLayerIndex() method and manually
        // set the z-index of the layer dev. setLayerIndex sets a relative
        // index based on current map layers, which then sets a z-index. This
        // caused issues with async layer loading.
        this.zIndex = zIndex;
        if (this.olLayer) {
            $(this.olLayer.div).css('z-index', zIndex);
            PubSub.publish(this.getChannel(), {
                field: 'zIndex',
                value: zIndex
            });
        }
    };

    /**
     * Get the layers zIndex.
     * @memberof VectorLayer
     *
     * @returns {integer} The zIndex for the layer.
     */
    VectorLayer.prototype.getZIndex = function() {
        return this.zIndex;
    };

    module.exports = VectorLayer;
}());

},{"../util/PubSub":59,"./Layer":15}],24:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Renderer = require('./Renderer'),
        RendererUtil = require('./RendererUtil'),
        injectCss,
        getLabelWidth,
        capitalize;

    injectCss = function( spec ) {
        var i;
        if ( spec.text.themes ) {
            for ( i=0; i<spec.text.themes.length; i++ ) {
                spec.text.themes[i].injectTheme({
                    selector: ".node-label"
                });
            }
        }
    };

    /**
     * Returns the pixel width of the label
     */
     getLabelWidth = function( str, fontSize ) {
        var $temp,
            width;
        $temp = $('<div class="node-label" style="font-size:'+fontSize+'px; padding-left:5px; padding-right:5px;">'+str+'</div>');
        $('body').append( $temp );
        width = $temp.outerWidth();
        $temp.remove();
        return width;
    };

    /**
     * Capitalizes the given word.
     */
    capitalize = function( str ) {
        return str.replace(/(?:^|,|\s)\S/g, function( a ) {
            return a.toUpperCase();
        });
    };

    /**
     * Instantiate a GraphLabelRenderer object.
     * @class GraphLabelRenderer
     * @augments Renderer
     * @classDesc A Renderer implementation that renders a set of graph labels.
     *
     * @param spec {Object} The specification object.
     * <pre>
     * {
     *     text: {
     *         xKey   {String|Function} - The attribute for the x coordinate.
     *         yKey   {String|Function} - The attribute for the y coordinate.
     *         themes {Array}  - The array of RenderThemes to be attached to this component.
     *     }
     * }
     * </pre>
     */
    function GraphLabelRenderer( spec ) {
        spec.rootKey = spec.rootKey || "tile.values[0].value[0].communities";
        Renderer.call( this, spec );
        injectCss( this.spec );
    }

    GraphLabelRenderer.prototype = Object.create( Renderer.prototype );

    /**
     * Implementation specific rendering function.
     * @memberof GraphLabelRenderer
     * @private
     *
     * @param {Object} data - The raw data for a tile to be rendered.
     *
     * @returns {{html: string, entries: Array}} The html to render and an array of all rendered data entries.
     */
    GraphLabelRenderer.prototype.render = function( data ) {

        var GRAPH_COORD_RANGE = 256,
            text = this.spec.text,
            levelMinMax = this.parent.getLevelMinMax(),
            communities = RendererUtil.getAttributeValue( data, this.spec.rootKey ),
            scale = Math.pow( 2, this.parent.map.getZoom() ),
            range =  GRAPH_COORD_RANGE / scale,
            labelIndex = ( text.labelIndex !== undefined ) ? text.labelIndex : 0,
            community,
            html = "",
            count,
            fontSize,
            split,
            label,
            width,
            minimumCount,
            maximumCount,
            percent,
            percentLabel,
            hierLevel,
            parentIDarray = [],
            entries = [],
            x, y, i;



        // get graph hierarchy level for this zoom level
        // assumes same hierarchy level for all tiles at a given zoom level
        hierLevel = levelMinMax.maximum.communities[0].hierLevel;

        // if hierLevel = 0, normalize label attributes by community degree
        // else normalize label attributes by num internal nodes
        if ( hierLevel === 0 ) {
            minimumCount =  levelMinMax.minimum.communities[0].degree;
            maximumCount =  levelMinMax.maximum.communities[0].degree;
        } else {
            minimumCount =  levelMinMax.minimum.communities[0].numNodes;
            maximumCount =  levelMinMax.maximum.communities[0].numNodes;
        }

        for ( i=0; i<communities.length; i++ ) {

            community = communities[i];

            // capitalize label array, split by comma
            split = community.metadata.split(",");
            // don't draw labels for isolated communities
            // and don't render if label string is empty
            // only draw one label per parent community per tile
            // only draw up to 5 labels per tile
            if ( community.degree === 0 ||
                 split[ labelIndex ] === "" ||
                 parentIDarray.length >= 5 ||
                 parentIDarray.indexOf( community.parentID ) !== -1 ) {
                // Skip this label entry
                continue;
            }
            else {
                // add this parent ID to the list, and draw the label (below
                parentIDarray.push( community.parentID );
            }

            // add to entries only if there is a legible label
            entries.push( community );

            // get label position
            x = ( community[ text.xKey ] % range ) * scale;
            y = ( community[ text.yKey ] % range ) * scale;

            // capitalize label
            label = capitalize( split[ labelIndex ].toLowerCase() );

            // get font scale based on hierarchy level
            count = ( hierLevel === 0 ) ? community.degree : community.numNodes;
            fontSize = RendererUtil.getFontSize(
                count, minimumCount, maximumCount, { type:'log' } );

            // calc percent label
            percent = RendererUtil.transformValue( count, minimumCount, maximumCount, 'log' );
            percentLabel = Math.round( ( percent*100 ) / 10 ) * 10;

            // calc width for centering
            width = getLabelWidth( label, fontSize );
            width = Math.min( width, 200 );

            html += '<div class="node-label node-label-'+percentLabel+'" style="'
                + 'left:'+x+'px;'
                + 'bottom:'+y+'px;'
                + 'font-size:' + fontSize + 'px;'
                + 'line-height:' + fontSize + 'px;'
                + 'width:' + width + 'px;'
                + 'margin-left:' + (-width/2) + 'px;'
                + 'margin-top:' + (-fontSize/2) + 'px;'
                + 'height:' + fontSize + 'px;'
                + 'z-index:' + Math.floor( fontSize ) + ';'
                + '">'+label+'</div>';

        }
        return {
            html: html,
            entries: entries
        };
    };

    module.exports = GraphLabelRenderer;
}());

},{"./Renderer":29,"./RendererUtil":30}],25:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Renderer = require('./Renderer'),
        RendererUtil = require('./RendererUtil'),
        injectCss;

    injectCss = function( spec ) {
        var i;
        if ( spec.node.themes ) {
            for (i = 0; i < spec.node.themes.length; i++) {
                spec.node.themes[i].injectTheme({
                    selector: ".community-node"
                });
            }
        }
        if ( spec.criticalNode.themes ) {
            for (i = 0; i < spec.criticalNode.themes.length; i++) {
                spec.criticalNode.themes[i].injectTheme({
                    selector: ".community-node.community-critical-node"
                });
            }
        }
        if ( spec.parentNode.themes ) {
            for (i = 0; i < spec.parentNode.themes.length; i++) {
                spec.parentNode.themes[i].injectTheme({
                    selector: ".community-parent-node"
                });
            }
        }
    };

    /**
     * Instantiate a GraphNodeRenderer object.
     * @class GraphNodeRenderer
     * @augments Renderer
     * @classDesc A Renderer implementation that renders a set of graph nodes.
     *
     * @param spec {Object} The specification object.
     * <pre>
     * {
     *     node: {
     *         xKey      {String|Function} - The attribute for the x coordinate.
     *         yKey      {String|Function} - The attribute for the y coordinate.
     *         radiusKey {String|Function} - The attribute for the node radius.
     *         themes    {Array}   The array of RenderThemes to be attached to this component.
     *     },
     *     criticalNode: {
     *         flag     {String|Function} - The boolean attribute to designate critical nodes.
     *         themes   {Array}  - The array of RenderThemes to be attached to this component.
     *     },
     *     parentNode: {
     *         xKey      {String|Function} - The attribute for the parent node x coordinate.
     *         yKey      {String|Function} - The attribute for the parent node y coordinate.
     *         radiusKey {String|Function} - The attribute for the node radius.
     *         themes    {Array}  - The array of RenderThemes to be attached to this component.
     *     }
     * }
     * </pre>
     */
    function GraphNodeRenderer( spec ) {
        spec.rootKey = spec.rootKey || "tile.values[0].value[0].communities";
        spec.node = spec.node || {};
        spec.node.xKey = spec.node.xKey || 'x';
        spec.node.yKey = spec.node.yKey || 'y';
        spec.node.radiusKey = spec.node.radiusKey || 'r';
        spec.parentNode = spec.parentNode || {};
        spec.parentNode.xKey = spec.parentNode.xKey || 'parentX';
        spec.parentNode.yKey = spec.parentNode.yKey || 'parentY';
        spec.parentNode.radiusKey = spec.parentNode.radiusKey || 'parentR';
        spec.criticalNode = spec.criticalNode || {};
        spec.criticalNode.flag = spec.criticalNode.flag || 'isPrimaryNode';
        Renderer.call( this, spec );
        injectCss( this.spec );
    }

    GraphNodeRenderer.prototype = Object.create( Renderer.prototype );

    /**
     * Implementation specific rendering function.
     * @memberof GraphNodeRenderer
     * @private
     *
     * @param {Object} data - The raw data for a tile to be rendered.
     *
     * @returns {{html: string, entries: Array}} The html to render and an array of all rendered data entries.
     */
    GraphNodeRenderer.prototype.render = function( data ) {

        var GRAPH_COORD_RANGE = 256,
            BORDER_WIDTH = 2,
            spec = this.spec,
            communities = RendererUtil.getAttributeValue( data, spec.rootKey ),
            scale = Math.pow( 2, this.parent.map.getZoom() ),
            range =  GRAPH_COORD_RANGE / scale,
            className,
            community,
            radius,
            diameter,
            parentRadius,
            parentDiameter,
            html = '',
            entries = [],
            i, x, y, px, py;

        for ( i=0; i<communities.length; i++ ) {

            community = communities[i];
            entries.push( community );

            // get node position, radius, and diameter
            x = ( community[ spec.node.xKey ] % range ) * scale;
            y = ( community[ spec.node.yKey ] % range ) * scale;
            radius = community[ spec.node.radiusKey ] * scale;
            diameter = radius*2;

            // don't draw node if radius < 1
            // or if it is an isolated community
            if ( radius < 1 || community.degree === 0 ) {
                continue;
            }

            if ( community[ spec.criticalNode.flag ] ) {
                className = 'community-node community-critical-node';
            } else {
                className = 'community-node';
            }

            // draw node
            html += '<div class="'+className+'" style="'
                  + 'height:'+diameter+'px;'
                  + 'width:'+diameter+'px;'
                  + 'border-radius:'+diameter+'px;'
                  + 'left:'+(x - radius - BORDER_WIDTH)+'px;'
                  + 'bottom:'+(y - radius - BORDER_WIDTH)+'px;'
                  + 'border-width:' + BORDER_WIDTH + 'px;'
                  + '"></div>';

            // only have the critical node draw the parent
            // assumes there is a critical node present in all communities
            if ( community[ spec.criticalNode.flag ] ) {

                // get parent node position, radius, and diameter
                px = ( community[ spec.parentNode.xKey ] % range ) * scale;
                py = ( community[ spec.parentNode.yKey ] % range ) * scale;
                parentRadius = community[ spec.parentNode.radiusKey ] * scale;
                parentDiameter = parentRadius * 2;

                // draw parent node
                html += '<div class="community-parent-node" style="'
                      + 'height:'+parentDiameter+'px;'
                      + 'width:'+parentDiameter+'px;'
                      + 'border-radius:'+parentDiameter+'px;'
                      + 'left:'+(px - parentRadius - BORDER_WIDTH)+'px;'
                      + 'bottom:'+(py - parentRadius - BORDER_WIDTH)+'px;'
                      + 'border-width:' + BORDER_WIDTH + 'px;'
                      + '"></div>';
            }
        }
        return {
            html: html,
            entries: entries
        };
    };

    module.exports = GraphNodeRenderer;
}());

},{"./Renderer":29,"./RendererUtil":30}],26:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Renderer = require('./Renderer'),
        RendererUtil = require('./RendererUtil'),
        MapUtil = require('../../map/MapUtil'),
        injectCss;

    injectCss = function( spec ) {
        var i;
        if ( spec.point.themes ) {
            for ( i = 0; i < spec.point.themes.length; i++ ) {
                spec.point.themes[i].injectTheme({
                    selector: ".point-annotation-fill",
                    parentSelector: ".point-annotation-aggregate"
                });
            }
        }
        if ( spec.aggregate.themes ) {
            for ( i = 0; i < spec.aggregate.themes.length; i++ ) {
                spec.aggregate.themes[i].injectTheme({
                    selector: ".point-annotation-border",
                    parentSelector: ".point-annotation-aggregate"
                });
            }
        }
    };

    /**
     * Instantiate a PointAggregateRenderer object.
     * @class PointAggregateRenderer
     * @augments Renderer
     * @classDesc A Renderer implementation that renders clusters of circular points for each
     * data value group.
     *
     * @param spec {Object} The specification object.
     * <pre>
     * {
     *     point: {
     *         xKey   {String|Function} - The attribute for the x coordinate.
     *         yKey   {String|Function} - The attribute for the y coordinate.
     *         themes {Array}  - The array of RenderThemes to be attached to this component.
     *     }
     *     aggregate: {
     *         themes {Array}  - The array of RenderThemes to be attached to this component.
     *     }
     * }
     * </pre>
     */
    function PointAggregateRenderer( spec ) {
        spec.rootKey = spec.rootKey || "tile.values";
        spec.point = spec.point || {};
        spec.point.xKey = spec.point.xKey || 'x';
        spec.point.yKey = spec.point.yKey || 'y';
		spec.point.magnitude.min = spec.point.magnitude.min || -1;
		spec.point.magnitude.max = spec.point.magnitude.max || -1;
        Renderer.call( this, spec );
        injectCss( this.spec );
    }

    PointAggregateRenderer.prototype = Object.create( Renderer.prototype );

    /**
     * Implementation specific rendering function.
     * @memberof PointAggregateRenderer
     * @private
     *
     * @param {Object} data - The raw data for a tile to be rendered.
     *
     * @returns {{html: string, entries: Array}} The html to render and an array of all rendered data entries.
     */
    PointAggregateRenderer.prototype.render = function( data ) {

        var spec = this.spec,
            map = this.parent.map,
            values = RendererUtil.getAttributeValue( data, spec.rootKey ),
            point = spec.point,
            entries = [],
            positionMap = {},
            positionKey,
            tilekey,
            tilePos,
            html = '',
            position,
            offset,
            value,
            i, j;

        // get tilekey
        tilekey = data.index.level + "," + data.index.xIndex + "," + data.index.yIndex;
        // get tile pos
        tilePos = MapUtil.getTopLeftViewportPixelForTile( map, tilekey );

        // for each bin
        for ( i=0; i<values.length; i++ ) {

            value = values[i].value;

            if ( value.length === 0 ) {
                continue;
            }
            entries.push( value );

            html += '<div class="point-annotation-aggregate">';

            for ( j=0; j<value.length; j++ ) {

                // get position in viewport space
                position = MapUtil.getViewportPixelFromCoord( map, value[j][point.xKey], value[j][point.yKey] );
                // get relative position from tile top left
                offset = {
                    x: position.x - tilePos.x,
                    y: position.y - tilePos.y
                };
                // prevent creating two annotations on the exact same pixel
                positionKey = Math.floor( offset.x ) + "," + Math.floor( offset.y );
                if ( !positionMap[ positionKey ] ) {
                    positionMap[ positionKey ] = true;
					// calculate proper colour based on magnitude, if present
					var percent = "";
					if ( spec.point.magnitude.min > 0 && spec.point.magnitude.max > 0 && value[j].data.magnitude ) {
						// get percent and round up to nearest 10
						var percent_value = ((value[j].data.magnitude - spec.point.magnitude.min)/(spec.point.magnitude.max - spec.point.magnitude.min))*100;
						percent = "-" + Math.ceil(percent_value/10)*10;
					}
                    html += '<div class="point-annotation point-annotation-fill' + percent + '" style="'
                          + 'left:' + offset.x + 'px;'
                          + 'top:' + offset.y + 'px;'
                          + 'border-width: 2px;"';
                    if (value[j].data.labels) {
                        html += ' title="' + value[j].data.labels + '"';
                    }
                    html += '></div>'
                          + '<div class="point-annotation point-annotation-border" style="'
                          + 'left:' + offset.x + 'px;'
                          + 'top:' + offset.y + 'px;'
                          + 'border-width: 2px"></div>';
                }
            }

            html += '</div>';
        }
        return {
            html: html,
            entries: entries
        };
    };

    module.exports = PointAggregateRenderer;
}());

},{"../../map/MapUtil":45,"./Renderer":29,"./RendererUtil":30}],27:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Renderer = require('./Renderer'),
        RendererUtil = require('./RendererUtil'),
        MapUtil = require('../../map/MapUtil'),
        injectCss;

    injectCss = function( spec ) {
        var i;
        if ( spec.point.themes ) {
            for (i = 0; i < spec.point.themes.length; i++) {
                spec.point.themes[i].injectTheme({
                    selector: ".point-annotation"
                });
            }
        }
    };

    /**
     * Instantiate a PointRenderer object.
     * @class PointRenderer
     * @augments Renderer
     * @classDesc A Renderer implementation that renders a circular point for each data
     * value.
     *
     * @param spec {Object} The specification object.
     * <pre>
     * {
     *     point: {
     *         xKey   {String|Function} - The attribute for the x coordinate.
     *         yKey   {String|Function} - The attribute for the y coordinate.
     *         themes {Array}  - The array of RenderThemes to be attached to this component.
     *     }
     * }
     * </pre>
     */
    function PointRenderer( spec ) {
        spec.rootKey = spec.rootKey || "tile.values";
        spec.point = spec.point || {};
        spec.point.xKey = spec.point.xKey || 'x';
        spec.point.yKey = spec.point.yKey || 'y';
        Renderer.call( this, spec );
        injectCss( this.spec );
    }

    PointRenderer.prototype = Object.create( Renderer.prototype );

    /**
     * Implementation specific rendering function.
     * @memberof PointRenderer
     * @private
     *
     * @param {Object} data - The raw data for a tile to be rendered.
     *
     * @returns {{html: string, entries: Array}} The html to render and an array of all rendered data entries.
     */
    PointRenderer.prototype.render = function( data ) {

        var spec = this.spec,
            map = this.parent.map,
            values = RendererUtil.getAttributeValue( data, spec.rootKey ),
            point = spec.point,
            entries = [],
            positionMap = {},
            positionKey,
            tilekey,
            tilePos,
            html = '',
            position,
            offset,
            value,
            i, j;

        // get tilekey
        tilekey = data.index.level + "," + data.index.xIndex + "," + data.index.yIndex;
        // get tile pos
        tilePos = MapUtil.getTopLeftViewportPixelForTile( map, tilekey );

        // for each bin
        for ( i=0; i<values.length; i++ ) {

            value = values[i].value;

            if ( value.length === 0 ) {
                continue;
            }

            for ( j=0; j<value.length; j++ ) {

                entries.push( value[j] );

                // get position in viewport space
                position = MapUtil.getViewportPixelFromCoord( map, value[j][point.xKey], value[j][point.yKey] );
                // get relative position from tile top left
                offset = {
                    x: position.x - tilePos.x,
                    y: position.y - tilePos.y
                };
                // prevent creating two annotations on the exact same pixel
                positionKey = Math.floor( offset.x ) + "," + Math.floor( offset.y );
                if ( !positionMap[ positionKey ] ) {
                    positionMap[ positionKey ] = true;
                    html += '<div class="point-annotation point-annotation-single" style="'
                          + 'left:' + offset.x + 'px;'
                          + 'top:' + offset.y + 'px;'
                          + 'border-width: 2px"';
                    if (value[j].data.labels) {
                        html += ' title="' + value[j].data.labels + '"';
                    }
                    html += '></div>';
                }
            }
        }
        return {
            html: html,
            entries: entries
        };
    };

    module.exports = PointRenderer;
}());

},{"../../map/MapUtil":45,"./Renderer":29,"./RendererUtil":30}],28:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var RendererUtil = require('./RendererUtil');

    function isColor( val ) {
        var split = val.replace(/\s+/g, '').split(/[\(\)]/);
        if ( split[0] === "rgb" || split[0] === "rgba" ) {
            return val;
        }
        return val[0] === "#" && ( val.length === 4 || val.length === 7 );
    }

    function injectSingleTheme( renderTheme, spec, options, percent ) {
        var theme = renderTheme.selector,
            selector = ( percent !== undefined ) ? options.selector + "-" + percent : options.selector,
            parentSelector = options.parentSelector,
            css = '';

        // set color
        if ( spec['background-color'] ) {
            css += theme + ' ' + selector + '{background-color:'+spec['background-color']+';}';
        }
        if ( spec.color ) {
            css += theme + ' ' + selector + '{color:' + spec.color + ';}';
        }
        if ( spec.opacity ) {
            css += theme + ' ' + selector + '{opacity:' + spec.opacity + ';}';
        }

        // set :hover color
        if ( parentSelector ) {
            if ( spec['background-color:hover'] ) {
                css += theme + ' '+parentSelector+':hover '+selector+' {background-color:'+spec['background-color:hover']+';}';
            }
            if ( spec['color:hover'] ) {
                css += theme + ' '+parentSelector+':hover '+selector+' {color:'+spec['color:hover']+';}';
            }
            if ( spec['opacity:hover'] ) {
                css += theme + ' '+parentSelector+':hover '+selector+' {opacity:'+spec['opacity:hover']+';}';
            }
        } else {
            if ( spec['background-color:hover'] ) {
                css += theme + ' '+selector+':hover {background-color:'+spec['background-color:hover']+';}';
            }
            if ( spec['color:hover'] ) {
                css += theme + ' '+selector+':hover {color:'+spec['color:hover']+';}';
            }
            if ( spec['opacity:hover'] ) {
                css += theme + ' '+selector+':hover {opacity:'+spec['opacity:hover']+';}';
            }
        }

        // set borders
        if ( spec['text-shadow'] ) {
            css += theme + ' ' + selector + '{' + getOutlineCss( 'text-shadow', spec['text-shadow'] ) + ';}';
        }

        if ( spec.border ) {
            css += theme + ' ' + selector + '{' + getOutlineCss( 'border', spec.border ) + ';}';
        }

        return css;
    }

    function getOutlineCss( type, value ) {


        if ( !value ) {
            return "";
        }

        if ( type === "text-shadow" ) {
            if ( isColor( value ) ) {
                return "text-shadow:"
                    + "-1px -1px 0 " + value + ","
                    + " 1px -1px 0 " + value + ","
                    + "-1px  1px 0 " + value + ","
                    + " 1px  1px 0 " + value + ","
                    + " 1px  0   0 " + value + ","
                    + "-1px  0   0 " + value + ","
                    + " 0    1px 0 " + value + ","
                    + " 0   -1px 0 " + value;
            }
            return "text-shadow:" + value + ";";
        }
        if ( type === "border" ) {
            if ( isColor( value ) ) {
                return "border: 1px solid " + value;
            }
            return "border:" + value + ";";
        }
        return "";
    }

    /**
     * Instantiate a RenderTheme object.
     * @class RenderTheme
     * @classdesc The RenderTheme class provides a mechanism to style separate components
     * generated from a Renderer object. The theme's CSS is injected into the DOM under the
     * supplied selectors. This allows switching between themes on client rendered tiles by
     * simply appending the respective selector to a parent DOM element.
     *
     * It is the Renderer implementations responsibility to ensure that the RenderTheme
     * object is utilized correctly, as different implementations may require unique
     * styling.
     *
     * An alternative to using RenderThemes would be either bypassing Renderers all together
     * and using the lower level html provider function accepted by client rendered layers, or
     * using the hook function to insert application or theme specific classes into the
     * generated html entries.
     *
     * @param theme {String} The theme identification string. Currently restricted to "dark" and "light".
     * @param spec  {Object} The specification object.
     * <pre>
     * {
     *     color                  {String} - The css color attribute for the component.
     *     color:hover            {String} - The css color attribute for the component, under hover.
     *     background-color       {String} - The css background-color attribute for the component.
     *     background-color:hover {String} - The css background-color attribute for the component, under hover.
     *     text-shadow            {String} - The css text-shadow attribute for the component.
     *     border                 {String} - The css border attribute for the component.
     * }
     * </pre>
     */
    function RenderTheme( theme, spec ) {
        spec = spec || {};
        this.selector = ( theme === 'light' ) ? ".light-theme" : ".dark-theme";
        this.spec = spec;
    }

    /**
     * Injects the themes CSS under the provided selector and parent selector. This should
     * only be called from within a Renderer class implementation, and it is the responsibility
     * of the Renderer implementation to ensure it is used correctly.
     * @private
     *
     * @param {Object} options - The options object containing the selector and parentSelector.
     */
    RenderTheme.prototype.injectTheme = function( options ) {
        var css,
            blendSpec,
            from,
            to,
            i;
        css = '<style class="render-theme" type="text/css">';
        if ( this.spec.from && this.spec.to ) {
            from = this.spec.from;
            to = this.spec.to;
            for ( i=10; i>=0; i-- ) {
                blendSpec = {};
                if ( from['background-color'] && to['background-color'] ) {
                     blendSpec['background-color'] = RendererUtil.hexBlend(
                         to['background-color'],
                         from['background-color'],
                         i/10 );
                }
                if ( from.color && to.color ) {
                     blendSpec.color = RendererUtil.hexBlend(
                         to.color,
                         from.color,
                         i/10 );
                }
                if ( from.opacity && to.opacity ) {
                    blendSpec.opacity = from.opacity + ((( to.opacity - from.opacity ) / 10)*i);
                }
                if ( from['background-color:hover'] && to['background-color:hover'] ) {
                     blendSpec['background-color:hover'] = RendererUtil.hexBlend(
                         to['background-color:hover'],
                         from['background-color:hover'],
                         i/10 );
                }
                if ( from['color:hover'] && to['color:hover'] ) {
                     blendSpec['color:hover'] = RendererUtil.hexBlend(
                         to['color:hover'],
                         from['color:hover'],
                         i/10 );
                }
                if ( from['opacity:hover'] && to['opacity:hover'] ) {
                    blendSpec['opacity:hover'] = from['opacity:hover'] + ((( to['opacity:hover'] - from['opacity:hover'] ) / 10)*i);
                }
                if ( from['text-shadow'] && to['text-shadow'] ) {
                     blendSpec['text-shadow'] = RendererUtil.hexBlend(
                         to['text-shadow'],
                         from['text-shadow'],
                         i/10 );
                }
                if ( from.border && to.border ) {
                     blendSpec.border = RendererUtil.hexBlend(
                         to.border,
                         from.border,
                         i/10 );
                }
                // inject percentage theme
                css += injectSingleTheme( this, blendSpec, options, i*10 );
                // add the theme for '100' without the '100' tag as well
                if ( i === 10 ) {
                    css += injectSingleTheme( this, blendSpec, options );
                }
            }
        } else {
            css += injectSingleTheme( this, this.spec, options );
        }

        css += '</style>';
        $( document.head ).prepend( css );
    };

    module.exports = RenderTheme;
}());

},{"./RendererUtil":30}],29:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Util = require('../../util/Util' ),
        RendererUtil = require('./RendererUtil');

    /**
     * Instantiate a Renderer object.
     * @class Renderer
     * @classdesc The Renderer class is designed to provide generic rendering capabilities
     * that can be reused across applications. This base class stores functionality that is
     * common across all renderer implementations, mainly the execution of the 'hook'
     * function to give access to the generated DOM elements to provide application
     * specific behavior.
     * <br>
     * Typically each unique component generated from a renderer will be under a separate
     * specification attribute. For example the text elements of the TextByFrequencyRenderer
     * is under 'text' and the frequency distribution elements are under 'frequency'.
     * <br>
     * Each of the separate components SHOULD accept *Key attributes to instruct it as to
     * where the relevant data should be found in the tile data object. Each of these
     * separate components SHOULD accept isolated RenderThemes (in the case that RenderThemes
     * are used).
     *
     * @param spec {Object} The specification object.
     * <pre>
     * {
     *     hook {Function} - The hook function that is executed on every rendered entry providing the following arguments:
     *         elem    {HTMLElement} - The html element for the entry.
     *         entry   {Object}      - The data entry.
     *         entries {Array}       - All entries for the tile.
     *         data    {Object}      - The raw data object for the tile.
     * }
     * </pre>
     */
    function Renderer( spec ) {
        this.spec = spec || {};
        this.uuid = Util.generateUuid();
        if ( spec.aggregator ) {
            this.aggregator = spec.aggregator;
        }
    }

    /**
     * Add a hook function to the renderer.
     * @memberof Renderer
     *
     * @param {Function} hook - the callback function.
     */
    Renderer.prototype.addHook = function( hook ) {
        if ( this.spec.hook ) {
            this.spec.hooks = [ this.spec.hook ];
            delete this.spec.hook;
        }
        this.spec.hooks = this.spec.hooks || [];
        if ( hook && typeof hook === "function" ) {
            this.spec.hooks.push( hook );
        }
    };

    /**
     * Remove a hook function from the renderer.
     * @memberof Renderer
     *
     * @param {Function} hook - the callback function.
     */
    Renderer.prototype.removeHook = function( hook ) {
        var index;
        if ( this.spec.hook && this.spec.hook === hook ) {
            delete this.spec.hook;
            this.spec.hooks = [ this.spec.hook ];
        }
        if ( this.spec.hooks ) {
            index = this.spec.hooks.indexOf( hook );
            if ( index !== -1 ) {
                this.spec.hooks.splice( index, 1 );
            }
        }
    };

    /**
     * When rendering a tile, the renderer will by default assume each immediate sibling
     * corresponds to a data entry. This function allows a renderer implementation to
     * provide a selector in situations where this is not the case. This is only relevant
     * if the hook callback is set.
     * @memberof Renderer
     * @private
     *
     * @returns {boolean|string} The DOM element selector for each rendered entry.
     */
    Renderer.prototype.getEntrySelector = function() {
        return false;
    };

    /**
     * Select all entries in the rendered layer that also share the same selected value. The
     * 'selectKey' of the 'select' option must be set.
     * @memberof Renderer
     *
     * @param {Object} selectedEntry - The selected data entry.
     */
    Renderer.prototype.select = function( selectedEntry ) {
        var $tiles = $( this.parent.olLayer.div ).find( '.olTileHtml,.olTileUnivariate' ),
            selectKey = this.spec.select.selectKey,
            selector = this.getEntrySelector(),
            uuid = this.uuid,
            selectValue,
            $entries;
        // if no key specified, exit
        if ( !selectKey ) {
            return;
        }
        // get the select value based on key
        this.selectValue = selectValue = RendererUtil.getAttributeValue( selectedEntry, selectKey );
        // if entry selector is set, use it to select entries
        $entries = selector ? $tiles.find( selector ) : $tiles.children();
        // for each entry, check if they have the matching value to the select
        $entries.each( function() {
            var $elem = $( this ),
                entry,
                value;
            // if this renderer did not create the elements, abort
            if ( uuid !== $elem.data( 'uuid' ) ) {
                return;
            }
            // get the entry and value
            entry = $elem.data( 'entry' );
            value = RendererUtil.getAttributeValue( entry, selectKey );
            if ( value === selectValue ) {
                 $elem.removeClass( 'de-emphasized' ).addClass( 'emphasized' );
            } else {
                $elem.removeClass( 'emphasized' ).addClass( 'de-emphasized' );
            }
        });
    };

    /**
     * Unselect all entries in the rendered layer.
     * @memberof Renderer
     */
    Renderer.prototype.unselect = function() {
        var $tiles = $( this.parent.olLayer.div ).find( '.olTileHtml,.olTileUnivariate' ),
            selector = this.getEntrySelector(),
            $entries;
        // if entry selector is set, use it to select entries
        $entries = selector ? $tiles.find( selector ) : $tiles.children();
        // for each entry, remove relevant classes
        $entries.each( function() {
            $( this ).removeClass( 'de-emphasized' ).removeClass( 'emphasized' );
        });
        // clear the select value
        this.selectValue = null;
    };

    /**
     * The central rendering function. This function is called for every tile containing data.
     * Returns an object containing the tiles html, along with an array of each data entry. The
     * implementation of this function is unique to each renderer.
     * @memberof Renderer
     * @private
     *
     * @returns {{html: string, entries: Array}} The html to render and an array of all rendered data entries.
     */
    Renderer.prototype.render = function() {
        return {
            html: "",
            entries: []
        };
    };

    /**
     * Attaches the renderer to its respective layer. This method should not be called
     * manually.
     * @memberof Renderer
     * @private
     *
     * @param {Layer} layer - The layer to attach to the renderer.
     */
    Renderer.prototype.attach = function( layer ) {
        if ( this.parent && this.parent !== layer ) {
            console.log( "This renderer has already been attached " +
                         "to a different layer, please use another instance." );
            return;
        }
        this.parent = layer;
        if ( this.aggregator ) {
            this.aggregator.attach( layer );
        }
    };

    /**
     * This iterates over every data entry's DOM element and if there is a current selected
     * value in the renderer, it will inject the correct emphasize and de-emphasize flags.
     * This method should not be called manually.
     * @memberof Renderer
     * @private
     *
     * @param {HTMLCollection} elements - A collection of html elements.
     * @param {Array} entries - The array of all data entries.
     */
    Renderer.prototype.injectEntries = function( elements, entries ) {
        var selector = this.getEntrySelector(),
            $elements = $( elements ),
            selectValue = this.selectValue,
            select = this.spec.select,
            uuid = this.uuid,
            selectKey;
        if ( !select || !select.selectKey ) {
            return;
        }
        // get select key
        selectKey = select.selectKey;
        // if entry selector is set, use it to select entries
        if ( selector ) {
            $elements = $elements.find( selector );
        }
        // call entry function on each entry
        $elements.each( function( index, elem ) {
            var $elem = $( elem ),
                entry = entries[index],
                value = RendererUtil.getAttributeValue( entry, selectKey );
            // store the entry data in the entry element
            $elem.data( 'entry', entry );
            // store the renderer uuid
            $elem.data( 'uuid', uuid );
            if ( selectValue && selectKey ) {
                if ( value === selectValue ) {
                    $elem.removeClass( 'de-emphasized' ).addClass( 'emphasized' );
                } else {
                    $elem.removeClass( 'emphasized' ).addClass( 'de-emphasized' );
                }
            }
        });
    };

    /**
     * The hook callback executor function. If a hook function is provided to the renderer, this
     * will execute it passing the respective element and data entry along with all entries and
     * the raw tile data. This is called by the HtmlTile object, should not be called manually.
     * @memberof Renderer
     * @private
     *
     * @param {HTMLCollection} elements - A collection of html elements.
     * @param {Array} entries - The array of all data entries.
     * @param {Object} data - The raw tile data object.
     */
    Renderer.prototype.executeHooks = function( elements, entries, data ) {

        function execHook( index, elem ) {
            hook( elem, entries[index], entries, data );
        }

        var hooks = this.spec.hook ? [ this.spec.hook ] : this.spec.hooks,
            selector = this.getEntrySelector(),
            hook,
            $elements,
            i;
        if ( hooks ) {
            for ( i=0; i<hooks.length; i++ ) {
                hook = hooks[i];
                if ( typeof hook === "function" ) {
                    // get the entries
                    $elements = $( elements );
                    // if entry selector is set, use it to select entries
                    if ( selector ) {
                        $elements = $elements.find( selector );
                    }
                    // call entry function on each entry
                    $elements.each( execHook );
                }
            }
        }
    };

    module.exports = Renderer;
}());

},{"../../util/Util":60,"./RendererUtil":30}],30:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * @namespace RenderUtil
 * @classdesc A utility namespace containing renderer related functionality.
 */
( function() {

    "use strict";

    function log10(val) {
        return Math.log(val) / Math.LN10;
    }

    module.exports = {

        /**
         * Returns a y offset required to vertical centre a number of entries based
         * on spacing and offset
         * @memberof RenderUtil
         *
         * @param {integer} numEntries - The number of entries to render.
         * @param {integer} spacing - The spacing between entries in pixels.
         * @param {integer} offset - The offset from the top of the tile to centre on in pixels.
         *
         * @returns {integer} The y pixel offset.
         */
        getYOffset: function( numEntries, spacing, offset ) {
            return offset - ( ( ( numEntries - 1) / 2 ) ) * spacing;
        },

        /**
         * Transforms a value into the range [0:1] based on a min and max value
         * according to a linear or log transform.
         *
         * @param {number} value - The value to transform.
         * @param {number} min -The value to transform.
         * @param {number} max - The value to transform.
         * @param {String} type - The type of transformation ('log' or 'linear').
         *
         * @returns {number} The value between 0 and 1.
         */
        transformValue: function( value, min, max, type ) {
            var clamped = Math.max( Math.min( value, max ), min );
            if ( type === "log" ) {
                var logMin = log10( min || 1 );
        		var logMax = log10( max || 1 );
        		var oneOverLogRange = 1 / ( (logMax - logMin) || 1 );
                return ( log10( clamped || 1 ) - logMin ) * oneOverLogRange;
            } else {
                var range = max - min;
                return ( clamped - min ) / range;
            }
        },

        /**
         * Returns a font size based on the percentage of tweets relative to the total count
         * @memberof RenderUtil
         *
         * @param {integer} count - The local count.
         * @param {integer} totalCount - The global count.
         * @param {Object} options - The options object to set min and max font size and type (optional).
         *
         * @returns {integer} The interpolated font size.
         */
        getFontSize: function( value, min, max, options ) {
            options = options || {};
            var MAX_FONT_SIZE = options.maxFontSize || 22,
                MIN_FONT_SIZE = options.minFontSize || 12,
                transformed = this.transformValue( value, min, max, options.type );
            return MIN_FONT_SIZE + transformed*( MAX_FONT_SIZE - MIN_FONT_SIZE );
        },

        /**
         * Traverses an object to return a nested attribute
         * @memberof RenderUtil
         *
         * @param {Object} obj - The object to traverse.
         * @param {String|Function} attribPath - Period delimited attribute path or a function that returns one.
         *
         * @returns {*} The nested value within the object.
         */
        getAttributeValue: function( obj, attribPath ) {
            var attribs,
                arraySplit,
                attrib,
                i;
            if ( typeof attribPath === "function" ) {
                attribPath = attribPath( obj );
            }
            attribs = attribPath.split('.');
            attrib = obj;
            for (i=0; i<attribs.length; i++) {
                arraySplit = attribs[i].replace(/ /g, '' ).split(/[\[\]]/);
                if ( arraySplit.length === 1 ) {
                    // normal attribute
                    if ( attribs[i].length > 0 ) {
                        attrib = attrib[ attribs[i] ];
                    }
                } else if ( arraySplit.length === 3 ) {
                    // array index expressed, use it
                    attrib = attrib[ arraySplit[0] ][ arraySplit[1] ];
                } else {
                    // unrecognized input, default to assumption of
                    // normal attribute
                    attrib = attrib[ arraySplit[0] ];
                }
            }
            return attrib;
        },

        /**
         * Converts a hex code color to its RGB counter part.
         * @memberof RenderUtil
         *
         * @param {String} hex - The hex code color.
         *
         * @returns {Object} The RGB color values.
         */
        hexToRgb: function(hex) {
            var bigint;
            // remove #
            hex = hex.replace(/#/, '');
            // if only 3 hex values are provided, expand into 6 digit hex code
            if ( hex.length === 3 ) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            bigint = parseInt(hex, 16);
            return {
                r: (bigint >> 16) & 255,
                g: (bigint >> 8) & 255,
                b: bigint & 255
            };
        },

        /**
         * Converts an RGB color to its hex code counter part.
         * @memberof RenderUtil
         *
         * @param {Object} rgb - The RGB color.
         *
         * @returns {String} The hex code color value.
         */
        rgbToHex: function( rgb ) {
            var r = rgb.r,
                g = rgb.g,
                b = rgb.b;
            function componentToHex(c) {
                var hex = c.toString(16);
                return (hex.length === 1) ? "0" + hex : hex;
            }
            return "#" + componentToHex( Math.floor(r)) +
                         componentToHex( Math.floor(g)) +
                         componentToHex( Math.floor(b));
        },

        /**
         * Increases the brightness of a hex code color by a percentage factor
         * @memberof RenderUtil
         *
         * @param {String} hex - The hex code color.
         * @param {float} factor - The percentage factor of increase.
         *
         * @returns {String} The adjusted hex code color value.
         */
        hexBrightness: function( hex, factor ) {
            var rgb = this.hexToRgb( hex );
            return this.rgbToHex( { r: Math.min( Math.max( 0, rgb.r * factor ), 255 ),
                                    g: Math.min( Math.max( 0, rgb.g * factor ), 255 ),
                                    b: Math.min( Math.max( 0, rgb.b * factor ), 255 ) } );
        },

        /**
         * Converts a hex code color to greyscale using a luminosity based model
         * @memberof RenderUtil
         *
         * @param {String} hex - The  hex code color.
         *
         * @returns {String} The greyscale hex code color value.
         */
        hexGreyscale: function( hex ) {
            var rgb = this.hexToRgb( hex ),
                avg = ( rgb.r * 0.21 + rgb.g * 0.72 + rgb.b * 0.07 );
            return this.rgbToHex({
                r: avg,
                g: avg,
                b: avg
            });
        },

        /**
         * Blends two hex code colors together, defaults to 50/50 blend
         * @memberof RenderUtil
         *
         * @param {String} hexA - The hex code color A.
         * @param {String} hexB - The hex code color B.
         * @param {number} aIntoBPercentage - The percentage to blend hexA into hexB (optional).
         *
         * @returns {String} The blended hex code color value.
         */
        hexBlend: function( hexA, hexB, aIntoBPercentage ) {
            var aPerc = ( aIntoBPercentage !== undefined ) ? Math.min( 1, aIntoBPercentage ) : 0.5,
                bPerc = 1 - aPerc,
                rgb1 = this.hexToRgb( hexA ),
                rgb2 = this.hexToRgb( hexB );
            return this.rgbToHex({
                r : ( rgb1.r*aPerc + rgb2.r*bPerc ),
                g : ( rgb1.g*aPerc + rgb2.g*bPerc ),
                b : ( rgb1.b*aPerc + rgb2.b*bPerc )
            });
        }

    };

}());

},{}],31:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Renderer = require('./Renderer'),
        RendererUtil = require('./RendererUtil'),
        MAX_WORDS_DISPLAYED = 8,
        getYOffset,
        getHighestCount;

    /**
     * Utility function for positioning the labels
     */
    getYOffset = function( index, numEntries, spacing ) {
        return 118 - ( (( numEntries - 1) / 2 ) - index ) * spacing;
    };

    /**
     * Utility function to get the highest count for a topic in the tile
     */
    getHighestCount = function( values, countKey ) {
        // get the highest single count
        var highestCount = 0,
            counts = RendererUtil.getAttributeValue( values, countKey ),
            j;
        for ( j=0; j<counts.length; j++ ) {
            // get highest count
            highestCount = Math.max( highestCount, counts[j] );
        }
        return highestCount;
    };

    /**
     * Instantiate a TextByFrequencyRenderer object.
     * @class TextByFrequencyRenderer
     * @augments Renderer
     * @classDesc A Renderer implementation that renders a histogram of the frequency of
     * a particular topic over time, with the topic text next to it.
     *
     * @param spec {Object} The specification object.
     * <pre>
     * {
     *     text: {
     *         textKey  {String|Function} - The attribute for the text in the data entry.
     *         themes   {Array}  - The array of RenderThemes to be attached to this component.
     *     },
     *     frequency: {
     *         countKey {String|Function} - The attribute for the count in the data entry.
     *         themes   {Array}  - The array of RenderThemes to be attached to this component.
     *         invertOrder {Boolean} - The boolean to determine order of chart values.  Defaults to false if not present
     *     }
     * }
     * </pre>
     */
    function TextByFrequencyRenderer( spec ) {
        spec.rootKey = spec.rootKey || "tile.meta.aggregated";
        spec.frequency.invertOrder = spec.frequency.invertOrder || false;
        Renderer.call( this, spec );
        this.injectCss( this.spec );
    }

    TextByFrequencyRenderer.prototype = Object.create( Renderer.prototype );

    TextByFrequencyRenderer.prototype.getEntrySelector = function() {
        return ".text-by-frequency-label";
    };

    TextByFrequencyRenderer.prototype.injectCss = function( spec ) {
        var i;
        if ( spec.text.themes ) {
          for (i = 0; i < spec.text.themes.length; i++) {
              spec.text.themes[i].injectTheme({
                  selector: ".text-by-frequency-label",
                  parentSelector: ".text-by-frequency-entry"
              });
          }
        }
        if ( spec.frequency.themes ) {
          for (i = 0; i < spec.frequency.themes.length; i++) {
              spec.frequency.themes[i].injectTheme({
                  selector: ".text-by-frequency-bar",
                  parentSelector: ".text-by-frequency-entry"
              });
          }
        }
    };

    TextByFrequencyRenderer.prototype.getBarStyleClass = function (value, countIndex, relativePercent) {
        // class percent in increments of 10
        var percentLabel = Math.round( relativePercent / 10 ) * 10;
        return 'text-by-frequency-bar text-by-frequency-bar-' + percentLabel;
    };

    TextByFrequencyRenderer.prototype.getTextStyleClass = function () {
        return 'text-by-frequency-label';
    };

    /**
     * Implementation specific rendering function.
     * @memberof TextByFrequencyRenderer
     * @private
     *
     * @param {Object} data - The raw data for a tile to be rendered.
     *
     * @returns {{html: string, entries: Array}} The html to render and an array of all rendered data entries.
     */
    TextByFrequencyRenderer.prototype.render = function( data ) {
        var self = this,
            minFontSize = 14,
            maxFontSize = 24,
            spacing = 20,
            textKey = this.spec.text.textKey,
            frequency = this.spec.frequency,
            countKey = frequency.countKey,
            invertOrder = frequency.invertOrder,
            values = RendererUtil.getAttributeValue( data, this.spec.rootKey ),
            numEntries = Math.min( values.length, MAX_WORDS_DISPLAYED ),
            levelMinMax = this.parent.getLevelMinMax(),
            barStyleClass,
            $html = $("<div></div>"),
            entries = [],
            min = 0,
            max = 0,
            text,
            highestCount,
            counts,
            relativePercent,
            chartSize,
            visibility,
            index,
            height,
            i = 0,
            j = 0;

        var $label = $('<div class="count-summary"></div>');
        $html = $html.append( $label );

        // if zoom level max is in meta, use it, otherwise calc it from tile
        if ( levelMinMax.maximum ) {
            max = getHighestCount( levelMinMax.maximum, countKey );
        } else {
            values.forEach( function( value ) {
                max = Math.max( max, RendererUtil.getAttributeValue( value, countKey ) );
            });
        }

	      values = values.slice( 0, numEntries );
        values.forEach ( function( value ) {
            entries.push( value );
            counts = RendererUtil.getAttributeValue( value, countKey );
            text = RendererUtil.getAttributeValue( value, textKey );
            chartSize = counts.length;
            // highest count for the topic
            highestCount = getHighestCount( value, countKey );
            // scale the height based on level min / max
            height = RendererUtil.getFontSize(
                highestCount,
                min,
                max,
                {
                    minFontSize: minFontSize,
                    maxFontSize: maxFontSize,
                    type: "log"
                });

			      // create container 'entry' for chart and hashtag
            var html_string = '';
                html_string += '<div class="text-by-frequency-entry" '
                      + 'style="'
                      // ensure constant spacing independent of height
                      + 'top:' + ( getYOffset( i, numEntries, spacing ) + ( maxFontSize - height ) ) + 'px;'
                      + 'height:' + height + 'px"></div>';
			      var $entry = $(html_string);

            $entry.mouseover(function() {
                $label.show(); // show label
                $label.text( value.count );
            });
            $entry.mouseout(function() {
                $label.hide(); // hide label
            });

            // create chart
			      var $chart = $('<div class="text-by-frequency-left"></div>');

            counts.forEach ( function( count, countIndex ) {
                // if invertOrder is true, invert the order of iteration
                index = ( invertOrder ) ? chartSize - j - 1 : j;
                // get the percent relative to the highest count in the tile
                relativePercent = ( count / highestCount ) * 100;
                // if percent === 0, hide bar
                visibility = ( relativePercent > 0 ) ? '' : 'hidden';
                // Get the style class of the bar
                barStyleClass = self.getBarStyleClass(value, countIndex, relativePercent);
                // set minimum bar length
                relativePercent = Math.max( relativePercent, 20 );
                // create bar
                var bar_string = '';
                        bar_string += '<div '
                            + 'class="' + barStyleClass + '" '
                            + 'style="'
                            + 'visibility:'+visibility+';'
                            + 'height:'+relativePercent+'%;'
                            + 'width:'+ Math.floor( (105+chartSize)/chartSize ) +'px;'
                            + 'top:'+(100-relativePercent)+'%;"></div>';
                var $chartBar = $(bar_string);
                $chart.append($chartBar);
                j += 1;
            });

			      $entry.append( $chart );
            // create tag label
			      var $labelTag = $('<div class="text-by-frequency-right"></div>');
			      var label_string = '';
                label_string += '<div class="' + self.getTextStyleClass(value) + '" style="' +
                    'font-size:'+height+'px;' +
                    'line-height:'+height+'px;' +
                    'height:'+height+'px">'+text+'</div>';
            var $labelText = $(label_string);
            $labelTag.append( $labelText );
            $entry.append( $labelTag );

            $html.append($entry);
            i += 1;
        });

        return {
            html: $html,
            entries: entries
        };
    };

    module.exports = TextByFrequencyRenderer;
}());

},{"./Renderer":29,"./RendererUtil":30}],32:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * A word cloud renderer. Uses a set of words and their counts to generate a word cloud.
 */
( function() {

    "use strict";

    var Renderer = require('./Renderer'),
		createTopicWordsArrays,
        injectCss;

    injectCss = function( spec ) {
        var i, j;
        if ( spec.text.themes ) {
			// for each pair of light and dark themes, inject theme
            for ( i = 0; i < spec.text.themes.length; i++ ) {
				var themePair = spec.text.themes[ i ];
				for ( j = 0; j < themePair.length; j++ ) {
					themePair[j].injectTheme({
						selector: '.text-topic-' + i + '-label'
					});
				}
			}
        }
    };

	/**
     * Create an array of text words for each topic based on the entry's topic number
     */
	createTopicWordsArrays = function( entries, numTopics ) {
		var topicWordsArray = [];
		
		for ( var i = 0; i < numTopics; i++ ) {
			topicWordsArray[i] = [];
		}

		entries.forEach( function( entry ) {
			topicWordsArray[ entry.topicNumber ].push( entry.topic );
		});	
		
		return topicWordsArray;
	};

    /**
     * Instantiate a TextByTopicRenderer object.
     * @class TextByTopicRenderer
     * @augments Renderer
     * @classDesc A Renderer implementation that renders a word cloud.
     *
     * @param spec {Object} The specification object.
     * <pre>
     *     text: {
     *         textKey   {String|Function} - The attribute for the text in the data entry.
     *         themes    {Array}  - The array of RenderThemes to be attached to this component.
	 *         numTopics {integer} - number of topics to bin the text words under
     *     }
     * }
     * </pre>
     */
    function TextByTopicRenderer( spec ) {
        spec.rootKey = spec.rootKey || "tile.meta.raw";
        spec.text = spec.text || {};
        Renderer.call( this, spec );
        injectCss( this.spec );
    }

    TextByTopicRenderer.prototype = Object.create( Renderer.prototype );

	TextByTopicRenderer.prototype.getEntrySelector = function() {
		return ".text-by-topic-label";
	};

    /**
     * Implementation specific rendering function.
     * @memberof TextByTopicRenderer
     *
     * @param {Object} data - The raw data for a tile to be rendered.
     *
     * @returns {{html: string, entries: Array}} The html to render and an array of all rendered data entries.
     */
    TextByTopicRenderer.prototype.render = function( data ) {

        var text = this.spec.text,
            textKey = text.textKey,
			numTopics = text.numTopics ? text.numTopics : 3,
            entries = data.tile.meta.raw[0],
			$html = $('<div class="text-by-topic-box"></div>'),
			topicWords = [],
			index = 1,
            i, j;
	
		// need to get the first non-null array in the raw data
		while ( entries === null && index < data.tile.meta.raw.length ) {
			entries = data.tile.meta.raw[index];
			index++;
		}
        topicWords = createTopicWordsArrays( entries, numTopics, textKey );

		for ( i = 0; i < numTopics; i++ ) {
			var words = topicWords[i],
				wordsString = '';
				
			for ( j = 0; j < words.length; j++ ) {
				wordsString += words[j] + ' ';
			}
			var $words_html = $('<div class="text-topic-' + i + '-label text-topic-label">' + wordsString + '</div>');

			// add it to the group
			$html = $html.append( $words_html );
        }

        return {
            html: $html,
            entries: entries
        };
    };

    module.exports = TextByTopicRenderer;
}());

},{"./Renderer":29}],33:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Renderer = require('./Renderer'),
        RendererUtil = require('./RendererUtil'),
        MAX_WORDS_DISPLAYED = 5,
        MAX_BAR_WIDTH = 110,
        injectCss;

    injectCss = function( spec ) {
        var i, j;
        if ( spec.text.themes ) {
            for ( i=0; i<spec.text.themes.length; i++ ) {
                spec.text.themes[i].injectTheme({
                    selector: ".text-score-label",
                    parentSelector: ".text-score-entry"
                });
                spec.text.themes[i].injectTheme({
                    selector: ".text-score-entry-count",
                    parentSelector: ".text-score-entry"
                });
            }
            for ( i=0; i<spec.weights.length; i++ ) {
                for ( j=0; j<spec.weights[i].themes.length; j++ ) {
                    spec.weights[i].themes[j].injectTheme( {
                        selector: ".text-score-weight-" + i,
                        parentSelector: ".text-score-entry"
                    });
                }
            }
        }
    };

    /**
     * Instantiate a TextScoreRenderer object.
     * @class TextScoreRenderer
     * @augments Renderer
     * @classDesc A Renderer implementation that renders a text label scaled by its
     * frequency.
     *
     * @param spec {Object} The specification object.
     * <pre>
     * {
     *     text: {
     *         textKey  {String|Function} - The attribute for the text in the data entry.
     *         countKey {String|Function} - The attribute for the count in the data entry.
     *         themes   {Array}  - The array of RenderThemes to be attached to this component.
     *     },
     *     weights: [{
     *         weightKey {Array|Function} - The attributes for the weights in the data entry
     *         themes    {Array}  - The array of RenderThemes to be attached to this component.
     *     }],
     *     threshold: {number} - The count threshold at which to de-saturate the colors.
     * }
     * </pre>
     */
    function TextScoreWeightedRenderer( spec ) {
        spec.rootKey = spec.rootKey || "tile.meta.aggregated";
        Renderer.call( this, spec );
        injectCss( this.spec );
    }

    TextScoreWeightedRenderer.prototype = Object.create( Renderer.prototype );

    /**
     * Returns the entry selector unique to this Renderer Implementation.
     * @memberof TextScoreRenderer
     * @private
     *
     * @returns {String} The entry DOM selector.
     */
    TextScoreWeightedRenderer.prototype.getEntrySelector = function() {
        return ".text-score-entry";
    };

    /**
     * Implementation specific rendering function.
     * @memberof TextScoreRenderer
     * @private
     *
     * @param {Object} data - The raw data for a tile to be rendered.
     *
     * @returns {{html: string, entries: Array}} The html to render and an array of all rendered data entries.
     */
    TextScoreWeightedRenderer.prototype.render = function( data ) {

        var ENTRY_HEIGHT = 30,
            BAR_HEIGHT = 6,
            BOTTOM_OFFSET = ENTRY_HEIGHT - BAR_HEIGHT - 2,
            spec = this.spec,
            weights = spec.weights,
            threshold = spec.threshold || 5,
            textKey = spec.text.textKey,
            countKey = spec.text.countKey,
            values = RendererUtil.getAttributeValue( data, spec.rootKey ),
            levelMinMax = this.parent.getLevelMinMax(),
            numEntries = Math.min( values.length, MAX_WORDS_DISPLAYED ),
            minFontSize = 13,
            maxFontSize = 18,
            min = Number.MAX_VALUE,
            max = 0,
            entries = [],
            html = '',
            desaturate,
            percentLabel,
            middleWeightIndex,
            middleWeight,
            weightCounts,
            weightPercent,
            weight,
            barWidth,
            yOffset,
            value,
            text,
            count,
            fontSize,
            i,
            j;

        yOffset = RendererUtil.getYOffset( numEntries, ENTRY_HEIGHT+BAR_HEIGHT, 122 );

        // if the min for the zoom level is specified in the meta, use it
        if ( levelMinMax.minimum ) {
            min = RendererUtil.getAttributeValue( levelMinMax.minimum, countKey );
        } else {
            values.forEach( function( value ) {
                min = Math.min( min, RendererUtil.getAttributeValue( value, countKey ) );
            });
        }

        // if the max for the zoom level is specified in the meta, use it
        if ( levelMinMax.maximum ) {
            max = RendererUtil.getAttributeValue( levelMinMax.maximum, countKey );
        } else {
            values.forEach( function( value ) {
                max = Math.max( max, RendererUtil.getAttributeValue( value, countKey ) );
            });
        }

        for (i=0; i<numEntries; i++) {
            value = values[i];
            entries.push( value );
            text = RendererUtil.getAttributeValue( value, textKey );
            count = RendererUtil.getAttributeValue( value, countKey );
            desaturate = ( count < threshold ) ? "de-saturate" : "";
            fontSize = RendererUtil.getFontSize(
                count,
                min,
                max,
                {
                    minFontSize: minFontSize,
                    maxFontSize: maxFontSize,
                    type: "log"
            });
            weightPercent = (fontSize-minFontSize) / (maxFontSize-minFontSize);

            // parent
            html += '<div class="text-score-entry-parent" style="top:' + yOffset + 'px;">';

            // create entry
            html += '<div class="text-score-entry" style="height:'+ENTRY_HEIGHT+'px;">';

            html += '<div class="text-score-entry-count">'+ count +'</div>';

            // create label
            percentLabel = Math.round( (weightPercent*100) / 10 ) * 10;
            html += '<div class="text-score-label text-score-label-'
                + percentLabel+' '+desaturate+'" style="'
                + 'font-size:'+ fontSize +'px;'
                + 'line-height:'+ fontSize +'px;'
                + 'bottom:'+-(BOTTOM_OFFSET-fontSize)+'px;">'+text+'</div>';

            if ( count > 0 ) {
                // create weights
                weightCounts = [];
                for ( j=0; j<weights.length; j++ ) {
                    weight = RendererUtil.getAttributeValue( value, weights[j].weightKey );
                    weightCounts.push( weight );
                }
                // get the index of the middle weight
                middleWeightIndex = Math.floor( (weights.length-1) / 2 );
                // sum the amount of weight to centre the bar on the middle weight
                if ( weights.length % 2 === 0 ) {
                    middleWeight = weightCounts[ middleWeightIndex ];
                } else {
                    middleWeight = weightCounts[ middleWeightIndex ] / 2;
                }
                for ( j=middleWeightIndex-1; j>=0; j-- ) {
                    middleWeight += weightCounts[j];
                }
                barWidth = MAX_BAR_WIDTH;
                // create bar container
                html += '<div class="text-score-weight-bar" style="'
                    + 'width:' + barWidth + 'px;'
                    + 'height:' + BAR_HEIGHT + 'px;'
                    + 'left:' + (-barWidth*(middleWeight/count)) + 'px;">';
                for ( j=0; j<weights.length; j++ ) {
                    // create bar
                    html += '<div class="text-score-weight text-score-weight-'
                        + j +' '+desaturate+'" style="'
                        + 'width:'+((weightCounts[j]/count)*100)+'%;"></div>';
                }
                html += '</div>';
            }

            html += '</div>';
            html += '</div>';
            html += '<div class="clear"></div>';
        }

        return {
            html: html,
            entries: entries
        };
    };

    module.exports = TextScoreWeightedRenderer;
}());

},{"./Renderer":29,"./RendererUtil":30}],34:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * A word cloud renderer. Uses a set of words and their counts to generate a word cloud.
 */
( function() {

    "use strict";

    var Renderer = require('./Renderer'),
        RendererUtil = require('./RendererUtil'),
        MAX_WORDS_DISPLAYED = 10,
        HORIZONTAL_OFFSET = 10,
        VERTICAL_OFFSET = 24,
        SIZE_FUNCTION = 'log',
        MIN_FONT_SIZE = 13,
        MAX_FONT_SIZE = 28,
        spiralPosition,
        intersectTest,
        overlapTest,
        intersectWord,
        getWordDimensions,
        createWordCloud;

    /**
     * Given an initial position, return a new position, incrementally spiralled
     * outwards.
     */
    spiralPosition = function( pos ) {
        var pi2 = 2 * Math.PI,
            circ = pi2 * pos.radius,
            inc = ( pos.arcLength > circ/10) ? circ/10 : pos.arcLength,
            da = inc / pos.radius,
            nt = (pos.t+da);
        if (nt > pi2) {
            nt = nt % pi2;
            pos.radius = pos.radius + pos.radiusInc;
        }
        pos.t = nt;
        pos.x = pos.radius * Math.cos(nt);
        pos.y = pos.radius * Math.sin(nt);
        return pos;
    };

    /**
     *  Returns true if bounding box a intersects bounding box b
     */
    intersectTest = function( a, b ) {
        return (Math.abs(a.x - b.x) * 2 < (a.width + b.width)) &&
               (Math.abs(a.y - b.y) * 2 < (a.height + b.height));
    };

    /**
     *  Returns true if bounding box a is not fully contained inside bounding box b
     */
    overlapTest = function( a, b ) {
        return ( a.x + a.width/2 > b.x+b.width/2 ||
                 a.x - a.width/2 < b.x-b.width/2 ||
                 a.y + a.height/2 > b.y+b.height/2 ||
                 a.y - a.height/2 < b.y-b.height/2 );
    };

    /**
     * Check if a word intersects another word, or is not fully contained in the
     * tile bounding box
     */
    intersectWord = function( position, dimensions, cloud, bb ) {
        var box = {
                x: position.x,
                y: position.y,
                height: dimensions.height,
                width: dimensions.width
            },
            i;
        for ( i=0; i<cloud.length; i++ ) {
            if ( intersectTest( box, cloud[i] ) ) {
                return true;
            }
        }
        // make sure it doesn't intersect the border;
        if ( overlapTest( box, bb ) ) {
            // if it hits a border, increment collision count
            // and extend arc length
            position.collisions++;
            position.arcLength = position.radius;
            return true;
        }
        return false;
    };

    /**
     * Returns the pixel dimensions of the label
     */
    getWordDimensions = function( str, fontSize ) {
        var $temp,
            dimension = {};
        $temp = $('<div class="word-cloud-label-temp" style="font-size:'+fontSize+'px;">'+str+'</div>');
        $('body').append( $temp );
        dimension.width = $temp.outerWidth();
        dimension.height = $temp.outerHeight();
        $temp.remove();
        return dimension;
    };

    /**
     * Returns the word cloud words containing font size and x and y coordinates
     */
    createWordCloud = function( wordCounts, min, max, sizeFunction, minFontSize, maxFontSize ) {
        var boundingBox = {
                width: 256 - HORIZONTAL_OFFSET * 2,
                height: 256 - VERTICAL_OFFSET * 2,
                x: 0,
                y: 0
            },
            cloud = [],
            percent,
            i, word, count, dim,
            fontSize, pos;
        // sort words by frequency
        wordCounts.sort( function( a, b ) {
            return b.count - a.count;
        });
        // assemble word cloud
        for ( i=0; i<wordCounts.length; i++ ) {
            word = wordCounts[i].word;
            count = wordCounts[i].count;
            // get font size based on font size function
            fontSize = RendererUtil.getFontSize( count, min, max, {
                maxFontSize: maxFontSize,
                minFontSize: minFontSize,
                type: sizeFunction
            });
            // frequency percent
            percent = ((fontSize-minFontSize) / (maxFontSize-minFontSize))*100;
            // get dimensions of word
            dim = getWordDimensions( word, fontSize );
            // starting spiral position
            pos = {
                radius : 1,
                radiusInc : 5,
                arcLength : 5,
                x : 0,
                y : 0,
                t : 0,
                collisions : 0
            };

            var numWords = wordCounts.length;
            while( pos.collisions < numWords ) {
                // increment position in a spiral
                pos = spiralPosition( pos );
                // test for intersection
                if ( !intersectWord( pos, dim, cloud, boundingBox ) ) {
                    cloud.push({
                        word: word,
                        entry: wordCounts[i].entry,
                        fontSize: fontSize,
                        percentLabel: Math.round( percent / 10 ) * 10, // round to nearest 10
                        x:pos.x,
                        y:pos.y,
                        width: dim.width,
                        height: dim.height
                    });
                    break;
                }
            }
        }
        return cloud;
    };

    /**
     * Instantiate a WordCloudRenderer object.
     * @class WordCloudRenderer
     * @augments Renderer
     * @classDesc A Renderer implementation that renders a word cloud.
     *
     * @param spec {Object} The specification object.
     * <pre>
     *     text: {
     *         textKey  {String|Function} - The attribute for the text in the data entry.
     *         countKey {String|Function} - The attribute for the count in the data entry.
     *         themes   {Array}  - The array of RenderThemes to be attached to this component.
     *     }
     * }
     * </pre>
     */
    function WordCloudRenderer( spec ) {
        spec.rootKey = spec.rootKey || "tile.meta.aggregated";
        spec.text = spec.text || {};
        Renderer.call( this, spec );
        this.injectCss( this.spec );
    }

    WordCloudRenderer.prototype = Object.create( Renderer.prototype );

    WordCloudRenderer.prototype.getEntrySelector = function() {
        return ".word-cloud-label";
    };

    WordCloudRenderer.prototype.injectCss = function( spec ) {
        var i;
        if ( spec.text.themes ) {
            for ( i = 0; i < spec.text.themes.length; i++ ) {
                spec.text.themes[i].injectTheme({
                    selector: ".word-cloud-label"
                });
                spec.text.themes[i].injectTheme({
                    selector: ".count-summary"
                });
            }
        }
    };

    WordCloudRenderer.prototype.getWordStyleClass = function ( wordProps ) {
        return 'word-cloud-label word-cloud-label-' + wordProps.percentLabel;
    };

    /**
     * Implementation specific rendering function.
     * @memberof WordCloudRenderer
     *
     * @param {Object} data - The raw data for a tile to be rendered.
     *
     * @returns {{html: string, entries: Array}} The html to render and an array of all rendered data entries.
     */
    WordCloudRenderer.prototype.render = function( data ) {

        var self = this,
            text = this.spec.text,
            textKey = text.textKey,
            countKey = text.countKey,
            values = RendererUtil.getAttributeValue( data, this.spec.rootKey ),
            numEntries = Math.min( values.length, text.maxWords || MAX_WORDS_DISPLAYED ),
            levelMinMax = this.parent.getLevelMinMax(),
            sizeFunction = text.sizeFunction || SIZE_FUNCTION,
            minFontSize = text.minFontSize || MIN_FONT_SIZE,
            maxFontSize = text.maxFontSize || MAX_FONT_SIZE,
            min = Number.MAX_VALUE,
            max = 0,
			$html = $("<div></div>"),
            wordCounts = [],
            entries = [],
            value,
            word,
            count,
            i,
            cloud;

        for ( i=0; i<numEntries; i++ ) {
            value = values[i];
            word = RendererUtil.getAttributeValue( value, textKey );
            count = RendererUtil.getAttributeValue( value, countKey );
            min = Math.min( min, count );
            max = Math.max( max, count );
            wordCounts.push({
                word: word,
                count: count,
                entry: value
            });
        }

        // if the min for the zoom level is specified in the meta, use it
        if ( levelMinMax.minimum ) {
            min = RendererUtil.getAttributeValue( levelMinMax.minimum, countKey );
        }
        // if the max for the zoom level is specified in the meta, use it
        if ( levelMinMax.maximum ) {
            max = RendererUtil.getAttributeValue( levelMinMax.maximum, countKey );
        }

        cloud = createWordCloud(
            wordCounts,
            min,
            max,
            sizeFunction,
            minFontSize,
            maxFontSize);

		var $label = $('<div class="count-summary"></div>');
		$html = $html.append( $label );

    cloud.forEach( function( word ) {
			entries.push( word.entry );
            var $wordLabel = $('<div '
                    + 'class="' + self.getWordStyleClass(word) + '" '
                    + 'style="'
                    + 'font-size:'+word.fontSize+'px;'
                    + 'left:'+(128+word.x-(word.width/2))+'px;'
                    + 'top:'+(128+word.y-(word.height/2))+'px;'
                    + 'width:'+word.width+'px;'
                    + 'height:'+word.height+'px;">'+word.word+'</div>');
			$wordLabel.mouseover(function() {
				$label.show(); // show label
				$label.text( RendererUtil.getAttributeValue( word.entry, countKey ) );
			});
			$wordLabel.mouseout(function() {
				$label.hide(); // hide label
			});
			// add it to the group
			$html = $html.append( $wordLabel );
    });

    return {
        html: $html,
        entries: entries
    };
  };

  module.exports = WordCloudRenderer;
}());

},{"./Renderer":29,"./RendererUtil":30}],35:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    /**
     * Instantiate a Aggregator object.
     * @class Aggregator
     * @classdesc
     */
    function Aggregator() {
    }

    /**
     * Given an array of buckets, will execute the provided aggregation
     * specification against all relevant entries.
     * @memberof Aggregator
     *
     * @param {Array} buckets - The array of buckets.
     *
     * @returns {Array} The aggregated buckets.
     */
    Aggregator.prototype.aggregate = function( buckets ) {
        return buckets;
    };

    /**
     * Attaches the aggregator to its respective layer. This method should not be called
     * manually.
     * @memberof Aggregator
     * @private
     *
     * @param {Layer} layer - The layer to attach to the renderer.
     */
     Aggregator.prototype.attach = function( layer ) {
        if ( this.parent && this.parent !== layer ) {
            console.log( "This renderer has already been attached " +
                         "to a different layer, please use another instance." );
            return;
        }
        this.parent = layer;
    };

    /**
     * Returns the start and end indices for the set of buckets.
     * @memberof Aggregator
     *
     * @param {Array} buckets - The array of buckets.
     *
     * @returns {Object} The range object.
     */
    Aggregator.prototype.getBucketRange = function( buckets ) {
        var tileTransformData = this.parent.getTileTransformData(),
            start = tileTransformData.startBucket,
            end = tileTransformData.endBucket;
        return {
            start: start !== undefined ? start : 0,
            end: end !== undefined ? end : buckets.length - 1
        };
    };

    /**
     * Checks the layer metadata for a translation map. If it exists, returns
     * the translated entry for the provided topic.
     * @memberof Aggregator
     *
     * @param {String} topic - The topic to translate.
     *
     * @returns {String} The translated topic.
     */
    Aggregator.prototype.translateTopic = function( topic ) {
        var meta = this.parent.source.meta.meta;
        if ( meta.translatedTopics ) {
            return meta.translatedTopics[ topic ];
        }
        return undefined;
    };

    /**
     * Executes a function for each bucket, passing the bucket and offset
     * reduced index arguments.
     * @memberof Aggregator
     *
     * @param {Array} buckets - The array of buckets.
     * @param {Function} func - The function to execute.
     */
    Aggregator.prototype.forEach = function( buckets, func ) {
        var range = this.getBucketRange( buckets ),
            start = range.start,
            end = range.end,
            i;
        // first iterate over all buckets and organize them by id
        for ( i=start; i<=end; i++ ) {
            // subtract start to always have index 0 based
            if ( func( buckets[i], i-start ) ) {
                return;
            }
        }
    };

    module.exports = Aggregator;

}());

},{}],36:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Aggregator = require('./Aggregator'),
        Util = require('../../../util/Util');

    /**
     * Instantiate a FrequenciesByTopicAggregator object.
     * @class FrequenciesByTopicAggregator
     * @classdesc
     */
    function FrequenciesByTopicAggregator() {
    }

    FrequenciesByTopicAggregator.prototype = Object.create( Aggregator.prototype );

    /**
     * Given an array of buckets, will execute the provided aggregation
     * specification against all relevant entries.
     * @memberof FrequenciesByTopicAggregator
     *
     * @param {Array} buckets - The array of buckets.
     *
     * @returns {Array} The aggregated buckets.
     */
    FrequenciesByTopicAggregator.prototype.aggregate = function( buckets ) {
        var frequenciesByTopic = {},
            range = this.getBucketRange( buckets ),
            bucketCount = range.end - range.start + 1;
        this.forEach(
            buckets,
            function( bucket, index ) {
                var topic,
                    i;
                if ( bucket ) {
                    for ( i=0; i<bucket.length; i++ ) {
                        topic = bucket[i].topic;
                        frequenciesByTopic[ topic ] = frequenciesByTopic[ topic ] || Util.fillArray( bucketCount );
                        frequenciesByTopic[ topic ][ index ] = bucket[i].score.total;
                    }
                }
        });
        return frequenciesByTopic;
    };

    module.exports = FrequenciesByTopicAggregator;

}());

},{"../../../util/Util":60,"./Aggregator":35}],37:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Aggregator = require('./Aggregator'),
        Util = require('../../../util/Util');

    /**
     * Instantiate a FrequencyArraysByTopicAggregator object.
     * @class FrequencyArraysByTopicAggregator
     * @classdesc
     */
    function FrequencyArraysByTopicAggregator() {
    }

    FrequencyArraysByTopicAggregator.prototype = Object.create( Aggregator.prototype );

    /**
     * Given an array of buckets, will execute the provided aggregation
     * specification against all relevant entries.
     * @memberof FrequencyArraysByTopicAggregator
     *
     * @param {Array} buckets - The array of buckets.
     *
     * @returns {Array} The aggregated buckets.
     */
    FrequencyArraysByTopicAggregator.prototype.aggregate = function( buckets ) {
        var frequenciesByTopic = {},
            range = this.getBucketRange( buckets ),
            bucketCount = range.end - range.start + 1,
            length;
        this.forEach(
            buckets,
            function( bucket, index ) {
                var topic,
                    i;
                if ( bucket ) {
                    for ( i=0; i<bucket.length; i++ ) {
                        topic = bucket[i].topic;
                        length = bucket[i].score.total.length;
                        frequenciesByTopic[ topic ] = frequenciesByTopic[ topic ] || Util.fillArray( bucketCount, Util.fillArray( length ) );
                        frequenciesByTopic[ topic ][ index ] = bucket[i].score.total.slice( 0 ); // copy
                    }
                }
        });
        return frequenciesByTopic;
    };

    module.exports = FrequencyArraysByTopicAggregator;

}());

},{"../../../util/Util":60,"./Aggregator":35}],38:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Aggregator = require('./Aggregator');

    /**
     * Iterates over each bucket, and perform the aggregation.
     *
     * @param {Aggregator} aggregator - The aggregator object.
     * @param {Array} buckets - The array of buckets.
     *
     * @param {Array} The aggregated buckets.
     */
    function aggregateBucket( aggregator, buckets ) {
        var aggregation,
            score,
            total,
            i;
        // set base aggregator
        aggregation = {
            topic: buckets[0].topic,
            topicEnglish: aggregator.translateTopic( buckets[0].topic ),
            count: 0
        };
        // for each bucket of data
        for ( i=0; i<buckets.length; i++ ) {
            // add to total count
            score = buckets[i].score;
            if (score !== undefined) {
                total = ( typeof score === "number" ) ? score : score.total;
                aggregation.count += total;
            }
        }
        return aggregation;
    }

    /**
     * Instantiate a TopicCountAggregator object.
     * @class TopicCountAggregator
     * @classdesc
     */
    function TopicCountAggregator() {
    }

    TopicCountAggregator.prototype = Object.create( Aggregator.prototype );

    /**
     * Given an array of buckets, will execute the provided aggregation
     * specification against all relevant entries.
     * @memberof TopicCountAggregator
     *
     * @param {Array} buckets - The array of buckets.
     *
     * @returns {Array} The aggregated buckets.
     */
    TopicCountAggregator.prototype.aggregate = function( buckets ) {
        var bucketsByTopic = {},
            aggBuckets = [],
            topic;
        this.forEach(
            buckets,
            function( bucket ) {
                var topic,
                    i;
                if ( bucket ) {
                    for ( i=0; i<bucket.length; i++ ) {
                        topic = bucket[i].topic;
                        bucketsByTopic[ topic ] = bucketsByTopic[ topic ] || [];
                        bucketsByTopic[ topic ].push( bucket[i] );
                    }
                }
        });
        // then, for each id, aggregate the buckets
        for ( topic in bucketsByTopic ) {
            if ( bucketsByTopic.hasOwnProperty( topic ) ) {
                aggBuckets.push( aggregateBucket( this, bucketsByTopic[ topic ] ) );
            }
        }
        // finally, sort them based on count
        aggBuckets.sort( function( a, b ) {
            return b.count - a.count;
        });
        return aggBuckets;
    };

    module.exports = TopicCountAggregator;

}());

},{"./Aggregator":35}],39:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Aggregator = require('./Aggregator'),
        Util = require('../../../util/Util');

    /**
     * Iterates over each bucket, and perform the aggregation.
     *
     * @param {Aggregator} aggregator - The aggregator object.
     * @param {Array} buckets - The array of buckets.
     *
     * @param {Array} The aggregated buckets.
     */
    function aggregateBucket( aggregator, buckets ) {
        var aggregation,
            score,
            total,
            texts,
            parsed,
            i, j, k;
        // set base aggregator
        aggregation = {
            topic: buckets[0].topic,
            topicEnglish: aggregator.translateTopic( buckets[0].topic ),
            counts: Util.fillArray(buckets[0].score instanceof Array ?
	            buckets[0].score.length : buckets[0].score.total.length ),
            total: 0
        };
        // for each bucket of data
        for ( i=0; i<buckets.length; i++ ) {
            score = buckets[i].score;
            total = ( score instanceof Array ) ? score : score.total;
            // add to total count
            for ( j=0; j<total.length; j++ ) {
                aggregation.counts[j] += total[j];
                aggregation.total += total[j];
            }
            // get sentiment. 'negative', 'positive', or 'neutral'
            texts = score.texts;
            if ( texts ) {
                for ( k=0; k<texts.length; k++ ) {
                    parsed = JSON.parse( texts[k].text );
                    aggregation.sentiment = parseSentiment( parsed[2] );
                }
            }
        }
        return aggregation;
    }

    /**
     * Instantiate a TopicCountArrayAggregator object.
     * @class TopicCountArrayAggregator
     * @classdesc
     */
    function TopicCountArrayAggregator() {
    }

    TopicCountArrayAggregator.prototype = Object.create( Aggregator.prototype );

    /**
     * Given an array of buckets, will execute the provided aggregation
     * specification against all relevant entries.
     * @memberof TopicCountArrayAggregator
     *
     * @param {Array} buckets - The array of buckets.
     *
     * @returns {Array} The aggregated buckets.
     */
    TopicCountArrayAggregator.prototype.aggregate = function( buckets ) {
        var bucketsByTopic = {},
            aggBuckets = [],
            topic;
        this.forEach(
            buckets,
            function( bucket ) {
                var topic,
                    i;
                if ( bucket ) {
                    for ( i=0; i<bucket.length; i++ ) {
                        topic = bucket[i].topic;
                        bucketsByTopic[ topic ] = bucketsByTopic[ topic ] || [];
                        bucketsByTopic[ topic ].push( bucket[i] );
                    }
                }
        });
        // then, for each id, aggregate the buckets
        for ( topic in bucketsByTopic ) {
            if ( bucketsByTopic.hasOwnProperty( topic ) ) {
                aggBuckets.push( aggregateBucket( this, bucketsByTopic[ topic ] ) );
            }
        }
        // finally, sort them based on count
        aggBuckets.sort( function( a, b ) {
            return b.total - a.total;
        });
        return aggBuckets;
    };

    /**
     * Returns the sentiment id string based on the numerical value.
     *
     * @param {number} value - The sentiment value.
     *
     * @returns {String} The sentiment id.
     */
    function parseSentiment( value ) {
        if ( value === undefined ) {
            return undefined;
        }
        if ( value === -1 ) {
            return 'negative';
        } else if ( value === 1 ) {
            return 'positive';
        }
        return 'neutral';
    }

    module.exports = TopicCountArrayAggregator;

}());

},{"../../../util/Util":60,"./Aggregator":35}],40:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Aggregator = require('./Aggregator'),
        Util = require('../../../util/Util');

    /**
     * Instantiate a TopicFrequencyAggregator object.
     * @class TopicFrequencyAggregator
     * @classdesc
     */
    function TopicFrequencyAggregator() {
    }

    TopicFrequencyAggregator.prototype = Object.create( Aggregator.prototype );

    /**
     * Given an array of buckets, will execute the provided aggregation
     * specification against all relevant entries.
     * @memberof TopicFrequencyAggregator
     *
     * @param {Array} buckets - The array of buckets.
     *
     * @returns {Array} The aggregated buckets.
     */
    TopicFrequencyAggregator.prototype.aggregate = function( buckets ) {
        var that = this,
            indexByTopic = {},
            range = this.getBucketRange( buckets ),
            bucketCount = range.end - range.start + 1,
            topics = [];
        this.forEach(
            buckets,
            function( bucket, index ) {
                var topicIndex,
                    topic,
                    score,
                    total,
                    i, j,
                    val;
                if ( bucket ) {
                    for ( i=0; i<bucket.length; i++ ) {
                        topic = bucket[i].topic;
                        if ( indexByTopic[ topic ] === undefined ) {
                            // create index if it does not exist
                            indexByTopic[ topic ] = topics.length;
                            topics.push({
                                topic: topic,
                                topicEnglish: that.translateTopic( topic ),
                                count: 0,
                                frequencies: Util.fillArray( bucketCount )
                            });
                        }
                        score = bucket[i].score;
                        total = ( typeof score === "number" || score instanceof Array ) ? score : score.total;
                        topicIndex = indexByTopic[ topic ];

                        if (total instanceof Array) {
                            // Calculate total aggregate and indexed aggregate
                            if (!topics[ topicIndex ].indexedCount) {
                                topics[topicIndex].indexedCount = new Array(total.length).fill(0);
                                topics[topicIndex].indexedFrequencies = new Array(bucketCount);
                            }
                            if (!topics[topicIndex].indexedFrequencies[index]) {
                                topics[topicIndex].indexedFrequencies[index] = new Array(total.length).fill(0);
                            }

                            var summedTotal = 0;

                            for (j = 0; j < total.length; j++) {
                                val = total[j];
                                summedTotal += val;
                                topics[topicIndex].indexedCount[j] += val;
                                topics[topicIndex].indexedFrequencies[index][j] += val;
                            }
                            total = summedTotal;
                        }

                        topics[ topicIndex ].count += total;
                        topics[ topicIndex ].frequencies[ index ] = total;
                    }
                }
        });
        // sort topics based on count
        topics.sort( function( a, b ) {
            return b.count - a.count;
        });
        return topics;
    };

    module.exports = TopicFrequencyAggregator;

}());

},{"../../../util/Util":60,"./Aggregator":35}],41:[function(require,module,exports){
/*
 * Copyright (c) 2013 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Aggregator = require('./Aggregator');

    /**
     * Returns the sentiment id string based on the numerical value.
     *
     * @param {number} value - The sentiment value.
     *
     * @returns {String} The sentiment id.
     */
    function parseSentiment( value ) {
        if ( value === undefined ) {
            return undefined;
        }
        if ( value === -1 ) {
            return 'negative';
        } else if ( value === 1 ) {
            return 'positive';
        }
        return 'neutral';
    }

    /**
     * Iterates over each bucket, and perform the aggregation.
     *
     * @param {Array} paths - The array of paths.
     * @param {Array} buckets - The array of buckets.
     *
     * @param {Array} The aggregated buckets.
     */
    function aggregateBucket( buckets ) {
        var tweets = [],
            parsed,
            texts,
            bucket,
            i, j;
        for ( i=0; i<buckets.length; i++ ) {
            bucket = buckets[i];
            texts = bucket.score.texts;
            for ( j=0; j<texts.length; j++ ) {
                parsed = JSON.parse( texts[j].text );
                tweets.push({
                    user: parsed[0],
                    text: parsed[1],
                    sentiment: parseSentiment( parsed[2] ),
                    timestamp: texts[j].score
                });
            }
        }
        return tweets;
    }

    /**
     * Instantiate a TweetsByTopicAggregator object.
     * @class TweetsByTopicAggregator
     * @classdesc
     */
    function TweetsByTopicAggregator() {
    }

    TweetsByTopicAggregator.prototype = Object.create( Aggregator.prototype );

    /**
     * Given an array of buckets, will execute the provided aggregation
     * specification against all relevant entries.
     * @memberof TweetsByTopicAggregator
     *
     * @param {Array} buckets - The array of buckets.
     * @param {number} startBucket - The start bucket. Optional.
     * @param {number} endBucket - The end bucket. Optional.
     *
     * @returns {Array} The aggregated buckets.
     */
    TweetsByTopicAggregator.prototype.aggregate = function( buckets ) {
        var bucketsByTopic = {},
            tweetsByTopic = {},
            topic;
        this.forEach(
            buckets,
            function( bucket ) {
                var topic,
                    i;
                if ( bucket ) {
                    for ( i=0; i<bucket.length; i++ ) {
                        topic = bucket[i].topic;
                        bucketsByTopic[ topic ] = bucketsByTopic[ topic ] || [];
                        bucketsByTopic[ topic ].push( bucket[i] );
                    }
                }
        });
        // then, for each id, aggregate the buckets
        for ( topic in bucketsByTopic ) {
            if ( bucketsByTopic.hasOwnProperty( topic ) ) {
                tweetsByTopic[ topic ] = aggregateBucket( bucketsByTopic[ topic ] );
            }
        }
        return tweetsByTopic;
    };

    module.exports = TweetsByTopicAggregator;

}());

},{"./Aggregator":35}],42:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Util = require('../util/Util'),
        PubSub = require('../util/PubSub'),
        AxisUtil = require('./AxisUtil'),
        AXIS_TITLE_CLASS = "axis-title-label",
        AXIS_DIV_CLASS_SUFFIX = "-axis",
        AXIS_HEADER_CLASS = "axis-header",
        AXIS_HEADER_CLASS_SUFFIX = "-axis-header",
        AXIS_CONTENT_CLASS = "axis-content",
        AXIS_CONTENT_CLASS_SUFFIX = "-axis-content",
        AXIS_LABEL_CLASS = "axis-marker-label",
        AXIS_POSITIONED_LABEL_CLASS_SUFFIX = "-axis-marker-label" ,
        AXIS_MARKER_CLASS = "axis-marker",
        AXIS_MARKER_SUFFIX = "-axis-marker",
        AXIS_POSITION_SUFFIX = "-axis",
        SPACING_BETWEEN_MARKER_AND_LABEL = 5,
        Z_INDEX = 2001;

    /**
     * Creates and returns a dummy marker label element to measure. This function
     * is used for measuring, as the real label func sizes the labels to the current
     * max measurements
     * @private
     *
     * @param axis   {Axis}     the axis object.
     * @param marker {Object} the marker object.
     */
    function createDummyMarkerLabelHTML( axis, marker ) {
        return '<div class="' + AXIS_LABEL_CLASS
            + ' ' + axis.horizontalOrVertical + AXIS_POSITIONED_LABEL_CLASS_SUFFIX + '"'
            + 'style="position:absolute;">'
            + axis.format( marker.label )
            + '</div>';
    }

    /**
     * Creates and returns a marker label element with proper CSS
     * @private
     *
     * @param axis   {Axis}     the axis object.
     * @param marker {Object} the marker object.
     */
    function createMarkerLabelHTML( axis, marker ) {
        var primaryPosition,
            secondaryPosition;
        if ( axis.isXAxis ) {
            // if x axis, add half of label length as text is anchored from bottom
            primaryPosition = marker.pixel - axis.MAX_LABEL_UNROTATED_WIDTH*0.5;
            secondaryPosition =  axis.LARGE_MARKER_LENGTH
                + SPACING_BETWEEN_MARKER_AND_LABEL;
        } else {
            primaryPosition = marker.pixel - axis.MAX_LABEL_HEIGHT*0.5;
            secondaryPosition =  axis.LARGE_MARKER_LENGTH
                + SPACING_BETWEEN_MARKER_AND_LABEL;
        }
        return '<div class="' + AXIS_LABEL_CLASS + ' '
            + axis.horizontalOrVertical + AXIS_POSITIONED_LABEL_CLASS_SUFFIX + '"'
            + 'style="position:absolute;'
            + 'text-align: center; '    // center text horizontally
            + 'height: ' + axis.MAX_LABEL_HEIGHT + 'px;'
            + 'line-height: ' + axis.MAX_LABEL_HEIGHT + 'px;'   // center text vertically
            + axis.leftOrTop + ":" + primaryPosition + 'px;'
            + axis.oppositePosition + ":" + secondaryPosition + 'px;">'
            + axis.format( marker.label )
            +'</div>';
    }

    /**
     * Creates and returns a large marker element with proper CSS
     * @private
     *
     * @param axis   {Axis}     the axis object.
     * @param marker {Object} the marker object.
     */
    function createLargeMarkerHTML( axis, marker ) {
        return '<div class="' + AXIS_MARKER_CLASS
            + ' large-' + axis.horizontalOrVertical + AXIS_MARKER_SUFFIX
            + ' ' + axis.position + AXIS_POSITION_SUFFIX + '"'
            + 'style="position:absolute;'
            + axis.leftOrTop + ":" + (marker.pixel - axis.LARGE_MARKER_HALF_WIDTH) + 'px;">'
            + '</div>';
    }

    /**
     * Creates and returns a major marker element with proper CSS
     * @private
     *
     * @param axis   {Axis}     the axis object.
     * @param marker {Object} the marker object.
     */
    function createMediumMarkerHTML( axis, marker ) {
        return '<div class="' + AXIS_MARKER_CLASS
            + ' medium-' + axis.horizontalOrVertical + AXIS_MARKER_SUFFIX
            + ' ' + axis.position + AXIS_POSITION_SUFFIX + '"'
            + 'style="position:absolute;'
            + axis.leftOrTop + ":" + (marker.pixel - axis.MEDIUM_MARKER_HALF_WIDTH) + 'px;">'
            + '</div>';
    }

    /**
     * Creates and returns a major marker element with proper CSS
     * @private
     *
     * @param axis   {Axis}     the axis object.
     * @param marker {Object} the marker object.
     */
    function createSmallMarkerHTML( axis, marker ) {
        return '<div class="' + AXIS_MARKER_CLASS
            + ' small-' + axis.horizontalOrVertical + AXIS_MARKER_SUFFIX
            + ' ' + axis.position + AXIS_POSITION_SUFFIX + '"'
            + 'style="position:absolute;'
            + axis.leftOrTop + ":" + (marker.pixel - axis.SMALL_MARKER_HALF_WIDTH) + 'px;">'
            + '</div>';
    }

    function measureLabelRotation( axis, $label ) {
        var matrix, values, angle;
        matrix = $label.css("-webkit-transform") ||
                 $label.css("-moz-transform")    ||
                 $label.css("-ms-transform")     ||
                 $label.css("-o-transform")      ||
                 $label.css("transform") || 'none';
        if(matrix !== 'none') {
            values = matrix.split('(')[1].split(')')[0].split(',');
            angle = Math.atan2(values[1], values[0]);
        } else {
            angle = 0;
        }
        axis.ROTATION_RADIANS = Math.abs(angle);
    }

    function measureLabelElement( axis, $label ) {
        var sinW = $label.width() * Math.sin( axis.ROTATION_RADIANS ),
            sinH = $label.height() * Math.sin( axis.ROTATION_RADIANS ),
            cosW = $label.width() * Math.cos( axis.ROTATION_RADIANS ),
            cosH = $label.height() * Math.cos( axis.ROTATION_RADIANS );
        axis.MAX_LABEL_WIDTH = Math.max( sinH + cosW, axis.MAX_LABEL_WIDTH );
        axis.MAX_LABEL_HEIGHT = Math.max( cosH + sinW, axis.MAX_LABEL_HEIGHT );
        axis.MAX_LABEL_UNROTATED_WIDTH = Math.max( $label.width(), axis.MAX_LABEL_UNROTATED_WIDTH );
    }

    function measureLabelDimensions( axis ) {
        var min = {
                pixel: 0,
                label: axis.min
            },
            max = {
                pixel: 0,
                label: axis.max
            },
            $temp;
        // clear previous measurements
        axis.MAX_LABEL_WIDTH = 0;
        axis.MAX_LABEL_HEIGHT = 0;
        axis.MAX_LABEL_UNROTATED_WIDTH = 0;
        // measure max label
        $temp = $( createDummyMarkerLabelHTML( axis, max ) ).appendTo( axis.$content );
        measureLabelElement( axis, $temp );
        $temp.remove();
        // measure min label
        $temp = $( createDummyMarkerLabelHTML( axis, min ) ).appendTo( axis.$content );
        measureLabelElement( axis, $temp );
        $temp.remove();
    }

    /**
     * This function is used to create temporary elements to determine the required run-time
     * dimensions. This is only be called once per axis as these dimensions will never change.
     * @private
     *
     * @param axis{Axis} the axis object.
     */
    function calcElementDimensions( axis ) {
        var $temp;
        // initialized all measurements to zero
        axis.LARGE_MARKER_LENGTH = 0;
        axis.LARGE_MARKER_HALF_WIDTH = 0;
        axis.MEDIUM_MARKER_HALF_WIDTH = 0;
        axis.SMALL_MARKER_HALF_WIDTH = 0;
        axis.ROTATION_RADIANS = 0;
        axis.HEADER_WIDTH = 0;
        axis.TITLE_WIDTH = 0;
        if ( axis.title ) {
            // title width
            axis.TITLE_WIDTH = axis.$title.width();
            // header width
            switch ( axis.position ) {
                case "top":
                    axis.HEADER_WIDTH = parseInt( axis.$header.css("border-top-width"), 10 );
                    break;
                case "right":
                    axis.HEADER_WIDTH = parseInt( axis.$header.css("border-right-width"), 10 );
                    break;
                case "bottom":
                    axis.HEADER_WIDTH = parseInt( axis.$header.css("border-bottom-width"), 10 );
                    break;
                case "left":
                    axis.HEADER_WIDTH = parseInt( axis.$header.css("border-left-width"), 10 );
                    break;
            }
        }
        // measure large markers
        $temp = $(createLargeMarkerHTML( axis, {pixel:0} )).hide().appendTo(axis.$content);
        axis.LARGE_MARKER_LENGTH = $temp[axis.markerWidthOrHeight]();
        axis.LARGE_MARKER_HALF_WIDTH = Math.floor( $temp[axis.axisWidthOrHeight]()*0.5 );
        $temp.remove();
        // measure medium markers
        $temp = $(createMediumMarkerHTML( axis, {pixel:0} )).hide().appendTo(axis.$content);
        axis.MEDIUM_MARKER_HALF_WIDTH = Math.floor( $temp[axis.axisWidthOrHeight]() * 0.5);
        $temp.remove();
        // measure small markers
        $temp = $(createSmallMarkerHTML( axis, {pixel:0} )).hide().appendTo(axis.$content);
        axis.SMALL_MARKER_HALF_WIDTH = Math.floor( $temp[axis.axisWidthOrHeight]() * 0.5);
        $temp.remove();
        // measure label rotation
        $temp = $( createDummyMarkerLabelHTML( axis, {pixel:0} ) ).appendTo( axis.$content );
        measureLabelRotation( axis, $temp );
        $temp.remove();
        // measure label dimensions
        measureLabelDimensions( axis );
    }

    /**
     * Creates and returns the axis label element with proper CSS.
     * @private
     *
     * @param axis {Axis} the axis object.
     */
    function createTitle( axis ) {
        var rotation = "",
            transformOrigin ="";
        if ( !axis.isXAxis ) {
            rotation = "rotate(-90deg)";
            transformOrigin = "top left";
        }
        return $('<span class="'+AXIS_TITLE_CLASS+'"'
            + 'style="position:absolute;'
            + '-webkit-transform: ' + rotation + ";"
            + '-moz-transform: ' + rotation + ";"
            + '-ms-transform: ' + rotation + ";"
            + '-o-transform: ' + rotation + ";"
            + 'transform: ' + rotation + ";"
            + '-webkit-transform-origin: ' + transformOrigin + ";"
            + '-moz-transform-origin: ' + transformOrigin + ";"
            + '-ms-transform-origin: ' + transformOrigin + ";"
            + '-o-transform-origin: ' + transformOrigin + ";"
            + 'transform-origin: ' + transformOrigin + ";"
            + '">' + axis.title + '</div>');
    }

    /**
     * Creates and returns the axis header jquery object.
     * @private
     *
     * @param axis {Axis} the axis object.
     */
    function createHeader( axis ) {
        return $('<div class="'+ AXIS_HEADER_CLASS + " " + axis.horizontalOrVertical + '-header' +" " + axis.position + AXIS_HEADER_CLASS_SUFFIX + '"'
               + 'style="z-index:'+(Z_INDEX+2)+';"></div>');
    }

    /**
     * Creates and returns the axis header background jquery object. This is used
     * to apply a box-shadow css without ugly overlap.
     * @private
     *
     * @param axis {Axis} the axis object.
     */
    function createHeaderBack( axis ) {
        return $('<div class="'+ AXIS_HEADER_CLASS + " " + AXIS_HEADER_CLASS + "-back " + axis.horizontalOrVertical + '-header-back' + '"'
               + 'style="z-index:'+(Z_INDEX+1)+';'
               + axis.position + ':0px;'
               + ( axis.isXAxis ? '' : 'top:0px;') + '"></div>' );
    }

    /**
     * Creates and returns the empty axis content jquery object.
     * @private
     *
     * @param axis {Axis} the axis object.
     */
    function createContent( axis ) {
        return $('<div class="'+ AXIS_CONTENT_CLASS
               + " " + axis.position + AXIS_CONTENT_CLASS_SUFFIX
               + '"  style="z-index:'+Z_INDEX+';"></div>');
    }

    /**
     * Creates and returns the axis parent div jquery object.
     * @private
     *
     * @param axis {Axis} the axis object.
     */
    function createAxis( axis ) {
        var $axis,
            enableSlide,
            disableSlide,
            horizontalSlide,
            verticalSlide;
        enableSlide = function() {
            // set enable / disable callbacks if collapsible axis
            if ( axis.isXAxis ) {
                axis.$header.click( verticalSlide );
                axis.$content.click( verticalSlide );
            } else {
                axis.$header.click( horizontalSlide );
                axis.$content.click( horizontalSlide );
            }
        };
        disableSlide = function() {
            axis.$header.off('click');
            axis.$content.off('click');
        };
        horizontalSlide = function() {
            axis.setEnabled( !axis.isEnabled() );
            axis.updateDimension();
            disableSlide();
            axis.$content.animate({width: 'toggle'}, {duration: 300, complete: function(){ enableSlide();} });
            axis.redraw();
            PubSub.publish( axis.getChannel(), { field: 'open', value: axis.isEnabled() } );
        };
        verticalSlide = function() {
            axis.setEnabled( !axis.isEnabled() );
            axis.updateDimension();
            disableSlide();
            axis.$content.animate({height: 'toggle'}, {duration: 300, complete: function(){ enableSlide();} });
            axis.redraw();
            PubSub.publish( axis.getChannel(), { field: 'open', value: axis.isEnabled() } );
        };
        // create axis content container and append it to root
        axis.$content = createContent( axis );
        $axis = $('<div class="axis '+ axis.position + AXIS_DIV_CLASS_SUFFIX + '"></div>');
        $axis.append( axis.$content );
        if ( axis.title  ) {
            // only create title and header IF a title is provided
            axis.$title = createTitle( axis );
            axis.$header = createHeader( axis ).append( axis.$title );
            $axis.append( axis.$header );
            $axis.append( createHeaderBack( axis ) );
            // enable callbacks, if collapsible
            if ( axis.collapsible ) {
                enableSlide();
            }
        }
        // return root
        return $axis;
    }

    /**
     * Updates the positon of the axis title of its size changes.
     * @private
     *
     * @param axis {Axis} the axis object.
     */
    function updateAxisTitle( axis ) {
        // update axis length
        var $title = axis.$title,
            axisLength,
            padding;
        // calc new axis length
        if ( axis.isXAxis ) {
            axisLength = axis.$map.outerWidth();
        } else {
            axisLength = axis.$map.outerHeight() - (axis.HEADER_WIDTH*2);
            // add position offset for vertical axes
            $title.css( axis.leftOrTop, axisLength+"px" );
        }
        // calc padding
        padding = ( axisLength/2 ) - ( axis.TITLE_WIDTH/2 );
        // add padding for hover hit box
        $title.css( 'padding-left', padding + "px" );
    }

    /**
     * Creates the axis marker elements and appends them to the content div.
     * @private
     *
     * @param axis {Axis} the axis object.
     */
    function updateAxisContent( axis ) {
        var markers,
            markersHTML = "",
            markersBySize,
            i;
        // generate array of marker labels and pixel locations
        markersBySize = AxisUtil.getMarkers( axis );
        // large markers
        markers = markersBySize.large;
        for (i = 0; i < markers.length; i++) {
            markersHTML += createLargeMarkerHTML( axis, markers[i] );
            if ( markers[i].label ) {
                markersHTML += createMarkerLabelHTML( axis, markers[i] );
            }
        }
        // medium markers
        markers = markersBySize.medium;
        for (i = 0; i < markers.length; i++) {
            markersHTML += createMediumMarkerHTML( axis, markers[i] );
            if ( markers[i].label ) {
                markersHTML += createMarkerLabelHTML( axis, markers[i] );
            }
        }
        // small markers
        markers = markersBySize.small;
        for (i = 0; i < markers.length; i++) {
            markersHTML += createSmallMarkerHTML( axis, markers[i] );
            if ( markers[i].label ) {
                markersHTML += createMarkerLabelHTML( axis, markers[i] );
            }
        }
        // append all markers and labels at once
        axis.$content[0].innerHTML = markersHTML;
    }

    /**
     * Returns the draw callback function on map 'move' event.
     * @private
     *
     * @param axis {Axis} The axis object.
     */
    function redrawCallback( axis ) {
        return function() {
            axis.redraw();
        };
    }

    /**
     * Returns the mouse marker callback function on 'mousemove' event.
     * @private
     *
     * @param axis {Axis} The axis object.
     */
    function mouseMoveCallback( axis ) {
        return function( event ) {
            if ( !axis.enabled ) {
                return;
            }
            var marker = AxisUtil.getMarker( axis, event.xy.x, event.xy.y );
            axis.$content.find( '.mouse-marker' ).remove();
            axis.$content.append( $( createLargeMarkerHTML( axis, marker ) ).addClass( 'mouse-marker' ) );
        };
    }

    /**
     * Returns the mouse hover callback function on 'mouseover' event.
     * @private
     *
     * @param axis {Axis} The axis object.
     */
    function mouseHoverCallback( axis ) {
        return function( event ) {
            var offset = axis.$content.offset(),
                position = {
                    x: event.clientX - offset.left,
                    y: event.clientY - offset.top
                },
                marker = AxisUtil.getMarker( axis, position.x, position.y ),
                $label;
            // remove existing markers
            axis.$content.find( '.axis-hover-label' ).remove();
            axis.$content.find( '.mouse-marker' ).remove();
            // create label
            $label = $('<div class="axis-hover-label hover-label" style="'+
                axis.leftOrTop+':'+ marker.pixel +'px;">'+
                    '<div class="hover-label-text">'+ axis.format( marker.label, true ) +'</div>'+
                '</div>');
            // append label
            axis.$content.append( $label );
            // position label
            if ( axis.isXAxis ) {
                $label.css( axis.oppositePosition, -( $label.outerHeight() + 10 ) );
                $label.css( 'margin-left', -$label.outerWidth()/2 );
            } else {
                $label.css( axis.oppositePosition, -( $label.outerWidth() + 10 ) );
                $label.css( 'margin-top', -$label.outerHeight()/2 );
            }
            // create and append marker
            axis.$content.append( $( createLargeMarkerHTML( axis, marker ) ).addClass( 'mouse-marker' ) );
        };
    }

    /**
     * Returns the mouse hover callback function on 'mouseout' event.
     * @private
     *
     * @param axis {Axis} The axis object.
     */
    function mouseOutCallback( axis ) {
        return function() {
            axis.$content.find( '.axis-hover-label' ).remove();
            axis.$content.find( '.mouse-marker' ).remove();
        };
    }

    /**
     * Instantiate an Axis object.
     * @class Axis
     * @classdesc A map axis object that will attach to a map edge and display coordinates based on
     *            supplied interval and unit specification.
     *
     * @param spec {Object} The specification object:
     * <pre>
	 * {
     *     position {String}  Set the position to the bottom of the map. Default = "bottom"
     *     title    {String}  Set the title of the axis label. Default = "Axis"
     *     enabled  {boolean} Have the axis initialize to an open or closed state. Default = true
     *     repeat   {boolean} Whether or not the axis repeats. Default = false
     *     intervals: {
     *         type          {String}  Whether the intervals are by "percentage" or by "value". Default = "percentage"
     *         increment     {number}  The interval increment in. Default = 10
     *         pivot         {number}  The value from with increments are generated from. Default = undefined
     *         scaleByZoom   {boolean} Whether the increments should be scaled by zoom level. Default = true
     *         minPixelWidth {number}  The minimum width for a full axis increment. Default = undefined;
     *     }
     *     units: {
     *         type     {String}  The type of unit, ["integer", "decimal", "thousands", "millions", "billions", "degrees"]. Default = "decimal"
     *         decimals {number}  The number of decimals to display, if applicable. Default = 2
     *         stepDown {boolean} Whether values should step down by unit type, if applicable. Default = true
     *     }
     * }
	 * </pre>
     */
    function Axis( spec ) {

        this.uuid = Util.generateUuid();
        this.position = ( spec.position !== undefined ) ? spec.position.toLowerCase() : 'bottom';
        this.repeat = ( spec.repeat !== undefined ) ? spec.repeat : false;
        this.title = spec.title || null;
        this.enabled = ( spec.enabled !== undefined ) ? spec.enabled : true;
        this.collapsible = ( spec.collapsible !== undefined ) ? spec.collapsible : true;
        spec.intervals = spec.intervals || {};
        this.intervals = {};
        this.intervals.type = ( spec.intervals.type !== undefined ) ? spec.intervals.type.toLowerCase() : 'percentage';
        this.intervals.increment = spec.intervals.increment || 10;
        this.intervals.pivot = spec.intervals.pivot;
        this.intervals.scaleByZoom = ( spec.intervals.scaleByZoom !== undefined ) ? spec.intervals.scaleByZoom : true;
        this.intervals.minPixelWidth = ( spec.intervals.minPixelWidth !== undefined ) ? spec.intervals.minPixelWidth : false;

        spec.units = spec.units || {};
        this.units = {};
        this.units.type = ( spec.units.type !== undefined ) ? spec.units.type.toLowerCase() : 'decimal';
        this.units.decimals = spec.units.decimals || 2;
        this.units.stepDown = ( spec.units.stepDown !== undefined ) ? spec.units.stepDown : true;
        this.units.scale = spec.units.scale || 'linear';

        // generate more attributes
        this.isXAxis = ( this.position === 'top' || this.position === 'bottom' );
        this.axisWidthOrHeight = this.isXAxis ? "width" : "height";
        this.markerWidthOrHeight = this.isXAxis ? "height" : "width";
        this.leftOrTop = this.isXAxis ? "left" : "top";
        this.horizontalOrVertical = (this.isXAxis) ? 'horizontal' : 'vertical';
        this.oppositePosition = (this.position === 'left') ? 'right' :
                                    (this.position === 'right') ? 'left' :
                                        (this.position === 'top') ? 'bottom' : 'top';
    }

    /**
     * Activates the Axis object. This should never be called manually.
     * @memberof Axis
     * @private
     */
    Axis.prototype.activate = function() {
        // create unique callbacks so they can be removed later
        this.redrawCallback = redrawCallback( this );
        this.mouseMoveCallback = mouseMoveCallback( this );
        this.mouseHoverCallback = mouseHoverCallback( this );
        this.mouseOutCallback = mouseOutCallback( this );
        // attach callbacks
        this.map.on( 'move', this.redrawCallback );
        this.map.on( 'mousemove', this.mouseMoveCallback );
        // generate the core html elements
        this.$map = $( this.map.getElement() );
        this.$axis = createAxis( this );
        this.$map.append( this.$axis );

        this.$axis.on( 'mousemove', this.mouseHoverCallback );
        this.$axis.on( 'mouseout', this.mouseOutCallback );

        // calculate the dimensions of the individual elements once
        calcElementDimensions( this );
        // check if axis starts open or closed
        if ( this.title && !this.enabled ) {
            // set enabled to true, as the triggered
            // click event will toggle the enabled flag
            // back to false
            this.enabled = true;
            // trigger close and skip animation;
            this.$header.click();
            this.$content.finish();
        }
    };

    /**
     * Dectivates the layer object. This should never be called manually.
     * @memberof Axis
     * @private
     */
    Axis.prototype.deactivate = function() {
        this.map.off( 'move', this.redrawCallback );
        this.map.off( 'mousemove', this.mouseMoveCallback );
        this.$axis.off( 'mousemove', this.mouseHoverCallback );
        this.$axis.off( 'mouseout', this.mouseOutCallback );
        this.$axis.remove();
        this.$axis = null;
        this.$title = null;
        this.$header = null;
        this.$content = null;
        this.redrawCallback = null;
        this.mouseMoveCallback = null;
        this.mouseHoverCallback = null;
        this.mouseOffCallback = null;
    };

    /**
     * Returns true if the axis is currently enabled, false if not.
     * @memberof Axis
     *
     * @returns {boolean} Whether or not the axis is enabled or not.
     */
    Axis.prototype.isEnabled = function() {
        return this.enabled;
    };

    /**
     * Enable or disable the axis.
     * @memberof Axis
     *
     * @param {boolean} - Whether to enable or disable the axis.
     */
    Axis.prototype.setEnabled = function( enabled ) {
        this.enabled = enabled;
    };

    /**
     * Returns the dimension of the content div of the axis.
     * @memberof Axis
     *
     * @returns {integer} The dimension of the content div.
     */
    Axis.prototype.getContentDimension = function() {
        var dim = this.isXAxis ? this.MAX_LABEL_HEIGHT : this.MAX_LABEL_WIDTH;
        if ( this.title ) {
            dim += this.HEADER_WIDTH;
        }
        return dim + SPACING_BETWEEN_MARKER_AND_LABEL*2 + this.LARGE_MARKER_LENGTH;
    };

    /**
     * Iterates over all axes on the map, determines the max content size, and
     * sets the content dimension to that size.
     * @memberof Axis
     *
     * @returns {integer} The max dimension of the axes attached to the map.
     */
    Axis.prototype.getMaxContentDimension = function() {
        var maxAxisLabelDim = 0;
        _.forIn( this.map.axes, function( axis ) {
            maxAxisLabelDim = Math.max( axis.getContentDimension() || 0, maxAxisLabelDim );
        });
        return maxAxisLabelDim;
    };

    /**
     * Sets the content dimension of the axis.
     * @memberof Axis
     */
    Axis.prototype.updateDimension = function() {
        var dim = this.isXAxis ? 'height' : 'width';
        this.$content[ dim ]( this.getMaxContentDimension( this.map ) );
    };

    /**
     * Checks if the mutable spec attributes have changed, if so, redraws the axis.
     * @memberof Axis
     */
    Axis.prototype.redraw = function() {
        if ( this.title ) {
            // always update title position (in case of window resize)
            updateAxisTitle( this );
        }
        // exit early if no markers are visible
        if ( !this.isEnabled() ) {
            return;
        }
        // measure label dimensions
        measureLabelDimensions( this );
        // add each marker to correct pixel location in axis DOM elements
        updateAxisContent( this );
    };

    /**
     * Format a value by the axis unit specification.
     *
     * @param {number} value - The value to format.
     * @param {boolean} verbose - Whether the formatting should be verbose. (optional)
     *
     * @returns {String} The resulting formatted value string.
     */
    Axis.prototype.format = function( value, verbose ) {
        return AxisUtil.formatText( this, value, this.units, verbose );
    };

    /**
     * Returns the publish/subscribe channel id of this specific axis.
     * @memberof Axis
     *
     * @returns {String} The publish/subscribe channel for the axis.
     */
     Axis.prototype.getChannel = function () {
        return 'axis.' + this.position + '.' + this.uuid;
    };

    module.exports = Axis;
}());

},{"../util/PubSub":59,"../util/Util":60,"./AxisUtil":43}],43:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * A utility namespace containing axis related functionality.
 */
( function() {

    "use strict";

    var Util = require('../util/Util'),
        MapUtil = require('./MapUtil'),
        MARKER_TYPE_ORDER = ['large', 'small', 'medium', 'small'];

    /**
     * Private: Given a value that is outside of the min and max of axis,
     * ensure the values rollover properly
     *
     * @param axis  {Axis}   the axis object.
     * @param value {number} original value.
     */
    function getMarkerRollover( axis, value ) {
        var rollover;
        if ( axis.repeat ) {
            // if repeat enabled ensure label value wraps past min/max properly
            if ( value > axis.max ) {
                rollover = value - axis.max + axis.min;
            } else if ( value < axis.min ) {
                rollover = value + axis.max - axis.min;
            } else {
                rollover = value;
            }
        } else {
            // non-repeat label is always value as there is no wrap around
            rollover = value;
        }
        return rollover;
    }

    /**
     * Private: Returns the pixel position for the value in viewport coordinates.
     *
     * @param axis  {Axis}   axis object.
     * @param value {number} the coordinate value.
     * @returns {int} pixel position
     */
    function getPixelPosition( axis, value ) {
        // given an axis value, get the pixel position on the page
        if ( axis.isXAxis ) {
            return MapUtil.getViewportPixelFromCoord( axis.map, value, 0 ).x;
        }
        return MapUtil.getViewportPixelFromCoord( axis.map, 0, value ).y;
    }

    /**
     * Private: Fills an array of markers by sub increments.
     *
     * @param axis      {Axis}   axis object.
     * @param start     {number} start increment.
     * @param end       {number} end increment
     * @param intervals {Object} intervals specification object.
     * @returns {{large: Array, medium: Array, small: Array}}
     */
    function fillArrayByIncrement( axis, start, end, intervals ) {
        var EPSILON = ( end - start ) * 0.000001,
            subIncrement = intervals.subIncrement,
            startingMarkerTypeIndex = intervals.startingMarkerTypeIndex,
            markers = {
                large: [],
                medium: [],
                small: []
            },
            i = Util.mod( startingMarkerTypeIndex, MARKER_TYPE_ORDER.length ),
            value,
            marker;
        // reduce sub increment by epsilon to prevent precision errors culling max point
        if ( axis.units.type !== 'time' &&
            axis.units.type !== 'date' &&
            axis.units.type !== 'i' &&
            axis.units.type !== 'int' &&
            axis.units.type !== 'integer' ) {
            subIncrement -= EPSILON;
        }
        for ( value=start; value<=end; value+=subIncrement ) {
            marker = {
                pixel: getPixelPosition( axis, value )
            };
            if ( MARKER_TYPE_ORDER[i] === "large" ) {
                marker.label = getMarkerRollover( axis, value );
            }
            markers[ MARKER_TYPE_ORDER[i] ].push( marker );
            i = (i + 1) % MARKER_TYPE_ORDER.length;
        }
        return markers;
    }

    /**
     * Private: Returns the minimum visible increment on the axis. Also sets the
     * 'startingMarkerTypeIndex' attribute on the intervals object to distinguish
     * which type of marker to start on.
     *
     * @param axis      {Axis}   axis object.
     * @param intervals {Object} intervals specification object.
     * @returns {number} minimum increment.
     */
    function getMinIncrement( axis, intervals ) {
        var minCull, // exact value of cull point, any value less will be culled from view
            incrementCount; // number of sub increments from the pivot
        if ( axis.isXAxis ) {
            minCull = MapUtil.getCoordFromViewportPixel( axis.map, 0, 0 ).x;
        } else {
            minCull = MapUtil.getCoordFromViewportPixel( axis.map, 0, axis.map.getViewportHeight() ).y;
        }
        if ( !axis.repeat && minCull < axis.min ) {
            // prevent roll-over
            minCull = axis.min;
        }
        // determine how many sub increments from the pivot to the minimum culling point
        incrementCount = Math.ceil( ( minCull - intervals.pivot ) / intervals.subIncrement, minCull );
        intervals.startingMarkerTypeIndex = incrementCount;
        // return the minimum increment that is still in view
        return intervals.pivot + intervals.subIncrement * incrementCount;
    }

    /**
     * Private: Returns the maximum visible increment on the axis.
     *
     * @param axis      {Axis}   axis object.
     * @param intervals {Object} intervals specification object.
     * @returns {number} maximum increment.
     */
    function getMaxIncrement( axis, intervals ) {
        var maxCull, // exact value of cull point, any value greater will be culled from view
            incrementCount; // number of sub increments from the pivot
        if ( axis.isXAxis ) {
            maxCull = MapUtil.getCoordFromViewportPixel( axis.map, axis.map.getViewportWidth(), 0 ).x;
        } else {
            maxCull = MapUtil.getCoordFromViewportPixel( axis.map, 0, 0 ).y;
        }
        if ( !axis.repeat && maxCull > axis.max ) {
            // prevent roll-over
            maxCull = axis.max;
        }
        // determine how many sub increments from the pivot to the maximum culling point
        incrementCount = Math.floor( ( maxCull - intervals.pivot ) / intervals.subIncrement, maxCull );
        // return the maximum increment that is still in view
        return intervals.pivot + intervals.subIncrement * incrementCount;
    }

    /**
     * Private: Rounds a value to an integer representation.
     *
     * @param value {number} the value.
     * @returns {int}
     */
    function formatInteger( value ) {
        return Math.round( value );
    }

    /**
     * Private: Formats a number in scientific notation rounding to nearest decimals.
     *
     * @param value    {number} the value.
     * @param decimals {int}    the number of decimal places.
     * @param allowStepDown {boolean} whether or not to step down units if < 1
     * @returns {string}
     */
    function formatScientificNotation( value, decimals ) {
        return value.toExponential(decimals);
    }

    /**
     * Private: Rounds a value to an floating point representation with specific decimal places.
     *
     * @param value    {number} the value.
     * @param decimals {int}    the number of decimal places.
     * @returns {string}
     */
    function formatNumber( value, decimals, allowStepDown ) {
        var truncValue = Math.pow( 10, -decimals );
        if (allowStepDown && value < truncValue) {
            return formatScientificNotation( value, decimals );
        }
        return Util.roundToDecimals( value, decimals );
    }

    /**
     * Private: Rounds a value to an floating point representation of thousands with a 'K' appended
     * onto the end.
     *
     * @param value         {number}  the value.
     * @param decimals      {int}     the number of decimal places.
     * @param allowStepDown {boolean} whether or not to step down units if < 1
     * @returns {string}
     */
    function formatThousand( value, decimals, allowStepDown ) {
        var truncValue = value / 1e3;
        if ( allowStepDown && Math.abs( truncValue ) < 1 ) {
            return formatNumber( value, decimals, true );
        }
        return Util.roundToDecimals( truncValue, decimals ) + 'K';
    }

    /**
     * Private: Rounds a value to an floating point representation of millions with an 'M' appended
     * onto the end.
     *
     * @param value         {number}  the value.
     * @param decimals      {int}     the number of decimal places.
     * @param allowStepDown {boolean} whether or not to step down units if < 1
     * @returns {string}
     */
    function formatMillion( value, decimals, allowStepDown ) {
        var truncValue = value / 1e6;
        if ( allowStepDown && Math.abs( truncValue ) < 1 ) {
            return formatThousand( value, decimals, true );
        }
        return Util.roundToDecimals( truncValue, decimals ) + 'M';
    }

    /**
     * Private: Rounds a value to an floating point representation of billions with a 'B' appended
     * onto the end.
     *
     * @param value         {number}  the value.
     * @param decimals      {int}     the number of decimal places.
     * @param allowStepDown {boolean} whether or not to step down units if < 1
     * @returns {string}
     */
    function formatBillion( value, decimals, allowStepDown ) {
        var truncValue = value / 1e9;
        if ( allowStepDown && Math.abs( truncValue ) < 1 ) {
            return formatMillion( value, decimals, true );
        }
        return Util.roundToDecimals( truncValue, decimals ) + 'B';
    }

    /**
     * Private: Formats a timestamp into a date.
     *
     * @param value {int} unix timestamp.
     * @param verbose {boolean} format to a longer more human readable date
     * @returns {string}
     */
    function formatTime( axis, value, verbose ) {
        var time = moment.utc( value );
        if ( verbose ) {
            return time.format( "MMM D, h:mm:ssa" );
        }
        var duration = moment.duration( ( axis.max - axis.min ) / Math.pow( 2, axis.map.getZoom() ) );
        if ( duration.asMonths() > 16 ) {
            return time.format( "YYYY" );
        } else if ( duration.asMonths() > 2 ) {
            return time.format( "MMM YYYY" );
        }
        return time.format( "MMM D, YYYY" );
    }

    /**
     * Private: Formats a floating point number and appends a 'degrees' symbol.
     *
     * @param value    {float} degrees value.
     * @param decimals {int}   the number of decimal places.
     * @returns {string}
     */
    function formatDegrees( value, decimals ) {
        return formatNumber( value, decimals ) + "\u00b0";
    }

    /**
     * Private: Returns a sub increment for the axis. This is scaled base on a
     * the 'minPixelWidth' interval property.
     * @param axis      {Axis}   axis object.
     * @param increment {number} increment for the axis.
     * @returns {number} sub increment value.
     */
    function getSubIncrement( axis, increment ) {
        var powerOfTwo = 1,
            subIncrement = increment / MARKER_TYPE_ORDER.length;
        if ( axis.intervals.minPixelWidth ) {
            // ensure increment is of minimum width
            while ( Math.abs( getPixelPosition( axis, increment*powerOfTwo ) -
                getPixelPosition( axis, 0 ) ) < axis.intervals.minPixelWidth ) {
                powerOfTwo *= 2;
            }
        }
        return subIncrement * powerOfTwo;
    }

    /**
     * Private: Adds a time based marker to the markers array.
     *
     * @param {Axis} axis - The axis object.
     * @param {number} start - The first visible value on the axis.
     * @param {number} end - The last visible value on the axis.
     * @param {Array} markers - The markers array.
     * @param {number} timestamp - The timestamp value to add.
     * @param {boolean} addLabel - Whether or not to add a label to the marker.
     */
    function addTimeMarker( axis, start, end, markers, timestamp, addLabel ) {
        if ( timestamp >= start && timestamp <= end ) {
            var marker = {
                pixel: getPixelPosition( axis, timestamp )
            };
            if ( addLabel ) {
                marker.label = timestamp;
            }
            markers.push( marker );
        }
    }

    /**
     * Private: Splits the time unit into non floating point units.
     *
     * @param {string} unit - The unit type.
     * @param {number} count - The number of units.
     */
    function splitTimeUnit( unit, count ) {
        // if unit is already a non floating point count, return early
        if ( count % 1 === 0 ) {
            return {
                unit: unit,
                count: count
            };
        }
        // split unit to next subunit
        var result = {};
        switch ( unit ) {
            case "year":
                result = {
                    unit: "month",
                    count: count * 12
                };
                break;
            case "month":
                result = {
                    unit: "week",
                    count: count * 4
                };
                break;
            case "week":
                result = {
                    unit: "day",
                    count: count * 7
                };
                break;
            case "day":
                result = {
                    unit: "hour",
                    count: count * 24
                };
                break;
            default:
                console.error("Cannot split time units evenly");
                return null;
        }
        // if unit still isn't split evenly, recurse further
        if ( result.count % 1 !== 0 ) {
            return splitTimeUnit( result.unit, result.count );
        }
        return result;
    }

    /**
     * Private: Adds time based markers based on some alignment.
     *
     * @param {Axis} axis - The axis object.
     * @param {Array} markers - The markers array.
     * @param {number} start - The first visible value on the axis.
     * @param {number} end - The last visible value on the axis.
     * @param {string} alignBy - The unit to align the markers by.
     * @param {string} unit - The unit by which to step by.
     * @param {number} countPerLabel - The number of units per label.
     */
    function addTimeAlignedMarkers( axis, markers, start, end, alignBy, unit, countPerLabel ) {
        var alignedStart = moment.utc( start ).startOf( alignBy ).valueOf(),
            duration = moment.duration( end - alignedStart ),
            numUnits = duration.as( unit + "s" ),
            step = countPerLabel >= 1 ? countPerLabel : 1,
            subUnit,
            aligned,
            large,
            medium,
            small,
            i, j;
        for ( i=0; i<numUnits; i+=step ) {
            // get timestamp of aligned unit
            aligned = moment.utc( alignedStart ).add( i, unit ).valueOf();
            // determine number of sub divisions
            var numSubDivisions = 1/countPerLabel;
            for ( j=0; j<numSubDivisions; j++ ) {
                var subDivided = splitTimeUnit( unit, countPerLabel );
                large = moment.utc( aligned ).add( j*subDivided.count, subDivided.unit ).valueOf();
                // add large marker
                addTimeMarker( axis, start, end, markers.large, large, true );
                // add medium marker
                subUnit = splitTimeUnit( subDivided.unit, subDivided.count / 2 );
                medium = moment.utc( large ).add( subUnit.count, subUnit.unit + "s" ).valueOf();
                addTimeMarker( axis, start, end, markers.medium, medium );
                // add small marker
                subUnit = splitTimeUnit( subDivided.unit, subDivided.count / 4 );
                small = moment.utc( large ).add( subUnit.count, subUnit.unit + "s" ).valueOf();
                addTimeMarker( axis, start, end, markers.small, small );
                small = moment.utc( large ).add( subUnit.count * 3, subUnit.unit + "s" ).valueOf();
                addTimeMarker( axis, start, end, markers.small, small );
            }
        }
    }

    /**
     * Private: Fills an array of markers by time based sub increments.
     *
     * @param axis      {Axis}   axis object.
     * @param start     {number} start increment.
     * @param end       {number} end increment
     */
    function fillArrayByTimeIncrement( axis, start, end ) {
        var duration = moment.duration( ( axis.max - axis.min ) / Math.pow( 2, axis.map.getZoom() ) ),
            markers = {
                large: [],
                medium: [],
                small: []
            };
        if ( duration.asMonths() > 16 ) {
            addTimeAlignedMarkers( axis, markers, start, end, "year", "year", 1 );
        } else if ( duration.asMonths() > 8 ) {
            addTimeAlignedMarkers( axis, markers, start, end, "year", "month", 4 );
        } else if ( duration.asMonths() > 4 ) {
            addTimeAlignedMarkers( axis, markers, start, end, "year", "month", 2 );
        } else if ( duration.asMonths() > 2 ) {
            addTimeAlignedMarkers( axis, markers, start, end, "year", "month", 1 );
        } else if ( duration.asMonths() > 1 ) {
            addTimeAlignedMarkers( axis, markers, start, end, "year", "month", 0.5 );
        } else if ( duration.asWeeks() > 2 ) {
            addTimeAlignedMarkers( axis, markers, start, end, "year", "month", 0.25 );
        } else if ( duration.asWeeks() > 1 ) {
            addTimeAlignedMarkers( axis, markers, start, end, "year", "day", 4 );
        } else if ( duration.asDays() > 4 ) {
            addTimeAlignedMarkers( axis, markers, start, end, "year", "day", 2 );
        } else {
            addTimeAlignedMarkers( axis, markers, start, end, "year", "day", 1 );
        }
        return markers;
    }

    module.exports = {

        /**
         * Formats axis marker label text.
         *
         * @param value {number} value of the label
         * @param units {Object} unit specification of the axis.
         * @param verbose {boolean} format to a more verbose format, if available.
         */
        formatText: function( axis, value, units, verbose ) {

            if ( !units ) {
                return formatNumber( value, 2 );
            }

            if (units.scale === "log10") {
                value = Math.pow(10, value);
            }

            switch ( units.type ) {

                case 'degrees':
                case 'degree':
                case 'deg':

                    return formatDegrees( value, units.decimals );

                case 'time':
                case 'date':

                    return formatTime( axis, value, verbose );

                case 'k':
                case 'thousand':
                case 'thousands':

                    return formatThousand( value, units.decimals, units.stepDown );

                case 'm':
                case 'million':
                case 'millions':

                    return formatMillion( value, units.decimals, units.stepDown );

                case 'b':
                case 'billion':
                case 'billions':

                    return formatBillion( value, units.decimals, units.stepDown );

                case 'i':
                case 'int':
                case 'integer':

                    return formatInteger( value );

                default:

                    return formatNumber( value, units.decimals );
            }
        },

        /**
         * Generates a marker value for the given viewport pixel coords.
         *
         * @param axis {Axis} the axis object.
         * @param vx   {int}  x viewport pixel coordinate
         * @param vy   {int}  y viewport pixel coordinate
         */
        getMarker: function( axis, vx, vy ) {
            var xOrY = axis.isXAxis ? 'x' : 'y',
                pixel = ( axis.isXAxis ) ? vx : vy,
                value = MapUtil.getCoordFromViewportPixel( axis.map, vx, vy )[ xOrY ];
            return {
                value: value,
                label: getMarkerRollover(axis, value),
                pixel: pixel
            };
        },

        /**
         * Generates all visible marker values, returns array of objects, containing
         * labels and pixel locations
         *
         * @param axis {Axis} the axis object.
         */
        getMarkers: function( axis ) {
            var intervals = {},
                increment,
                minIncrement,
                maxIncrement;

            // time based axis partitions aren't 'even', they should correspond based
            // on the scale at which the data is currently being shown, therefore these
            // markers will be generated as their own edge case
            if ( axis.units.type === "time" ) {
                minIncrement = getMinIncrement( axis, {
                    pivot: axis.min,
                    subIncrement: 1000 * 60 * 60
                });
                maxIncrement = getMaxIncrement( axis, {
                    pivot: axis.min,
                    subIncrement: 1000 * 60 * 60
                });
                return fillArrayByTimeIncrement( axis, minIncrement, maxIncrement );
            }

            switch ( axis.intervals.type ) {

                case "value":
                case "fixed":
                case "#":
                    // use fixed interval
                    increment = axis.intervals.increment;
                    // set pivot by value
                    intervals.pivot = ( axis.intervals.pivot !== undefined ) ? axis.intervals.pivot : axis.min;
                    break;

                default:
                    // use percentage
                    increment = axis.intervals.increment;
                    increment = ( increment > 1 ) ? increment * 0.01 : increment;
                    increment = ( axis.max - axis.min ) * increment;
                    intervals.pivot = ( axis.intervals.pivot !== undefined ) ? axis.intervals.pivot : 0;
                    // normalize percentages to [0-1] not [0-100]
                    if ( intervals.pivot > 1 ) {
                        intervals.pivot = intervals.pivot / 100;
                    }
                    // calc pivot value by percentage
                    intervals.pivot = axis.min + ( intervals.pivot * ( axis.max - axis.min ) );
                    break;
            }

            // scale increment if specified
            if ( axis.intervals.scaleByZoom ) {
                // scale increment by zoom
                increment = increment / Math.pow(2, Math.max( axis.map.getZoom() - 1, 0) );
            }

            //intervals.increment = increment;
            intervals.subIncrement = getSubIncrement( axis, increment );

            // get minimum and maximum visible increments on the axis
            minIncrement = getMinIncrement( axis, intervals );
            maxIncrement = getMaxIncrement( axis, intervals );

            // add all points between minimum visible value and maximum visible value
            return fillArrayByIncrement( axis, minIncrement, maxIncrement, intervals );
        }
    };
}());

},{"../util/Util":60,"./MapUtil":45}],44:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var Axis = require('./Axis'),
        PendingLayer = require('../layer/PendingLayer'),
        MapUtil = require('./MapUtil'),
        Layer = require('../layer/Layer'),
        Carousel = require('../layer/Carousel'),
        BaseLayer = require('../layer/BaseLayer'),
        PubSub = require('../util/PubSub'),
        AreaOfInterestTilePyramid = require('../binning/AreaOfInterestTilePyramid'),
        WebMercatorTilePyramid = require('../binning/WebMercatorTilePyramid'),
        TileIterator = require('../binning/TileIterator'),
        TILESIZE = 256,
        MARKER_Z_INDEX = 5000,
        setMapCallbacks,
        activateComponent,
        deactivateComponent,
        activateDeferredComponents,
        addBaseLayer,
        addLayer,
        addCarousel,
        addAxis,
        removeBaseLayer,
        removeLayer,
        removeCarousel,
        removeAxis,
        resetLayerZIndices;

    /**
     * Set callbacks to update the maps tile focus, identifying which tile
     * the user is currently hovering over.
     * @private
     *
     * @param map {Map} The map object.
     */
    setMapCallbacks = function( map ) {
        var previousMouse = {};
        function updateTileFocus( x, y ) {
            var tileAndBin = MapUtil.getTileAndBinFromViewportPixel( map, x, y, 1, 1 ),
                tilekey = tileAndBin.tile.level + ","
                    + tileAndBin.tile.xIndex + ","
                    + tileAndBin.tile.yIndex;
            if ( tilekey !== map.tileFocus ) {
                // only update tilefocus if it actually changes
                map.previousTileFocus = map.tileFocus;
                map.tileFocus = tilekey;
                PubSub.publish( 'layer', { field: 'tileFocus', value: tilekey });
            }
        }
        // set tile focus callbacks
        map.on('mousemove', function( event ) {
            updateTileFocus( event.xy.x, event.xy.y );
            previousMouse.x = event.xy.x;
            previousMouse.y = event.xy.y;
        });
        map.on('zoomend', function() {
            updateTileFocus( previousMouse.x, previousMouse.y );
        });
        // if mousedown while map is panning, interrupt pan
        map.olMap.events.register( "mousedown", map, function(){
            if ( map.olMap.panTween ) {
                map.olMap.panTween.callbacks = null;
                map.olMap.panTween.stop();
            }
        }, true );
        // create resize callback
        map.resizeCallback = function() {
            map.olMap.updateSize();
        };
        // set resize callback
        $( window ).on( 'resize', map.resizeCallback );
    };

    /**
     * Activates a component.
     * @private
     *
     * @param map       {Map} The map object.
     * @param component {*}   The component to activate.
     */
    activateComponent = function( map, component ) {
        if ( component instanceof Carousel ) {
            addCarousel( map, component );
        } else if ( component instanceof Layer ) {
            if ( component.carousel ) {
                console.log(
                    "You cannot add a layer that is part of a carousel to a map " +
                    "independently, remove it from the carousel first." );
                return;
            }
            addLayer( map, component );
        } else if ( component instanceof Axis ) {
            addAxis( map, component );
        }
    };

    /**
     * Deactivates a component.
     * @private
     *
     * @param map       {Map} The map object.
     * @param component {*}   The component to deactivate.
     */
    deactivateComponent = function( map, component ) {
        if ( component instanceof BaseLayer ) {
            removeBaseLayer( map, component );
        } else if ( component instanceof Carousel ) {
            removeCarousel( map, component );
        } else if ( component instanceof Layer ) {
            removeLayer( map, component );
        } else if ( component instanceof Axis ) {
            removeAxis( map, component );
        }
    };

    /**
     * Activates deferred components when the map is ready.
     * @private
     *
     * @param map {Map} The map object.
     */
    activateDeferredComponents = function( map ) {
        var i;
        for ( i=0; i<map.deferreds.length; i++ ) {
            activateComponent( map, map.deferreds[i] );
        }
        delete map.deferreds;
    };

    /**
     * Adds a base layer to the map. If no baselayer is attached, it
     * will also activate it, along with any deferred components that were attached
     * first.
     * @private
     *
     * @param map       {Map}       The map object.
     * @param baselayer {BaseLayer} The baselayer object.
     */
    addBaseLayer = function( map, baselayer ) {
        // add map to baselayer
        baselayer.map = map;
        // add to baselayer array
        map.baselayers = map.baselayers || [];
        map.baselayers.push( baselayer );
        // if first baselayer, activate the map
        if ( map.baseLayerIndex < 0 ) {
            // openlayers maps require a baselayer to operate, once
            // this baselayer is set, activate the map
            map.setBaseLayerIndex( 0 );
            // set initial viewpoint, required by openlayers
            map.olMap.zoomToMaxExtent();
            // set mouse callbacks
            setMapCallbacks( map );
            // create pending layer now
            if ( map.showPendingTiles ) {
                map.pendingLayer = new PendingLayer();
                map.pendingLayer.map = map;
                map.pendingLayer.activate();
            }
            if ( map.deferreds ) {
                activateDeferredComponents( map );
            }
        }
    };

    /**
     * Adds a layer object to the map and activates it.
     * @private
     *
     * @param map   {Map}   The map object.
     * @param layer {Layer} The layer object.
     */
    addLayer = function( map, layer ) {
        // add map to layer
        layer.map = map;
        // track layer
        if ( map.showPendingTiles && layer.showPendingTiles ) {
            map.pendingLayer.register( layer );
        }
        // activate the layer
        layer.activate();
        // add to layer array
        map.layers = map.layers || [];
        map.layers.push( layer );
        // add it to layer map
        map.layersById = map.layersById || {};
        map.layersById[ layer.getUUID() ] = layer;
    };

    /**
     * Adds a carousel object to the map and activates it.
     * @private
     *
     * @param map   {Map}   The map object.
     * @param carousel {Carousel} The carousel object.
     */
    addCarousel = function( map, carousel ) {
        // add map to carousel
        carousel.map = map;
        // activate the carousel
        carousel.activate();
        // add to carousel array
        map.carousels = map.carousels || [];
        map.carousels.push( carousel );
        // add it to carousel map
        map.carouselsById = map.carouselsById || {};
        map.carouselsById[ carousel.getUUID() ] = carousel;
    };

    /**
     * Adds an Axis object to the map and activates it.
     * @private
     *
     * @param map  {Map}  The map object.
     * @param axis {Axis} The layer object.
     */
    addAxis = function( map, axis ) {
        // set min/max based on pyramid
        if ( axis.position === 'top' || axis.position === 'bottom' ) {
            axis.min = map.pyramid.minX;
            axis.max = map.pyramid.maxX;
        } else {
            axis.min = map.pyramid.minY;
            axis.max = map.pyramid.maxY;
        }
        // activate and attach to map
        axis.map = map;
        axis.activate();
        map.axes = map.axes || {};
        map.axes[ axis.position ] = axis;
        // update dimensions
        _.forIn( map.axes, function( value ) {
            value.updateDimension();
        });
        // redraw
        _.forIn( map.axes, function( value ) {
            value.redraw();
        });
    };

    /**
     * Removes a base layer from the map. If no other baselayer is attached, it
     * will refuse to do so.
     * @private
     *
     * @param map       {Map}       The map object.
     * @param baselayer {BaseLayer} The baselayer object.
     */
    removeBaseLayer = function( map, baselayer ) {
        var index;
        // if only 1 baselayer available, ignore
        if ( !map.destroying && map.baselayers.length === 1 ) {
            console.error( 'Error: attempting to remove only baselayer from ' +
                'map, this destroys the map, use destroy() instead' );
            return;
        }
        // get index of baselayer
        index = map.baselayers.indexOf( baselayer );
         // remove baselayer from array
        map.baselayers.splice( index, 1 );
        // if we are removing an active base layer, change to
        // next index
        if ( index === map.baseLayerIndex ) {
            // get replacement index
            index = ( map.baselayers[ index ] ) ? index : index-1;
            // replace baselayer
            map.setBaseLayerIndex( index );
        } else {
            if ( index < map.baseLayerIndex ) {
                map.baseLayerIndex--;
            }
        }
        baselayer.map = null;
    };

    /**
     * Removes a layer object from the map and deactivates it.
     * @private
     *
     * @param map   {Map}   The map object.
     * @param layer {Layer} The layer object.
     */
    removeLayer = function( map, layer ) {
        var index = map.layers.indexOf( layer );
        if ( index !== -1 ) {
             // remove it from layer map
            delete map.layersById[ layer.getUUID() ];
            // remove it from layer array
            map.layers.splice( index, 1 );
            // track layer
            if ( map.showPendingTiles ) {
                map.pendingLayer.unregister( layer );
            }
            // deactivate it
            layer.deactivate();
            layer.map = null;
            // reset z-indices
            resetLayerZIndices( map );
        }
    };

    /**
     * Removes a carousel object from the map and deactivates it.
     * @private
     *
     * @param map   {Map}   The map object.
     * @param carousel {Carousel} The carousel object.
     */
    removeCarousel = function( map, carousel ) {
        var index = map.carousels.indexOf( carousel );
        if ( index !== -1 ) {
             // remove it from layer map
            delete map.carouselsById[ carousel.getUUID() ];
            // remove it from layer array
            map.carousels.splice( index, 1 );
            // deactivate it
            carousel.deactivate();
            carousel.map = null;
            // reset z-indices
            resetLayerZIndices( map );
        }
    };

    /**
     * Removes an Axis object from the map and deactivates it.
     * @private
     *
     * @param map  {Map}   The map object.
     * @param axis {Axis} The layer object.
     */
    removeAxis = function( map, axis ) {
        // remove it from axes map
        delete map.axes[ axis.position ];
        // deactivate it
        axis.deactivate();
        axis.map = null;
    };

    /**
     * Removing layers causes a z-index reset since we use css z-index rather
     * than OpenLayers's built in relative indexing (which sucks for dynamic maps).
     * This is used to reset all z-indices accordingly.
     * @private
     *
     * @param {Map} map - The map object.
     */
    resetLayerZIndices = function( map ) {
        var layers = map.layers,
            baselayer,
            i;
        if ( map.layers ) {
            for ( i=0; i<layers.length; i++ ) {
                layers[i].setZIndex( layers[i].getZIndex() );
            }
        }
        if ( map.baseLayerIndex >= 0 ) {
            baselayer = map.baselayers[ map.baseLayerIndex ];
            baselayer.resetZIndex();
        }
        if ( map.olMarkers ) {
            $( map.olMarkers.div ).css( 'z-index', MARKER_Z_INDEX );
        }
    };

    /**
     * Instantiate a Map object.
     * @class Map
     * @classdesc A map object that acts as a central container for all layers and other map
     *            components.
     *
     * @param {String} id - The DOM element id string.
     * @param {Object} spec - The specification object.
     * <pre>
     * {
     *     pyramid {String} - The pyramid type for the map. Defaults to 'WebMercator'
     *     options: {
     *         numZoomLevels {integer} - The number of zoom levels. Default = 18.
     *         units {integer} - The units used for the map. Default = 'm'.
     *         zoomDelay {integer} - The delay before requesting tiles on a zoom. Default = 400.
     *         moveDelay {integer} - The delay before requesting tiles on a pan. Default = 400.
     *     }
     * }
     * </pre>
     */
    function Map( id, spec ) {
        spec = spec || {};
        spec.options = spec.options || {};
        spec.theme = spec.theme || 'dark';
        // element id
        this.id = id;
        // set map tile pyramid
        this.setPyramid( spec.pyramid );
        // initialize base layer index to -1 for no baselayer
        this.baseLayerIndex = -1;
        // disable kinetic pan
        OpenLayers.Control.DragPan.prototype.enableKinetic = false;
		// navigation controls
		this.navigationControls = new OpenLayers.Control.Navigation({
			documentDrag: true,
			zoomBoxEnabled: false
		});
		// zoom controls
		this.zoomControls = new OpenLayers.Control.Zoom();
        // create map object
        this.olMap = new OpenLayers.Map( this.id, {
            theme: null, // prevent OpenLayers from checking for default css
            projection: new OpenLayers.Projection( "EPSG:900913" ),
            displayProjection: new OpenLayers.Projection( "EPSG:4326" ),
            maxExtent: OpenLayers.Bounds.fromArray([
                -20037508.342789244,
                -20037508.342789244,
                20037508.342789244,
                20037508.342789244
            ]),
            zoomMethod: null,
            units: spec.options.units || "m",
            numZoomLevels: spec.options.numZoomLevels || 18,
            fallThrough: true,
            controls: [
                this.navigationControls,
                this.zoomControls
            ],
            tileManager: OpenLayers.TileManager ? new OpenLayers.TileManager({
                moveDelay: spec.options.moveDelay !== undefined ? spec.options.moveDelay : 400,
                zoomDelay: spec.options.zoomDelay !== undefined ? spec.options.zoomDelay : 400
            }) : undefined
        });
        // show animation on pending tiles
        this.showPendingTiles = ( spec.showPendingTiles !== undefined ) ? spec.showPendingTiles : true;
        // set theme, default to 'dark' theme
        this.setTheme( spec.theme );
    }

    Map.prototype = {

        /**
         * Removes all components and destroys the map.
         * @memberof Map.prototype
         */
        destroy: function() {
            this.destroying = true;
            // remove pending layer
            if ( this.pendingLayer ) {
                this.pendingLayer.deactivate();
                this.pendingLayer.map = null;
                this.pendingLayer = null;
            }
            // remove marker layer
            if ( this.olMarkers ) {
                this.olMap.removeLayer( this.olMarkers );
                this.olMarkers = null;
            }
            this.layers.forEach( function( layer ) {
                this.remove( layer );
            }, this );
            _.forIn( this.axes, function( axis ) {
                this.remove( axis );
            }, this );
            this.baselayers.forEach( function( baselayer ) {
                this.remove( baselayer );
            }, this );
            // remove window resize callback
            $( window ).off( 'resize', this.resizeCallback );
            // destroy map
            this.olMap.destroy();
        },

        /**
         * Adds a component to the map.
         * @memberof Map.prototype
         *
         * @param {Layer|Axis} component - The component object.
         */
        add: function( component ) {
            if ( component instanceof BaseLayer ) {
                // if a baselayer, add it
                addBaseLayer( this, component );
                return;
            }
            if ( this.baseLayerIndex < 0 ) {
                // if no baselayer is attached yet, we cannot activate the component
                // add it to list of deferred activations
                this.deferreds = this.deferreds || [];
                this.deferreds.push( component );
                return;
            }
            // activate the component
            activateComponent( this, component );
        },

        /**
         * Removes a component from the map.
         * @memberof Map.prototype
         *
         * @param {Layer|Axis} component - The component object.
         */
        remove: function( component ) {
            if ( this.baseLayerIndex < 0 ) {
                // if no baselayer is attached yet, we cannot deactivate the component
                // remove it from the list of deferred activations
                this.deferreds = this.deferreds || [];
                this.deferreds.splice( this.deferreds.indexOf( component ), 1 );
                return;
            }
            // activate the component
            deactivateComponent( this, component );
        },

        /**
         * Enables the panning controls for the map.
         */
        enableNavigation: function() {
            this.navigationControls.activate();
        },

        /**
         * Disables the panning controls for the map.
         */
        disableNavigation: function() {
            this.navigationControls.deactivate();
        },

        /**
         * Returns the tilekey for the tile currently under the mouse.
         * @memberof Map.prototype
         *
         * @returns {String} The tilekey currently under the mouse.
         */
        getTileFocus: function() {
            return this.tileFocus;
        },

        /**
         * If multiple baselayers are attached to the map, this function is
         * used to change the currently active one by index.
         * @memberof Map.prototype
         *
         * @param {integer} index - The index of the baselayer to switch to.
         */
        setBaseLayerIndex: function( index ) {
            var oldBaseLayer = this.baselayers[ this.baseLayerIndex ],
                newBaseLayer = this.baselayers[ index ];
            if ( !newBaseLayer ) {
                console.error("Error, no baselayer for supplied index: " + index );
                return;
            }
            if ( oldBaseLayer === newBaseLayer ) {
                // same layer, don't switch
                return;
            }
            if ( oldBaseLayer ) {
                oldBaseLayer.deactivate();
            }
            newBaseLayer.activate();
            this.baseLayerIndex = index;
            // update z index, since changing baselayer resets them
            resetLayerZIndices( this );
            PubSub.publish( newBaseLayer.getChannel(), { field: 'baseLayerIndex', value: index });
        },

        /**
         * Returns the currently active baselayer index.
         * @memberof Map.prototype
         *
         * @returns {integer} The currently active baselayer index.
         */
        getBaseLayerIndex: function() {
            return this.baseLayerIndex;
        },

        /**
         * Returns the currently active baselayer, or null if there isn't one.
         * @memberof Map.prototype
         *
         * @returns {BaseLayer} The currently active baselayer.
         */
        getActiveBaseLayer: function() {
            if ( this.baseLayerIndex === -1 ) {
                return null;
            }
            return this.baselayers[ this.baseLayerIndex ];
        },

        /**
         * Set the theme of the map. Currently restricted to "dark" and "light".
         * @memberof Map.prototype
         *
         * @param {String} theme - The theme identification string of the map.
         */
        setTheme: function( theme ) {
            if ( this.theme === theme ) {
                return;
            }
            var i;
            // toggle theme in html
            if ( theme === 'light' ) {
                $( 'body' ).removeClass( "dark-theme" ).addClass( "light-theme" );
            } else {
                $( 'body' ).removeClass( "light-theme" ).addClass( "dark-theme" );
            }
            this.theme = theme;
            // update theme for all attached layers
            if ( this.layers ) {
                for ( i=0; i<this.layers.length; i++ ) {
                    if ( this.layers[i].setTheme ) {
                        this.layers[i].setTheme( theme );
                    }
                }
            }
        },

        /**
         * Returns the current theme of the map. Currently restricted to "dark"
         * and "light".
         * @memberof Map.prototype
         *
         * @returns {String} The theme of the map.
         */
        getTheme: function() {
            return this.theme;
        },

        /**
         * Returns the map DOM element. This is the element to which
         * the map object is 'attached'.
         * @memberof Map.prototype
         *
         * @returns {HTMLElement} The map div element.
         */
        getElement:  function() {
            return this.olMap.div;
        },

        /**
         * Returns the map viewport DOM element. This the element that encompasses
         * the viewable portion of the map.
         * @memberof Map.prototype
         *
         * @returns {HTMLElement} The map viewport div element.
         */
        getViewportElement:  function() {
            return this.olMap.viewPortDiv;
        },

        /**
         * Returns the map container DOM element. This is the element to which all
         * 'pannable' layers are attached to.
         * @memberof Map.prototype
         *
         * @returns {HTMLElement} The map container div element.
         */
        getContainerElement:  function() {
            return this.olMap.layerContainerDiv;
        },

        /**
         * Add a pyramid to the map. All Tile iterators returned prior to this
         * will be invalidated.
         * @memberof Map.prototype
         *
         * @param {AreaOfInterestTilePyramid|WebMercatorTilePyramid|Object} pyramid - The pyramid.
         */
        setPyramid: function( pyramid ) {
            if ( !pyramid ) {
                this.pyramid = new WebMercatorTilePyramid();
            } else if ( pyramid instanceof AreaOfInterestTilePyramid ||
                pyramid instanceof WebMercatorTilePyramid ) {
                this.pyramid = pyramid;
            } else if ( pyramid.type && pyramid.type.toLowerCase() === "areaofinterest" ) {
                this.pyramid = new AreaOfInterestTilePyramid( pyramid );
            } else {
                this.pyramid = new WebMercatorTilePyramid();
            }
        },

        /**
         * Returns the tile pyramid used by the map.
         * @memberof Map.prototype
         *
         * @returns {AreaOfInterestTilePyramid|WebMercatorTilePyramid} The TilePyramid object.
         */
        getPyramid: function() {
            return this.pyramid;
        },

        /**
         * Returns a TileIterator object. This TileIterator contains all tiles currently
         * visible in the map.
         * @memberof Map.prototype
         *
         * @returns {TileIterator} A TileIterator object containing all visible tiles.
         */
        getTileIterator: function() {
            var level = this.olMap.getZoom(),
                // Current map bounds, in meters
                bounds = this.olMap.getExtent(),
                // Total map bounds, in meters
                extents = this.olMap.getMaxExtent(),
                // Pyramid for the total map bounds
                pyramid = new AreaOfInterestTilePyramid({
                    minX: extents.left,
                    minY: extents.bottom,
                    maxX: extents.right,
                    maxY: extents.top
                });
            // determine all tiles in view
            return new TileIterator({
                pyramid: pyramid,
                level: level,
                minX: bounds.left,
                minY: bounds.bottom,
                maxX: bounds.right,
                maxY: bounds.top
            });
        },

        /**
         * Returns an array of all tilekeys currently visible in the map.
         * @memberof Map.prototype
         *
         * @returns {Array} An array of tilekey strings.
         */
        getTilesInView: function() {
            var tiles = this.getTileIterator().getRest(),
                culledTiles = [],
                maxTileIndex = Math.pow(2, this.getZoom() ),
                tile,
                i;
            for (i=0; i<tiles.length; i++) {
                tile = tiles[i];
                if ( tile.xIndex >= 0 && tile.yIndex >= 0 &&
                     tile.xIndex < maxTileIndex && tile.yIndex < maxTileIndex ) {
                     culledTiles.push( tile.level + "," + tile.xIndex + "," + tile.yIndex );
                }
            }
            return culledTiles;
        },

        /**
         * Zooms the map to a particular coordinate and zoom level. The
         * transition is instantaneous.
         * @memberof Map.prototype
         *
         * @param {number} x - The x coordinate (longitude for geospatial).
         * @param {number} y - The y coordinate (latitude for geospatial).
         * @param {integer} zoom - The zoom level.
         */
        zoomTo: function( x, y, zoom ) {
            var viewportPx = MapUtil.getViewportPixelFromCoord( this, x, y ),
                lonlat = this.olMap.getLonLatFromViewPortPx( viewportPx );
            this.olMap.setCenter( lonlat, zoom );
        },

        /**
         * Zooms the map to a particular bounding box. The transition is
         * instantaneous.
         * @memberof Map.prototype
         *
         * @param {Object} bounds - The bounding box to zoom to.
         */
        zoomToExtent: function( bounds ) {
            var minViewportPx = MapUtil.getViewportPixelFromCoord( this, bounds.minX, bounds.minY ),
                maxViewportPx = MapUtil.getViewportPixelFromCoord( this, bounds.maxX, bounds.maxY ),
                minLonLat = this.olMap.getLonLatFromViewPortPx( minViewportPx ),
                maxLonLat = this.olMap.getLonLatFromViewPortPx( maxViewportPx ),
                olBounds = new OpenLayers.Bounds();
            olBounds.extend( minLonLat );
            olBounds.extend( maxLonLat );
            this.olMap.zoomToExtent( olBounds );
        },

        /**
         * Restricts the map extents to a particular bounding box. If no arg is
         * provided, this removes previous restrictions.
         * @memberof Map.prototype
         *
         * @param {Object} bounds - The bounding box to zoom to.
         */
        restrictExtent: function( bounds ) {
            if ( !bounds ) {
                this.olMap.restrictedExtent = null;
                this.olMap.zoomToMaxExtent();
                return;
            }
            var minViewportPx = MapUtil.getViewportPixelFromCoord( this, bounds.minX, bounds.minY ),
                maxViewportPx = MapUtil.getViewportPixelFromCoord( this, bounds.maxX, bounds.maxY ),
                minLonLat = this.olMap.getLonLatFromViewPortPx( minViewportPx ),
                maxLonLat = this.olMap.getLonLatFromViewPortPx( maxViewportPx ),
                olBounds = new OpenLayers.Bounds();
            olBounds.extend( minLonLat );
            olBounds.extend( maxLonLat );
            this.olMap.restrictedExtent = olBounds;
            this.olMap.zoomToExtent( olBounds );
        },

        /**
         * Pans the map to a particular coordinate. The transition is
         * animated if the region is currently in view, instantaneous if
         * not.
         * @memberof Map.prototype
         *
         * @param {number} x - The x coordinate (longitude for geospatial).
         * @param {number} y - The y coordinate (latitude for geospatial).
         */
        panTo: function( x, y ) {
            var viewportPx = MapUtil.getViewportPixelFromCoord( this, x, y ),
                lonlat = this.olMap.getLonLatFromViewPortPx( viewportPx );
            this.olMap.panTo( lonlat );
        },


        /**
         * Creates a marker at the specified position of the map.
         * @memberof Map.prototype
         *
         * @param {number} x - The x coordinate (longitude for geospatial).
         * @param {number} y - The y coordinate (latitude for geospatial).
         * @param {Marker} marker - The Marker object to add.
         *
         * @returns {Marker} The added marker.
         */
        addMarker: function( x, y, marker ) {
            if ( !this.olMarkers ) {
                this.olMarkers = new OpenLayers.Layer.Markers( "Markers" );
                this.olMap.addLayer( this.olMarkers );
            }
            // always update the z-index of this div
            $( this.olMarkers.div ).css( 'z-index', 5000 );
            marker.map = this;
            marker.activate( x, y );
            return marker;
        },

        /**
         * Removes a marker from the map.
         *
         * @param {OpenLayers.Marker} marker - The marker object.
         */
        removeMarker: function( marker ) {
            if ( this.olMarkers ) {
                marker.deactivate();
                marker.map = null;
            }
        },

        /**
         * Removes all markers from the map.
         */
        clearMarkers: function() {
            if ( this.olMarkers ) {
                this.olMarkers.clearMarkers();
            }
        },

        /**
         * Returns the width of the entire map in pixels.
         * @memberof Map.prototype
         *
         * @returns {integer} The width of the map in pixels.
         */
        getWidth: function() {
            return TILESIZE * Math.pow( 2, this.getZoom() );
        },

        /**
         * Returns the height of the entire map in pixels.
         * @memberof Map.prototype
         *
         * @returns {integer} The height of the map in pixels.
         */
        getHeight: function() {
            return TILESIZE * Math.pow( 2, this.getZoom() );
        },

        /**
         * Returns the width of the viewport in pixels.
         * @memberof Map.prototype
         *
         * @returns {integer} The width of the viewport in pixels.
         */
        getViewportWidth: function() {
            return this.olMap.viewPortDiv.clientWidth;
        },

        /**
         * Returns the height of the viewport in pixels.
         * @memberof Map.prototype
         *
         * @returns {integer} The height of the viewport in pixels.
         */
        getViewportHeight: function() {
            return this.olMap.viewPortDiv.clientHeight;
        },

        /**
         * Returns the maps current zoom level. Level 0 is contains the most
         * of aggregation.
         * @memberof Map.prototype
         *
         * @returns {integer} The zoom level.
         */
        getZoom: function () {
            return this.olMap.getZoom();
        },

        /**
         * Returns the x and y coordinates at the centre of the map.
         *
         * @return {OpenLayers.LonLat}
         */
        getCenterProjected: function() {
            return MapUtil.getCoordFromViewportPixel(
                this,
                this.getViewportWidth() / 2,
                this.getViewportHeight() / 2 );
        },

        /**
         * Get the top-left and bottom-right extents of the visible map.
         *
         * @return {Object}
         */
        getMapExtents: function() {
            return {
                topLeft: MapUtil.getCoordFromViewportPixel(
                    this,
                    0,
                    0 ),
                bottomRight: MapUtil.getCoordFromViewportPixel(
                    this,
                    this.getViewportWidth(),
                    this.getViewportHeight() )
            };
        },

        /**
         * Set a map event callback. Supports all of the following OpenLayers.Map events:
         * <pre>
         *     movestart - triggered after the start of a drag, pan, or zoom.  The event object may include a zoomChanged property that tells whether the zoom has changed.
         *     move - triggered after each drag, pan, or zoom
         *     moveend - triggered after a drag, pan, or zoom completes
         *     zoomstart - triggered when a zoom starts.  Listeners receive an object with center and zoom properties, for the target center and zoom level.
         *     zoomend - triggered after a zoom completes
         *     mouseover - triggered after mouseover the map
         *     mouseout - triggered after mouseout the map
         *     mousemove - triggered after mousemove the map
         * </pre>
         * @memberof Map.prototype
         *
         * @param {String} eventType - The event type.
         * @param {Function} callback - The callback.
         */
        on: function( eventType, callback ) {
            this.olMap.events.register( eventType, this.olMap, callback );
        },

        /**
         * Remove a map event callback. Supports all of the following OpenLayers.Map events:
         * <pre>
         *     movestart - triggered after the start of a drag, pan, or zoom.  The event object may include a zoomChanged property that tells whether the zoom has changed.
         *     move - triggered after each drag, pan, or zoom
         *     moveend - triggered after a drag, pan, or zoom completes
         *     zoomstart - triggered when a zoom starts.  Listeners receive an object with center and zoom properties, for the target center and zoom level.
         *     zoomend - triggered after a zoom completes
         *     mouseover - triggered after mouseover the map
         *     mouseout - triggered after mouseout the map
         *     mousemove - triggered after mousemove the map
         * </pre>
         * @memberof Map.prototype
         *
         * @param {String} eventType - The event type.
         * @param {Function} callback - The callback.
         */
        off: function( eventType, callback ) {
            this.olMap.events.unregister( eventType, this.olMap, callback );
        },

        /**
         * Trigger a map event. Supports all of the following OpenLayers.Map events:
         * <pre>
         *     movestart - triggered after the start of a drag, pan, or zoom.  The event object may include a zoomChanged property that tells whether the zoom has changed.
         *     move - triggered after each drag, pan, or zoom
         *     moveend - triggered after a drag, pan, or zoom completes
         *     zoomstart - triggered when a zoom starts.  Listeners receive an object with center and zoom properties, for the target center and zoom level.
         *     zoomend - triggered after a zoom completes
         *     mouseover - triggered after mouseover the map
         *     mouseout - triggered after mouseout the map
         *     mousemove - triggered after mousemove the map
         * </pre>
         * @memberof Map.prototype
         *
         * @param {String} eventType - The event type.
         * @param {Object} event - The event object to be passed to the event.
         */
        trigger: function( eventType, event ) {
            this.olMap.events.triggerEvent( eventType, event );
        }
    };

    module.exports = Map;
}());

},{"../binning/AreaOfInterestTilePyramid":2,"../binning/TileIterator":3,"../binning/WebMercatorTilePyramid":4,"../layer/BaseLayer":7,"../layer/Carousel":8,"../layer/Layer":15,"../layer/PendingLayer":18,"../util/PubSub":59,"./Axis":42,"./MapUtil":45}],45:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * A utility namespace containing map coordinate conversion functionality.
 */
( function() {

	"use strict";

	var Util = require('../util/Util'),
        getMapMinAndMaxInViewportPixels,
        TILESIZE = 256;

    /**
     * Private: Returns the maps min and max pixels in viewport pixels.
     *
     * @param map {Map} The map object.
     * NOTE:    viewport [0,0] is TOP-LEFT
     *          map [0,0] is BOTTOM-LEFT
     */
    getMapMinAndMaxInViewportPixels = function( map ) {
        var olMap = map.olMap;
		return {
			min: olMap.getViewPortPxFromLonLat(
					new OpenLayers.LonLat(
						olMap.maxExtent.left,
						olMap.maxExtent.bottom ) ),
			max: olMap.getViewPortPxFromLonLat(
					new OpenLayers.LonLat(
						olMap.maxExtent.right,
						olMap.maxExtent.top ) )
		};
    };

    module.exports = {

        /**
		 * Transforms a point from data coordinates to viewport pixel coordinates
         *
         * @param map {Map}    The map object.
         * @param x   {number} The x coordinate of the data.
         * @param y   {number} The y coordinate of the data.
		 * NOTE:    viewport [0,0] is TOP-LEFT
		 *          data [0,0] is BOTTOM-LEFT
		 */
		getViewportPixelFromCoord: function( map, x, y ) {
			var mapPixel = this.getMapPixelFromCoord( map, x, y );
			return this.getViewportPixelFromMapPixel( map, mapPixel.x, mapPixel.y );
		},

		/**
		 * Transforms a point from map pixel coordinates to viewport pixel coordinates
         *
         * @param map {Map}    The map object.
         * @param mx  {number} The x pixel coordinate of the map.
         * @param my  {number} The y pixel coordinate of the map.
		 * NOTE:    viewport [0,0] is TOP-LEFT
		 *          map [0,0] is BOTTOM-LEFT
		 */
		getViewportPixelFromMapPixel: function( map, mx, my ) {
			var viewportMinMax = getMapMinAndMaxInViewportPixels( map );
			return {
				x: mx + viewportMinMax.min.x,
				y: map.getWidth() - my + viewportMinMax.max.y
			};
		},

		/**
		 * Transforms a point from data coordinates to map pixel coordinates
         *
         * @param map {Map} The map object.
         * @param x   {int} The x coordinate of the data.
         * @param y   {int} The y coordinate of the data.
		 * NOTE:    data and map [0,0] are both BOTTOM-LEFT
		 */
		getMapPixelFromCoord: function( map, x, y ) {
			var tile = map.pyramid.rootToFractionalTile( x, y, map.getZoom(), TILESIZE ),
			    bin = map.pyramid.rootToFractionalBin( x, y, tile);
			return {
				x: tile.xIndex * TILESIZE + bin.x,
				y: tile.yIndex * TILESIZE + TILESIZE - 1 - bin.y
			};
		},

		/**
		 * Transforms a point from viewport pixel coordinates to map pixel coordinates
         *
         * @param map {Map} The map object.
         * @param vx  {int} The x pixel coordinate of the viewport.
         * @param vy  {int} The y pixel coordinate of the viewport.
		 * NOTE:    viewport [0,0] is TOP-LEFT
		 *          map [0,0] is BOTTOM-LEFT
		 */
		getMapPixelFromViewportPixel: function( map, vx, vy ) {
            var viewportMinMax = getMapMinAndMaxInViewportPixels( map ),
			    totalPixelSpan = map.getWidth();
            return {
				x: totalPixelSpan + vx - viewportMinMax.max.x,
				y: totalPixelSpan - vy + viewportMinMax.max.y
			};
		},

		/**
		 * Transforms a point from map pixel coordinates to data coordinates
         *
         * @param map {Map}    The map object.
         * @param mx  {number} The x pixel coordinate of the map.
         * @param my  {number} The y pixel coordinate of the map.
		 * NOTE:    data and map [0,0] are both BOTTOM-LEFT
		 */
		getCoordFromMapPixel: function( map, mx, my ) {
            var tileAndBin = this.getTileAndBinFromMapPixel( map, mx, my, TILESIZE, TILESIZE ),
			    bounds = map.pyramid.getBinBounds( tileAndBin.tile, tileAndBin.bin );
			return {
				x: bounds.minX,
				y: bounds.minY
			};
		},

		/**
		 * Transforms a point from viewport pixel coordinates to data coordinates
         *
         * @param map {Map} The map object.
         * @param vx  {int} The x pixel coordinate of the viewport.
         * @param vy  {int} The y pixel coordinate of the viewport.
		 * NOTE:    viewport [0,0] is TOP-LEFT
		 *          data [0,0] is BOTTOM-LEFT
		 */
		getCoordFromViewportPixel: function( map, vx, vy ) {
			var mapPixel = this.getMapPixelFromViewportPixel( map, vx, vy );
			return this.getCoordFromMapPixel( map, mapPixel.x, mapPixel.y );
		},

		/**
		 * Returns the tile and bin index corresponding to the given viewport pixel coordinate
         *
         * @param map {Map} The map object.
         * @param vx  {int} The x pixel coordinate of the viewport.
         * @param vy  {int} The y pixel coordinate of the viewport.
         * @param xBinCount {int} The number of bins in the x dimension of the tile.
         * @param yBinCount {int} The number of bins in the y dimension of the tile.
		 */
		getTileAndBinFromViewportPixel: function( map, vx, vy, xBinCount, yBinCount ) {
			var mapPixel = this.getMapPixelFromViewportPixel( map, vx, vy );
			return this.getTileAndBinFromMapPixel( map, mapPixel.x, mapPixel.y, xBinCount, yBinCount );
		},

		/**
         * Returns the tile and bin index corresponding to the given map pixel coordinate
         *
         * @param map {Map}    The map object.
         * @param mx  {number} The x pixel coordinate of the map.
         * @param my  {number} The y pixel coordinate of the map.
         * @param xBinCount {int} The number of bins in the x dimension of the tile.
         * @param yBinCount {int} The number of bins in the y dimension of the tile.
         */
        getTileAndBinFromMapPixel: function( map, mx, my, xBinCount, yBinCount ) {
            var tileIndexX = Math.floor( mx / TILESIZE ),
                tileIndexY = Math.floor( my / TILESIZE ),
                tilePixelX = Util.mod( mx , TILESIZE ),
                tilePixelY = Util.mod( my, TILESIZE );
            return {
                tile: {
                    level : map.getZoom(),
                    xIndex : tileIndexX,
                    yIndex : tileIndexY,
                    xBinCount : xBinCount,
                    yBinCount : yBinCount
                },
                bin: {
                    x : Math.floor( tilePixelX / (TILESIZE / xBinCount ) ),
                    y : (yBinCount - 1) - Math.floor( tilePixelY / (TILESIZE / yBinCount) ) // bin [0,0] is top left
                }
            };
        },

        /**
		 * Returns the tile and bin index corresponding to the given data coordinate
         *
         * @param map {Map} The map object.
         * @param x   {int} The x coordinate of the data.
         * @param y   {int} The y coordinate of the data.
         * @param xBinCount {int} The number of bins in the x dimension of the tile.
         * @param yBinCount {int} The number of bins in the y dimension of the tile.
		 */
		getTileAndBinFromCoord: function( map, x, y, xBinCount, yBinCount ) {
			var mapPixel = this.getMapPixelFromCoord( map, x, y );
			return this.getTileAndBinFromMapPixel( map, mapPixel.x, mapPixel.y, xBinCount, yBinCount );
		},

        /**
         * Returns the top left pixel location in viewport coordinates from a tilekey..
         *
         * @param map     {Map}    The map object.
         * @param tilekey {string} The tilekey.
         */
        getTopLeftViewportPixelForTile: function( map, tilekey ) {
            var mapPixel = this.getTopLeftMapPixelForTile( map, tilekey );
            return this.getViewportPixelFromMapPixel( map, mapPixel.x, mapPixel.y );
        },

        /**
         * Returns the top left pixel location in viewport coord from a tile index.
         *
         * @param map     {Map}    The map object.
         * @param tilekey {string} The tilekey.
         */
        getTopLeftMapPixelForTile: function( map, tilekey ) {
            var parsedValues = tilekey.split( ',' ),
                x = parseInt( parsedValues[1], 10 ),
                y = parseInt( parsedValues[2], 10 ),
                mx = x * TILESIZE,
                my = y * TILESIZE + TILESIZE;
            return {
                x : mx,
                y : my
            };
        },

        /**
         * Returns the data coordinate value corresponding to the top left pixel of the tile
         *
         * @param map     {Map}    The map object.
         * @param tilekey {string} The tilekey.
         */
        getTopLeftCoordForTile: function( map, tilekey ) {
            var mapPixel = this.getTopLeftMapPixelForTile( map, tilekey );
            return this.getCoordFromMapPixel( map, mapPixel.x, mapPixel.y );
        }

	};
}());

},{"../util/Util":60}],46:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var MapUtil = require('./MapUtil');

    /**
     * Instantiate a Marker object.
     * @class Marker
     * @classdesc A marker object that is pinned to the map.
     */
    function Marker( imgUrl, imgWidth, imgHeight ) {
        this.width = imgWidth || 50;
        this.height = imgHeight || 50;
        this.icon = new OpenLayers.Icon(
            imgUrl,
            new OpenLayers.Size( this.width, this.height ),
            new OpenLayers.Pixel( -this.width/2, -this.height ) );
    }

    Marker.prototype = {

        /**
         * Activates the marker object. This should never be called manually.
         * @memberof Marker
         * @private
         */
        activate: function( x, y ) {
            this.x = x;
            this.y = y;
            var viewportPx = MapUtil.getViewportPixelFromCoord( this.map, x, y ),
                lonlat = this.map.olMap.getLonLatFromViewPortPx( viewportPx );
            this.olMarker = new OpenLayers.Marker( lonlat, this.icon.clone() );
            this.map.olMarkers.addMarker( this.olMarker );
        },

        /**
         * De-activates the marker object. This should never be called manually.
         * @memberof Marker
         * @private
         */
        deactivate: function() {
            if ( this.olMarker && this.map.olMarkers ) {
                this.map.olMarkers.removeMarker( this.olMarker );
                this.olMarker.destroy();
                this.olMarker = null;
                this.x = null;
                this.y = null;
            }
        },

        /**
         * Returns the markers div element.
         * @memberof Map.prototype
         *
         * @returns {HTMLElement} The marker div.
         */
        getElement: function() {
            if ( this.olMarker ) {
                return this.olMarker.icon.imageDiv;
            }
            return null;
        }

    };

    module.exports = Marker;
}());

},{"./MapUtil":45}],47:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * @namespace AnnotationService
 * @classdesc A utility namespace that provides annotation service REST functionality.
 */
( function() {

    "use strict";

    var Util = require('../util/Util');

    module.exports = {

        /**
         * Get a tiles worth of annotations from the server. Upon success, will execute success
         * callback function passing the resulting object as first argument.
         * @memberof AnnotationService
         *
         * @param {String} layerId - The annotation layer identification string.
         * @param {integer} level - The zoom level.
         * @param {integer} x - The tile x index.
         * @param {integer} y - The tile y index.
         * @param {Object} params - The query parameter configuration overrides (optional).
         * @param {Function} success - The callback function executed after success received (optional).
         */
        getTileJSON: function( layerId, level, x, y, params, success ) {
            var _params = ( typeof params === "object" ) ? params : null,
                _success = ( typeof success === "function" )
                    ? success
                    : ( typeof params === "function" )
                        ? params
                        : null;
            $.get(
                'rest/v1.0/annotation/'
                + layerId + "/"
                + level + "/"
                + x + "/"
                + y + ".json" + Util.encodeQueryParams( _params )
            ).then(
                _success,
                Util.handleHTTPError
            );
        },

        /**
         * Write an annotation to the server. Upon success, will execute success
         * callback function passing the resulting certificate as first argument.
         * @memberof AnnotationService
         *
         * @param {String} layerId - The annotation layer identification string.
         * @param {Object} annotation - The annotation to be written.
         * @param {Function} success - The callback function executed after success received (optional).
         */
        writeAnnotation: function( layerId, annotation, success ) {
            var _success = ( typeof success === "function" ) ? success : null;
            $.post(
                'rest/v1.0/annotation',
                JSON.stringify({
                    type: "write",
                    annotation: annotation,
                    layer: layerId
                })
            ).then(
                _success,
                Util.handleHTTPError
            );
        },

        /**
         * Modify an annotation on the server. Upon success, will execute success
         * callback function passing the resulting certificate as first argument.
         * @memberof AnnotationService
         *
         * @param {String} layerId - The annotation layer identification string.
         * @param {Object} annotation - The annotation to be modified.
         * @param {Function} success - The callback function executed after success received (optional).
         */
        modifyAnnotation: function( layerId, annotation, success ) {
            var _success = ( typeof success === "function" ) ? success : null;
            $.post(
                'rest/v1.0/annotation',
                JSON.stringify({
                    type: "modify",
                    annotation: annotation,
                    layer: layerId
                })
            ).then(
                _success,
                Util.handleHTTPError
            );
        },

        /**
         * Remove an annotation from the server.
         * @memberof AnnotationService
         *
         * @param {String} layerId - The annotation layer identification string.
         * @param {Object} certificate - The certificate of the annotation to be removed.
         * @param {Function} success - The callback function executed after success received (optional).
         */
        removeAnnotation: function( layerId, certificate, success ) {
            var _success = ( typeof success === "function" ) ? success : null;
            $.post(
                'rest/v1.0/annotation',
                JSON.stringify({
                    type: "remove",
                    certificate: certificate,
                    layer: layerId
                })
            ).then(
                _success,
                Util.handleHTTPError
            );
        }

    };
}());

},{"../util/Util":60}],48:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * @namespace LayerService
 * @classdesc A utility namespace that provides layer service REST functionality.
 */
( function() {

    "use strict";

    var Util = require('../util/Util');

    module.exports = {

        /**
         * Request all layers from the server. Upon success, will execute success
         * callback function passing the resulting object as first argument.
         * @memberof LayerService
         *
         * @param {Function} success - The callback function executed after success received (optional).
         */
        getLayers: function( success ) {
            var _success = ( typeof success === "function" ) ? success : null;
            $.get(
                'rest/v1.0/layers'
            ).then(
                _success,
                Util.handleHTTPError
            );
        },

        /**
         * Request a specific layer from the server. Upon success, will execute success
         * callback function passing the resulting object as first argument.
         * @memberof LayerService
         *
         * @param {String} layerId - The layer identification string.
         * @param {Function} success - The callback function executed after success received (optional).
         */
        getLayer: function( layerId, success ) {
            var _success = ( typeof success === "function" ) ? success : null;
            $.get(
                'rest/v1.0/layers/' + layerId
            ).then(
                _success,
                Util.handleHTTPError
            );
        },

        /**
         * Store a configuration state on the server. Upon success, will execute success
         * callback function passing the resulting object as first argument.
         * @memberof LayerService
         *
         * @param {String} layerId - The layer identification string.
         * @param {Object} params - The parameter configuration overrides (optional).
         * @param {Function} success - The callback function executed after success received (optional).
         */
        saveLayerState: function( layerId, params, success ) {
            var _success = ( typeof success === "function" ) ? success : null;
            $.post(
                'rest/v1.0/layers/' + layerId + '/states',
                JSON.stringify( params )
            ).then(
                _success,
                Util.handleHTTPError
            );
        },

        /**
         * Get all configuration states for a layer on the server. Upon success, will execute
         * success callback function passing the resulting object as first argument.
         * @memberof LayerService
         *
         * @param {String} layerId - The layer identification string.
         * @param {Function} success - The callback function executed after success received (optional).
         */
        getLayerStates: function( layerId, success ) {
            var _success = ( typeof success === "function" ) ? success : null;
            $.get(
                'rest/v1.0/layers/' + layerId + '/states'
            ).then(
                _success,
                Util.handleHTTPError
            );
        },

        /**
         * Get a configuration state for a layer on the server by state id. Upon success,
         * will execute success callback function passing the resulting object as first argument.
         * @memberof LayerService
         *
         * @param {String} layerId - The layer identification string.
         * @param {String} stateId - The state identification string.
         * @param {Function} success - The callback function executed after success received (optional).
         */
        getLayerState: function( layerId, stateId, success ) {
            var _success = ( typeof success === "function" ) ? success : null;
            $.get(
                'rest/v1.0/layers/' + layerId + '/states/' + stateId
            ).then(
                _success,
                Util.handleHTTPError
            );
        }
    };
}());

},{"../util/Util":60}],49:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/**
 * @namespace LegendService
 * @classdesc A utility namespace that provides legend service REST functionality.
 */
( function() {

    "use strict";

    var Util = require('../util/Util');

    module.exports = {

        /**
         * Get an encoded image string representing the rendering legend. Upon success,
         * will execute success callback function passing the resulting string as first
         * argument.
         * @memberof LegendService
         *
         * @param {String} layerId - The layer identification string.
         * @param {Object} params - The query parameter configuration overrides (optional).
         * @param {Function} success - The callback function executed after success received (optional).
         */
        getEncodedImage: function( layerId, params, success ) {
            var _params = ( typeof params === "object" ) ? params : null,
                _success = ( typeof success === "function" )
                    ? success
                    : ( typeof params === "function" )
                        ? params
                        : null;
            $.get(
                'rest/v1.0/legend/' + layerId + Util.encodeQueryParams( _params )
            ).then(
                _success,
                Util.handleHTTPError
            );
        },

        /**
         * Get a png image representing the rendering legend.
         * @memberof LegendService
         *
         * @param {String} layerId - The layer identification string.
         * @param {Object} params - The query parameter configuration overrides (optional).
         * @param {Function} success - The callback function executed after success received (optional).
         */
        getImage: function( layerId, params, success ) {
            var _params = ( typeof params === "object" ) ? params : {},
                _success = ( typeof success === "function" )
                    ? success
                    : ( typeof params === "function" )
                        ? params
                        : null;
            // explicitly set output type to png image
            _params.output = 'png';
            $.get(
                'rest/v1.0/legend/' + layerId + Util.encodeQueryParams( _params )
            ).then(
                _success,
                Util.handleHTTPError
            );
        }
    };
}());

},{"../util/Util":60}],50:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * @namespace TileService
 * @classdesc A utility namespace that provides tile service REST functionality.
 */
( function() {
    
    "use strict";

    var Util = require('../util/Util');

    module.exports = {

        /**
         * Get a tile worth of data in JSON format. Upon success, will execute success
         * callback function passing the resulting object as first argument.
         * @memberof TileService
         *
         * @param {String} layerId - The layer identification string.
         * @param {integer} level - The zoom level.
         * @param {integer} x - The tile x index.
         * @param {integer} y - The tile y index.
         * @param {Object} params - The query parameter configuration overrides (optional).
         * @param {Function} success - The callback function executed after success received (optional).
         */
        getTileJSON: function( layerId, level, x, y, params, success ) {
            var _params = ( typeof params === "object" ) ? params : null,
                _success = ( typeof success === "function" )
                    ? success
                    : ( typeof params === "function" )
                        ? params
                        : null;
            $.get(
                'rest/v1.0/tile/'
                + layerId + "/"
                + level + "/"
                + x + "/"
                + y + ".json" + Util.encodeQueryParams( _params )
            ).then(
                _success,
                Util.handleHTTPError
            );
        },

        /**
         * Get a tile rendered as an image. Upon success, will execute success
         * callback function passing the resulting object as first argument.
         * @memberof TileService
         *
         * @param {String} layerId - The layer identification string.
         * @param {integer} level - The zoom level.
         * @param {integer} x - The tile x index.
         * @param {integer} y - The tile y index.
         * @param {Object} params - The query parameter configuration overrides (optional).
         * @param {Function} success - The callback function executed after success received (optional).
         */
        getTileImage: function( layerId, level, x, y, params, success ) {
            var _params = ( typeof params === "object" ) ? params : null,
                _success = ( typeof success === "function" )
                    ? success
                    : ( typeof params === "function" )
                        ? params
                        : null;
            $.get(
                'rest/v1.0/tile/'
                + layerId + "/"
                + level + "/"
                + x + "/"
                + y + ".png" + Util.encodeQueryParams( _params )
            ).then(
                _success,
                Util.handleHTTPError
            );
        }
    };
}());

},{"../util/Util":60}],51:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 * 
 * Released under the MIT License.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var PubSub = require('../util/PubSub');

    module.exports = {

        /**
         * Creates a coarseness dropdown menu and binds it to the provided layer.
         *
         * @param {Layer} layer - The layer object.
         *
         * @returns {JQuery} - The JQuery element.
         */
        create: function( layer ) {
            var $coarsenessControls = $( '<div class="coarseness-controls"></div>' ),
                $coarsenessLabel = $( '<div class="controls-label">Coarseness</div>' ),
                $coarsenessMenu = $( '<div class="control-menu">' ),
                $menuItems = $('<ul class="dropdown-menu"></ul>'),
                setCoarseness = function() {
                    layer.setCoarseness( $( this ).data( 'coarseness' ) );
                    $menuItems.children().each( function() {
                        $( this ).removeClass( 'active' );
                    });
                    $( this ).addClass( 'active' );
                },
                updateMenu = function( coarseness ) {
                    $menuItems.children().each( function() {
                        $( this ).removeClass( 'active' );
                        if ( $( this ).data( 'coarseness' ) === coarseness ) {
                            $( this ).addClass( 'active' );
                        }
                    });
                },
                items = [
                    {
                        id: 1,
                        name: "1x1"
                    },
                    {
                        id: 2,
                        name: "2x2"
                    },
                    {
                        id: 3,
                        name: "4x4"
                    },
                    {
                        id: 4,
                        name: "8x8"
                    }],
                $item,
                i;
            $menuItems.click( function() {
                $menuItems.toggleClass("dropdown-menu-open");
            });
            for ( i=0; i<items.length; i++ ) {
                $item = $( 
                    '<li class="menu-item">'+
                        '<a href="#" class="menu-item-link">'+items[i].name+'</a>'+
                    '</li>' );
                $item.data( 'coarseness', items[i].id );
                $item.click( setCoarseness );
                $menuItems.append( $item );
            }
            updateMenu( layer.getCoarseness() );
            PubSub.subscribe( layer.getChannel(), function( message ) {
                if ( message.field === "coarseness" ) {
                    updateMenu( message.value );
                }
            });
            $coarsenessControls.append( $coarsenessLabel );
            $coarsenessControls.append( $coarsenessMenu.append( $menuItems ) );
            return $coarsenessControls;
        }

    };

}());
},{"../util/PubSub":59}],52:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var SliderUtil = require('./SliderUtil'),
        Util = require('../util/Util'),
        AxisUtil = require('../map/AxisUtil'),
        PubSub = require('../util/PubSub');

    function createFilterAxis( minMax, transform ) {
        var NUM_MAJOR_MARKERS = 5;
        return $( '<div class="filter-axis"></div>' )
            .append( createAxisMarkers( NUM_MAJOR_MARKERS ) )
            .append( createAxisLabels( NUM_MAJOR_MARKERS, minMax, transform ) );
    }

    function createAxisMarkers( numMajorMarkers ) {
        var $container = $('<div class="filter-axis-ticks-container"></div>'),
            numMarkers = (numMajorMarkers-1)*2,
            margin = 100/numMarkers,
            isMajor = true,
            i;
        for( i = 0; i<numMarkers; i++ ) {
            if ( isMajor ) {
                $container.append( '<div class="filter-axis-marker filter-major-marker" style="margin-right:calc('+margin+'% - 1px);"></div>' );
            } else {
                $container.append( '<div class="filter-axis-marker filter-minor-marker" style="margin-right:calc('+margin+'% - 1px);"></div>' );
            }
            isMajor = !isMajor;
        }
        $container.append( '<div class="filter-axis-marker filter-major-marker" style="margin-left:-1px;"></div>' );
        return $container;
    }

    function createAxisLabels( numMajorMarkers, minMax, transform ){
        var $container = $('<div class="filter-axis-label-container"></div>'),
            margin = 100/(numMajorMarkers-1),
            options = {
                'stepDown' : true,
                'decimals' : 1,
                'type': 'b'
            },
            val,
            i;
        for ( i = 0; i<numMajorMarkers; i++ ) {
            val = Util.denormalizeValue( i / (numMajorMarkers-1), minMax, transform );
            $container.append(
                $( '<div class="filter-axis-label" style="position:absolute; left:'+(margin*i)+'%; width:'+margin+'%; margin-left:-'+(margin/2)+'%;">'+
                      AxisUtil.formatText( val, options ) +
                  '</div>' )
            );
        }
        return $container;
    }

    module.exports = {

        /**
         * Creates a filter jquery-ui slider and binds it to the provided layer.
         *
         * @param {Layer} layer - The layer object.
         *
         * @returns {JQuery} - The JQuery element.
         */
        create: function( layer ) {
            var $filterControls = $( '<div class="filter-controls"></div>' ),
                $filterLabel = $( '<div class="controls-label">Filter</div>' ),
                $sliderBorder = $( '<div class="slider-border">' ),
                $filterSlider = $( '<div class="filter-slider"></div>' ),
                MIN_VAL = 0,
                MAX_VAL = 100;
            $filterSlider.slider({
                range: true,
                min: MIN_VAL,
                max: MAX_VAL,
                values: [
                    layer.getRangeMinPercentage() * MAX_VAL,
                    layer.getRangeMaxPercentage() * MAX_VAL
                ],
                change: function () {
                    var result = $( this ).slider( "option", "values" );
                    // set by percentage
                    layer.setRangeMinPercentage( result[0] / MAX_VAL );
                    layer.setRangeMaxPercentage( result[1] / MAX_VAL );
                },
                slide: function( event, ui ) {
                    var handleIndex = $( ui.handle ).index() - 1,
                        values = ui.values,
                        value = Util.denormalizeValue(
                            values[ handleIndex ] / MAX_VAL,
                            layer.getLevelMinMax(),
                            layer.getValueTransformType() );
                    SliderUtil.createLabel( $( $filterSlider[0].children[ 1 + handleIndex ] ), value );
                },
                start: function( event, ui ) {
                    var handleIndex = $(ui.handle).index() - 1,
                        values = ui.values,
                        value = Util.denormalizeValue(
                            values[ handleIndex ] / MAX_VAL,
                            layer.getLevelMinMax(),
                            layer.getValueTransformType() );
                    SliderUtil.createLabel( $( $filterSlider[0].children[ 1 + handleIndex ] ), value );
                },
                stop: function( event, ui ) {
                    var handleIndex = $(ui.handle).index() - 1,
                        $handle = $( $filterSlider[0].children[ 1 + handleIndex ] );
                    if ( !$handle.is(':hover') ) {
                        // normally this label is removed on mouse out, in the case that
                        // the user has moused out while dragging, this will cause the label to
                        // be removed
                        SliderUtil.removeLabel( $handle );
                    }
                }
            });
            // bind slider label mouseover and mouseout callbacks to each handle of the slider
            $filterSlider.find( '.ui-slider-handle' ).each( function( index, elem ) {
                $( elem ).mouseover( function() {
                    var value = ( index === 0 ) ? layer.getRangeMinValue() : layer.getRangeMaxValue();
                    SliderUtil.createLabel( $( this ), value );
                });
                $( elem ).mouseout( function() {
                    SliderUtil.removeLabel( $( this ) );
                });
            });
            $filterSlider.append( createFilterAxis( layer.getLevelMinMax(), layer.getValueTransformType() ) );
            $filterSlider.find( '.ui-slider-handle' ).first().addClass( "filter-min-handle" );
            $filterSlider.find( '.ui-slider-handle' ).last().addClass( "filter-max-handle" );
            $filterControls.append( $filterLabel );
            $filterControls.append( $sliderBorder.append( $filterSlider ) );
            PubSub.subscribe( layer.getChannel(), function( message ) {
                switch ( message.field ) {

                    case 'rangeMin':

                        $filterSlider.slider( 'values', 0, layer.getRangeMinPercentage() * MAX_VAL );
                        break;

                    case 'rangeMax':

                        $filterSlider.slider( 'values', 1, layer.getRangeMaxPercentage() * MAX_VAL );
                        break;

                    case 'rampImageUrl':

                        $filterSlider.find( ".ui-slider-range" ).css({
                            "background": "url(" + message.value + ")",
                            "background-size": "contain"
                        });
                        break;

                    case 'levelMinMax':

                        $filterSlider.find( ".filter-axis" ).replaceWith(
                            createFilterAxis( layer.getLevelMinMax(), layer.getValueTransformType() )
                        );
                        break;
                }
            });
            return $filterControls;
        }
    };

}());

},{"../map/AxisUtil":43,"../util/PubSub":59,"../util/Util":60,"./SliderUtil":58}],53:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 * 
 * Released under the MIT License.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var LayerEntry = require('./LayerEntry');

    module.exports = {
        /**
         * Creates a minimal layer controls UI component and binds it to all provided layers.
         *
         * @param {Array} layers - The array of layers.
         *
         * @returns {JQuery} The layers control element.
         */

        create: function( layers ) {
            var $controls = $( '<div class="tiles-layer-controls"></div>' );
            _.forEach( layers, function( layer ) {
                $controls.append( LayerEntry.create( layer ) );
            });
            return $controls;
        }
    };

}());
},{"./LayerEntry":54}],54:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 * 
 * Released under the MIT License.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var LayerEntryHead = require('./LayerEntryHead'),
        LayerEntryBody = require('./LayerEntryBody'),
        PubSub = require('../util/PubSub');

    module.exports = {

        /**
         * Creates the UI component that holds the controls header and body for a layer.
         *
         * @param {Layer} layer - The layer object.
         *
         * @returns {JQuery} - The JQuery element.
         */
        create: function( layer ) {
            var $layerEntry = $( '<div class="layer-entry"></div>' ),
                $layerHeader = LayerEntryHead.create( layer ),
                $layerBody = LayerEntryBody.create( layer );
            PubSub.subscribe( layer.getChannel(), function( message ) {
                if ( message.field === "enabled" ) {
                    if ( message.value ) {
                        $layerBody.css( 'display', "" );
                    } else {
                        $layerBody.css( 'display', "none" );
                    }
                }
            });
            if ( layer.isEnabled() ) {
                $layerBody.css( 'display', "" );
            } else {
                $layerBody.css( 'display', "none" );
            }
            $layerEntry.append( $layerHeader );
            $layerEntry.append( $layerBody );
            return $layerEntry;
        }

    };

}());
},{"../util/PubSub":59,"./LayerEntryBody":55,"./LayerEntryHead":56}],55:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 * 
 * Released under the MIT License.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var OpacityControls = require('./OpacityControls'),
        FilterControls = require('./FilterControls'),
        CoarsenessControls = require('./CoarsenessControls');

    module.exports = {

        /**
         * Creates the UI component that holds the controls for a layer.
         *
         * @param {Layer} layer - The layer object.
         *
         * @returns {JQuery} - The JQuery element.
         */
        create: function( layer ) {
            var $entryBody = $( '<div class="layer-entry-body"></div>' );
            if ( layer.domain === "client" || layer.domain === "annotation" ) {
                $entryBody.append( OpacityControls.create( layer ).addClass( 'opacity-controls-client' ) );
            } else {
                $entryBody.append( OpacityControls.create( layer ).addClass( 'opacity-controls-server' ) );
                $entryBody.append( FilterControls.create( layer ) );
                $entryBody.append( CoarsenessControls.create( layer ) );
            }
            $entryBody.append( '<div class="clear"></div>');
            return $entryBody;
        }

    };

}());
},{"./CoarsenessControls":51,"./FilterControls":52,"./OpacityControls":57}],56:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 * 
 * Released under the MIT License.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var PubSub = require('../util/PubSub');

    module.exports = {

        /**
         * Creates the UI component that holds the layer controls header.
         *
         * @param {Layer} layer - The layer object.
         *
         * @returns {JQuery} - The JQuery element.
         */
        create: function( layer ) {
            var ENABLED_CLASS = 'fa-check-square-o',
                DISABLED_CLASS = 'fa-square-o',
                iconClass = layer.isEnabled() ? ENABLED_CLASS : DISABLED_CLASS,
                $layerHeader = $( '<div class="layer-entry-head"></div>' ),
                $layerToggleIcon = $( '<i class="fa '+iconClass+'"></i>'),
                $layerToggleButton = $('<div class="layer-toggle"></div>'),
                $layerTitle = $( '<div class="layer-title">'+layer.source.name+'</div>');

            $layerHeader.click( function() {
                if ( layer.isEnabled() ) {
                    layer.setEnabled( false );
                } else {
                    layer.setEnabled( true );
                }              
            });
            PubSub.subscribe( layer.getChannel(), function( message ) {
                if ( message.field === "enabled" ) {
                    if ( message.value ) {
                        $layerToggleIcon.removeClass( DISABLED_CLASS );
                        $layerToggleIcon.addClass( ENABLED_CLASS );
                    } else {
                        $layerToggleIcon.removeClass( ENABLED_CLASS );
                        $layerToggleIcon.addClass( DISABLED_CLASS );
                    } 
                }
            });
            $layerHeader.append( $layerToggleButton.append( $layerToggleIcon ) );
            $layerHeader.append( $layerTitle );
            return $layerHeader;
        }
    };

}());
},{"../util/PubSub":59}],57:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 * 
 * Released under the MIT License.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    "use strict";

    var SliderUtil = require('./SliderUtil'),
        PubSub = require('../util/PubSub');

    module.exports = {

        /**
         * Creates an opacity jquery-ui slider and binds it to the provided layer.
         *
         * @param {Layer} layer - The layer object.
         *
         * @returns {JQuery} - The JQuery element.
         */
        create: function( layer ) {
            var $opacityControls = $( '<div class="opacity-controls"></div>' ),
                $opacityLabel = $( '<div class="controls-label">Opacity</div>' ),
                $sliderBorder = $( '<div class="slider-border">' ),
                $opacitySlider = $( '<div class="opacity-slider"></div>' ),
                MIN_VAL = 0,
                MAX_VAL = 100;
            $opacitySlider.slider({
                range: "min",
                min: MIN_VAL,
                max: MAX_VAL,
                value: layer.getOpacity() * MAX_VAL,
                slide: function( event, ui ) {
                    $( '.olTileImage' ).addClass( 'no-transition' );
                    $( '.olTileHtml' ).addClass( 'no-transition' );
                    layer.setOpacity( ui.value / MAX_VAL );
                    SliderUtil.createLabel( $( this ).find(".ui-slider-handle"), ui.value / MAX_VAL );
                },
                start: function( event, ui ) {
                    SliderUtil.createLabel( $( this ).find(".ui-slider-handle"), ui.value / MAX_VAL );
                },
                stop: function() {
                    var $handle = $( this ).find(".ui-slider-handle");
                    if ( !$handle.is(':hover') ) {
                        // normally this label is removed on mouse out, in the case that
                        // the user has moused out while dragging, this will cause the label to
                        // be removed
                        SliderUtil.removeLabel( $handle );
                    }                       
                    $( '.olTileImage' ).removeClass( 'no-transition' );
                    $( '.olTileHtml' ).removeClass( 'no-transition' );
                }
            });   
            // bind slider label mouseover and mouseout callbacks
            $opacitySlider.find( ".ui-slider-handle" ).mouseover( function() {
                SliderUtil.createLabel( $( this ), layer.getOpacity() );
            });
            $opacitySlider.find( ".ui-slider-handle" ).mouseout( function() {
                SliderUtil.removeLabel( $( this ) );
            });
            PubSub.subscribe( layer.getChannel(), function( message ) {
                if ( message.field === "opacity" ) {
                    $opacitySlider.slider('value', layer.getOpacity()*MAX_VAL );
                }
            });
            $opacityControls.append( $opacityLabel );
            $opacityControls.append( $sliderBorder.append( $opacitySlider ) );
            return $opacityControls;
        }
    };

}());
},{"../util/PubSub":59,"./SliderUtil":58}],58:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

( function() {

    'use strict';

    var AxisUtil = require('../map/AxisUtil');

    module.exports = {

        /**
         * Creates and appends a label to the supplied element.
         *
         * @param {jQuery} $elem - The element to which the label is appended onto.
         * @param {number} value - The value to be written on the label.
         */
        createLabel: function( $elem, value ) {
            var options = {
                    'stepDown' : true,
                    'decimals' : 2,
                    'type': 'b'
                },
                $label = $('<div class="hover-label" style="left:'+ ($elem.width()/2) +'px; top:0px;">'+
                              '<div class="hover-label-text">'+ AxisUtil.formatText( value, options ) +'</div>'+
                           '</div>');
            // remove previous label if it exists
            $elem.find('.hover-label').finish().remove();
            // add new label
            $elem.append( $label );
            // reposition to be centred above cursor
            $label.css( {"margin-top": -$label.outerHeight()*1.2, "margin-left": -$label.outerWidth()/2 } );
        },

        /**
         * Removes a label from the element. Fades the element out first.
         *
         * @param {jQuery} $elem - The element to which the label is appended onto.
         */
        removeLabel: function( $elem ) {
            $elem.find('.hover-label').animate({
                    opacity: 0
                },
                {
                    complete: function() {
                        $elem.find('.hover-label').remove();
                    },
                    duration: 800
                }
            );
        }

    };

}());

},{"../map/AxisUtil":43}],59:[function(require,module,exports){
/**
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * @namespace PubSub
 * @classdesc A hierarchical publish and subscribe namespace. Channels consist of strings, sub-channels
 * are separated with a period ('.'). Publishing to a target channel will propagate the message
 * breadth first from the root of the hierarchy to the target channel, then from the target channel to
 * all its existing sub-channels.
 * <pre>
 * Ex.
 *
 *     Hierarchy:
 *
 *         layer -> server -> abc28d05-9b9d-4e03-9f53-9f88cf7078c7
 *                            fb943cca-cac3-4bbf-ba03-91a1559fee28
 *                            67fd55b5-dc3a-40cf-8adc-9e634b82d474
 *                  client -> 3392103f-7f50-4422-ae59-2c2c0971951f
 *                            7bc33c81-c347-4bea-9cfb-c22328bcb648
 *
 *     Publishing to 'layer.server' will publish:
 *
 *         From root to target:
 *
 *             1) layer
 *
 *     From target to all sub-channels:
 *
 *             2) layer.server
 *             3) layer.server.abc28d05-9b9d-4e03-9f53-9f88cf7078c7
 *             4) layer.server.fb943cca-cac3-4bbf-ba03-91a1559fee28
 *             5) layer.server.67fd55b5-dc3a-40cf-8adc-9e634b82d474
 *
 *     Publishing to 'layer.client.3392103f-7f50-4422-ae59-2c2c0971951f' will publish:
 *
 *         From root to target:
 *
 *             1) layer
 *             2) layer.client
 *
 *         From target to all sub-channels:
 *
 *             3) layer.client.3392103f-7f50-4422-ae59-2c2c0971951f
 * </pre>
 */
( function() {

    "use strict";

    function createChannel( path ) {
        return {
            path : path,
            subscribers : [],
            children : {}
        };
    }

    module.exports = {

        /**
         * Subscribe a listener function to the specific channel path.
         * @memberof PubSub
         *
         * @param channelPath {string}   A '.' delimited channel path.
         * @param subscriber  {Function} The subscriber function associated with the provided path.
         */
        subscribe: function( channelPath, subscriber ) {

            var paths = channelPath.split('.'),
                path,
                currentPath = '',
                channel;

            this.channels = this.channels || {
                subscribers : [],
                children : {}
            };

            channel = this.channels;

            while ( paths.length > 0 ) {
                path = paths.shift();
                currentPath += ( currentPath.length > 0 ) ? '.' + path : path;
                if ( !channel.children[ path ] ) {
                    channel.children[ path ] = createChannel( currentPath );
                }
                channel = channel.children[ path ];
            }
            channel.subscribers.push( subscriber );
        },

        /**
         * Unsubscribe a listener function from the specific channel path.
         * @memberof PubSub
         *
         * @param channelPath {string}   A '.' delimited channel path.
         * @param subscriber  {Function} The subscriber function associated with the provided path.
         */
        unsubscribe: function( channelPath, subscriber ) {

            var paths = channelPath.split('.'),
                path,
                currentPath = '',
                channel;

            this.channels = this.channels || {
                subscribers : [],
                children : {}
            };

            channel = this.channels;

            while ( paths.length > 0 ) {
                path = paths.shift();
                currentPath += ( currentPath.length > 0 ) ? '.' + path : path;
                if ( !channel.children[ path ] ) {
                    channel.children[ path ] = createChannel( currentPath );
                }
                channel = channel.children[ path ];
            }
            var index = channel.subscribers.indexOf( subscriber );
            if ( index !== -1 ) {
                channel.subscribers.splice( index, 1 );
            }
        },

        /**
         * Publish a message to a channel path. Publishing to a target channel will propagate the message
         * breadth first from the root of the hierarchy to the target channel, then from the target channel
         * to all existing sub-channels
         * @memberof PubSub
         *
         * @param channelPath {string}   A '.' delimited channel path.
         * @param message  {*}       The messsage to be published.
         */
        publish: function( channelPath, message ) {

            var paths = channelPath.split('.'),
                children,
                subscribers,
                queue = [],
                path, i, sub,
                leafChannel,
                currentPath = '',
                channel = this.channels || {
                    subscribers : [],
                    children : {}
                };

            // find channel
            while ( paths.length > 0 ) {
                path = paths.shift();
                currentPath += ( currentPath.length > 0 ) ? '.' + path : path;
                if ( !channel.children[ path ] ) {
                    channel.children[ path ] = createChannel( currentPath );
                }
                channel = channel.children[ path ];
                queue.push( channel );
            }

            leafChannel = queue.pop();

            // breadth first publishing from root to target
            while ( queue.length > 0 ) {
                channel = queue.shift();
                subscribers = channel.subscribers;
                // publish to current channel
                for ( i=0; i<subscribers.length; i++ ) {
                    subscribers[i]( message, channelPath );
                }
            }

            queue = [ leafChannel ];

            // breadth first publishing from target to all children
            while ( queue.length > 0 ) {
                channel = queue.shift();
                subscribers = channel.subscribers;
                children = channel.children;
                // publish to current channel
                for ( i=0; i<subscribers.length; i++ ) {
                    subscribers[i]( message, channelPath );
                }
                // queue up children for leaf channel
                for ( sub in children ) {
                    if ( children.hasOwnProperty( sub ) ) {
                        queue.push( children[ sub ] );
                    }
                }
            }
        }
    };
}());

},{}],60:[function(require,module,exports){
/*
 * Copyright (c) 2014 Oculus Info Inc.
 * http://www.oculusinfo.com/
 *
 * Released under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * A utility namespace containing commonly used functionality.
 */
( function() {

    "use strict";

    var propagateEvent;

    /**
     * Private: A propagation handler that will temporarily de-activate the
     * DOM element and propagate the event through to any underlying element.
     * @param event {Event} The event object.
     */
    propagateEvent = function( event ) {
        var newEvent = new event.constructor( event.type, event ),
            element,
            before,
            below;
        element = event.currentTarget;
        before = element.style['pointer-events'];
        element.style['pointer-events'] = 'none';
        below = document.elementFromPoint( event.clientX, event.clientY );
        if ( below ) {
            below.dispatchEvent( newEvent );
        }
        element.style['pointer-events'] = before;
    };

    module.exports = {

        /**
         * Generates an RFC4122 version 4 compliant UUID string.
         *
         * @returns {string}
         */
        generateUuid: function() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random()*16|0, v = (c === 'x') ? r : (r&0x3|0x8);
                return v.toString(16);
            });
        },

        /**
         * Allows the given DOM element or jQuery object events to propagate through
         * and interact with underlying elements
         *
         * @param elem     {HTMLElement | jQuery} The DOM element.
         * @param [events] {Array}                 Array of events to propagate through (optional).
         */
        enableEventPropagation: function( elem, events ) {
            var domElement = ( elem instanceof $ ) ? elem[0] : elem,
                i;
            if ( !events ) {
                domElement.addEventListener( 'mousedown', propagateEvent );
                domElement.addEventListener( 'mouseup', propagateEvent );
                domElement.addEventListener( 'mousemove', propagateEvent );
                domElement.addEventListener( 'wheel', propagateEvent );
                domElement.addEventListener( 'scroll', propagateEvent );
                domElement.addEventListener( 'click', propagateEvent );
                domElement.addEventListener( 'dblclick', propagateEvent );
            } else {
                events = ( events instanceof Array ) ? events : [ events ];
                for ( i=0; i<events.length; i++ ) {
                    domElement.addEventListener( events[i], propagateEvent );
                }
            }
        },

        /**
         * Removes previously enabled event propagation.
         *
         * @param elem     {HTMLElement | jQuery} The DOM element.
         * @param [events] {Array}               Array of events to remove (optional).
         */
        disableEventPropagation: function( elem, events ) {
            var domElement = ( elem instanceof $ ) ? elem[0] : elem,
                i;
            if ( !events ) {
                domElement.removeEventListener( 'mousedown', propagateEvent );
                domElement.removeEventListener( 'mouseup', propagateEvent );
                domElement.removeEventListener( 'mousemove', propagateEvent );
                domElement.removeEventListener( 'wheel', propagateEvent );
                domElement.removeEventListener( 'scroll', propagateEvent );
                domElement.removeEventListener( 'click', propagateEvent );
                domElement.removeEventListener( 'dblclick', propagateEvent );
            } else {
                events = ( events instanceof Array ) ? events : [ events ];
                for ( i=0; i<events.length; i++ ) {
                    domElement.removeEventListener( events[i], propagateEvent );
                }
            }
        },

        /**
         * Returns a proper modulo as the % operator in javascript is the 'remainder' operator.
         * @param value {number} the value
         * @param n     {number} the divisor
         * @returns {number}
         */
        mod: function( value, n ) {
           return ( (value % n) + n) % n;
        },

        /**
         * Rounds a number towards another number.
         * @param value {number} the value
         * @returns {number}
         */
         roundTowards: function( value, num ) {
            if ( value < num ) {
                return Math.ceil( value );
            }
            return Math.floor( value );
        },

        /**
         * Rounds a given value to a set number of decimals. Defaults to 2.
         *
         * @param value    {number} value to round
         * @param decimals {int}    number of decimals
         * @returns {string} rounded value
         */
        roundToDecimals: function( value, decimals ) {
            var numDec = decimals || 2,
                pow10 = Math.pow( 10, numDec );
            return parseFloat( Math.round( value * pow10 ) / pow10 ).toFixed( decimals );
        },

        /**
         * Converts a value from the range [0, 1] to a value from the
         * range [minMax.min, minMax.max] based on a value transform function.
         *
         * @param {number} percentage - The range percentage in range [0, 1].
         * @param {Object} minMax - The min and max values of the range.
         * @param {String} transform - The transform type, either 'log10' or 'linear'.
         *
         * @returns {number} The value from [minMax.min, minMax.max].
         */
        denormalizeValue: function( percentage, minMax, transform ) {
            var range = minMax.maximum- minMax.minimum,
                val;
            function log10(val) {
                return Math.log(val) / Math.LN10;
            }
            //iterate over the inner labels
            if ( transform === "log10" ) {
                var logMin = (minMax.minimum === 0) ? 0 : log10(minMax.minimum);
                var logMax = (minMax.maximum === 0) ? 0 : log10(minMax.maximum);
                val =  Math.pow(10, logMin + (logMax - logMin) * percentage);
            } else {
                val = percentage * range + minMax.minimum;
            }
            return val;
        },

        /**
         * Converts a value from the range [minMax.min, minMax.max] to a value in
         * the range [0, 1] based on a value transform function.
         *
         * @param {number} value - The range percentage in range [minMax.min, minMax.max].
         * @param {Object} minMax - The min and max values of the range.
         * @param {String} transform - The transform type, either 'log10' or 'linear'.
         *
         * @returns {number} The value percentage from [0, 1].
         */
        normalizeValue: function( value, minMax, transform ) {
            var range = minMax.maximum - minMax.minimum,
                val;
            function log10(val) {
                return Math.log(val) / Math.LN10;
            }
            function checkLogInput( value ) {
                return ( value === 0 || value === 1 ) ? 0 : log10( value ) / log10( value );
            }
            //iterate over the inner labels
            if ( transform === "log10" ) {
                val = checkLogInput( minMax.maximum );
            } else {
                val = ( ( value - minMax.minimum ) / range );
            }
            return val;
        },

        /**
         * Registers a click handler that only fires if the click isn't part of
         * a double click.
         *
         * @param element  {HTMLElement} The DOM element to attach the event.
         * @param callback {Function}    The callback function.
         * @param [timout] {int}            The timeout in ms (optional).
         */
        timeSensitiveClick: function( element, callback, timeout ) {
            var clicks = 0;
            element.addEventListener( "click", function( event ) {
		    	clicks++;
		    	if ( clicks === 1 ) {
		        	setTimeout( function() {
		        		if ( clicks === 1 ) {
							callback.call( element, event );
				        }
		        		clicks = 0;
		        	}, timeout || 300);
			    }
		    });
        },

        /**
         * Registers a click handler that only fires if the click didn't
         * involve a map drag. Since the map is moving under the mouse cursor
         * the browser will still register a click despite mouse movement. This
         * guards against that.
         *
         * @param element     {HTMLElement} The DOM element to attach the event.
         * @param callback    {Function}    The callback function.
         * @param [threshold] {int}         The movement threshold (optional).
         */
        dragSensitiveClick: function( element, callback, threshold ) {
            var dragStart = {x: null, y: null};
            threshold = threshold || 10;
            element.addEventListener( "mousedown", function( evt ) {
                dragStart.x = evt.pageX;
                dragStart.y = evt.pageY;
            });
            element.addEventListener( "click", function( evt ) {
                if (Math.abs( dragStart.x - evt.pageX ) < threshold &&
                    Math.abs( dragStart.y - evt.pageY ) < threshold ) {
                    callback.call( this, evt );
                }
            });
        },

        /**
         * Registers a click handler that only fires if the click didn't
         * involve a map drag and was not part of a double click.
         *
         * @param element     {HTMLElement} The DOM element to attach the event.
         * @param callback    {Function}    The callback function.
         */
        dragAndTimeSensitiveClick: function( element, callback ) {
            var dragStart = {x: null, y: null},
                threshold = threshold || 10;
            element.addEventListener( "mousedown", function( evt ) {
                dragStart.x = evt.pageX;
                dragStart.y = evt.pageY;
            });
            this.timeSensitiveClick( element, function( evt ) {
                if (Math.abs( dragStart.x - evt.pageX ) < threshold &&
                    Math.abs( dragStart.y - evt.pageY ) < threshold ) {
                    callback.call( this, evt );
                }
            });
        },

        /**
         * Return an object containing all parameters and values in the current
         * URL.
         *
         * @returns {Object}
         */
        getURLParameters: function() {
            var url = window.location.search.substring(1),
                urlVars = url.split('&'),
                result = {},
                keyValue,
                i;
            for ( i=0; i<urlVars.length; ++i ) {
                keyValue = urlVars[i].split('=');
                result[ keyValue[0] ] = keyValue[1];
            }
            return result;
        },

        /**
         * Return the value of a specific parameters in the current URL.
         *
         * @param key {string} The url parameter key.
         * @returns {string}
         */
        getURLParameter: function( key ) {
            return this.getURLParameters()[ key ];
        },

        /**
         * HTTP REST Error handling function.
         *
         * @param xhr {XmlHttpRequest} XmlHttpRequest object
         */
        handleHTTPError: function( xhr ) {
            console.error( xhr.responseText );
            console.error( xhr );
        },

        /**
         * Returns a string of an object in query parameter dot notation.
         *
         * @param params {Object} The query parameter object.
         * @returns {string}
         */
        encodeQueryParams: function( params ) {
            var query;
            function traverseParams( params, query ) {
                var result = "";
                _.forIn( params, function( value, key ) {
                    if ( typeof value !== "object" ) {
                        result += query + key + '=' + value + "&";
                    } else {
                        result += traverseParams( params[ key ], query + key + "." );
                    }
                });
                // if string ends in ".", it resulted in an empty leaf node, return
                // nothing in that case
                return ( result[0] !== "." ) ? result : "";
            }
            query = "?" + traverseParams( params, '' );
            // remove last '&' character
            return query.slice( 0, query.length - 1 );
        },

        /**
         * Creates and fills an array with the provided value.
         *
         * @param {number} length - The length of the array.
         * @param {*} value - The value to fill. Defaults to 0.
         *
         * @returns {Array} The filled array.
         */
        fillArray: function( length, value ) {
            value = value !== undefined ? value : 0;
            var arr = [],
                i;
            for ( i=0; i<length; i++ ) {
                arr.push( value );
            }
            return arr;
        },

			    /**
			     * Creates and fills an array with the provided value.
			     *
			     * @param {number} length - The length of the array.
			     * @param {*} value - The value to fill. Defaults to 0.
			     *
			     * @returns {Array} The filled array.
			     */
			    fillArrayByFunc: function( length, func ) {
				    var arr = [],
					    i;
				    for ( i=0; i<length; i++ ) {
					    arr.push( func() );
				    }
				    return arr;
			    },

        /**
         * Returns true if an object has no parameters.
         *
         * @param obj {Object} The object.
         * @returns {boolean}
         */
        isEmpty: function( obj ) {
            var prop;
            for ( prop in obj ) {
                if ( obj.hasOwnProperty( prop ) ) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Extend class a by class b. Does not recurse, simply overlays top attributes.
         *
         * @param {Object} a - Object a which is extended.
         * @param {Object} b - Object b which extends a.
         *
         * @returns {Object} The extended object.
         */
        extend: function( a, b ) {
            var key;
            for( key in b ) {
                if( b.hasOwnProperty( key ) ) {
                    a[ key ] = b[ key ];
                }
            }
            return a;
        },


    };
}());

},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvanMvYXBpLmpzIiwic3JjL2pzL2Jpbm5pbmcvQXJlYU9mSW50ZXJlc3RUaWxlUHlyYW1pZC5qcyIsInNyYy9qcy9iaW5uaW5nL1RpbGVJdGVyYXRvci5qcyIsInNyYy9qcy9iaW5uaW5nL1dlYk1lcmNhdG9yVGlsZVB5cmFtaWQuanMiLCJzcmMvanMvbGF5ZXIvQW5ub3RhdGlvbkxheWVyLmpzIiwic3JjL2pzL2xheWVyL0F4aXNMYXllci5qcyIsInNyYy9qcy9sYXllci9CYXNlTGF5ZXIuanMiLCJzcmMvanMvbGF5ZXIvQ2Fyb3VzZWwuanMiLCJzcmMvanMvbGF5ZXIvQ2xpZW50TGF5ZXIuanMiLCJzcmMvanMvbGF5ZXIvSHRtbE1hcmtlci5qcyIsInNyYy9qcy9sYXllci9IdG1sTWFya2VyTGF5ZXIuanMiLCJzcmMvanMvbGF5ZXIvSHRtbFRpbGUuanMiLCJzcmMvanMvbGF5ZXIvSHRtbFRpbGVMYXllci5qcyIsInNyYy9qcy9sYXllci9LTUxMYXllci5qcyIsInNyYy9qcy9sYXllci9MYXllci5qcyIsInNyYy9qcy9sYXllci9MYXllclV0aWwuanMiLCJzcmMvanMvbGF5ZXIvTXVsdGlVcmxDbGllbnRMYXllci5qcyIsInNyYy9qcy9sYXllci9QZW5kaW5nTGF5ZXIuanMiLCJzcmMvanMvbGF5ZXIvUGVuZGluZ1RpbGUuanMiLCJzcmMvanMvbGF5ZXIvU2VydmVyTGF5ZXIuanMiLCJzcmMvanMvbGF5ZXIvVW5pdmFyaWF0ZVRpbGUuanMiLCJzcmMvanMvbGF5ZXIvVW5pdmFyaWF0ZVRpbGVMYXllci5qcyIsInNyYy9qcy9sYXllci9WZWN0b3JMYXllci5qcyIsInNyYy9qcy9sYXllci9yZW5kZXJlci9HcmFwaExhYmVsUmVuZGVyZXIuanMiLCJzcmMvanMvbGF5ZXIvcmVuZGVyZXIvR3JhcGhOb2RlUmVuZGVyZXIuanMiLCJzcmMvanMvbGF5ZXIvcmVuZGVyZXIvUG9pbnRBZ2dyZWdhdGVSZW5kZXJlci5qcyIsInNyYy9qcy9sYXllci9yZW5kZXJlci9Qb2ludFJlbmRlcmVyLmpzIiwic3JjL2pzL2xheWVyL3JlbmRlcmVyL1JlbmRlclRoZW1lLmpzIiwic3JjL2pzL2xheWVyL3JlbmRlcmVyL1JlbmRlcmVyLmpzIiwic3JjL2pzL2xheWVyL3JlbmRlcmVyL1JlbmRlcmVyVXRpbC5qcyIsInNyYy9qcy9sYXllci9yZW5kZXJlci9UZXh0QnlGcmVxdWVuY3lSZW5kZXJlci5qcyIsInNyYy9qcy9sYXllci9yZW5kZXJlci9UZXh0QnlUb3BpY1JlbmRlcmVyLmpzIiwic3JjL2pzL2xheWVyL3JlbmRlcmVyL1RleHRTY29yZVdlaWdodGVkUmVuZGVyZXIuanMiLCJzcmMvanMvbGF5ZXIvcmVuZGVyZXIvV29yZENsb3VkUmVuZGVyZXIuanMiLCJzcmMvanMvbGF5ZXIvcmVuZGVyZXIvYWdncmVnYXRvci9BZ2dyZWdhdG9yLmpzIiwic3JjL2pzL2xheWVyL3JlbmRlcmVyL2FnZ3JlZ2F0b3IvRnJlcXVlbmNpZXNCeVRvcGljQWdncmVnYXRvci5qcyIsInNyYy9qcy9sYXllci9yZW5kZXJlci9hZ2dyZWdhdG9yL0ZyZXF1ZW5jeUFycmF5c0J5VG9waWNBZ2dyZWdhdG9yLmpzIiwic3JjL2pzL2xheWVyL3JlbmRlcmVyL2FnZ3JlZ2F0b3IvVG9waWNDb3VudEFnZ3JlZ2F0b3IuanMiLCJzcmMvanMvbGF5ZXIvcmVuZGVyZXIvYWdncmVnYXRvci9Ub3BpY0NvdW50QXJyYXlBZ2dyZWdhdG9yLmpzIiwic3JjL2pzL2xheWVyL3JlbmRlcmVyL2FnZ3JlZ2F0b3IvVG9waWNGcmVxdWVuY3lBZ2dyZWdhdG9yLmpzIiwic3JjL2pzL2xheWVyL3JlbmRlcmVyL2FnZ3JlZ2F0b3IvVHdlZXRzQnlUb3BpY0FnZ3JlZ2F0b3IuanMiLCJzcmMvanMvbWFwL0F4aXMuanMiLCJzcmMvanMvbWFwL0F4aXNVdGlsLmpzIiwic3JjL2pzL21hcC9NYXAuanMiLCJzcmMvanMvbWFwL01hcFV0aWwuanMiLCJzcmMvanMvbWFwL01hcmtlci5qcyIsInNyYy9qcy9yZXN0L0Fubm90YXRpb25TZXJ2aWNlLmpzIiwic3JjL2pzL3Jlc3QvTGF5ZXJTZXJ2aWNlLmpzIiwic3JjL2pzL3Jlc3QvTGVnZW5kU2VydmljZS5qcyIsInNyYy9qcy9yZXN0L1RpbGVTZXJ2aWNlLmpzIiwic3JjL2pzL3VpL0NvYXJzZW5lc3NDb250cm9scy5qcyIsInNyYy9qcy91aS9GaWx0ZXJDb250cm9scy5qcyIsInNyYy9qcy91aS9MYXllckNvbnRyb2xzLmpzIiwic3JjL2pzL3VpL0xheWVyRW50cnkuanMiLCJzcmMvanMvdWkvTGF5ZXJFbnRyeUJvZHkuanMiLCJzcmMvanMvdWkvTGF5ZXJFbnRyeUhlYWQuanMiLCJzcmMvanMvdWkvT3BhY2l0eUNvbnRyb2xzLmpzIiwic3JjL2pzL3VpL1NsaWRlclV0aWwuanMiLCJzcmMvanMvdXRpbC9QdWJTdWIuanMiLCJzcmMvanMvdXRpbC9VdGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3R1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xyXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cclxuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICAgICAgLy8gQmlubmluZ1xyXG4gICAgICAgIEFyZWFPZkludGVyZXN0VGlsZVB5cmFtaWQ6IHJlcXVpcmUoJy4vYmlubmluZy9BcmVhT2ZJbnRlcmVzdFRpbGVQeXJhbWlkJyksXHJcbiAgICAgICAgVGlsZUl0ZXJhdG9yOiByZXF1aXJlKCcuL2Jpbm5pbmcvVGlsZUl0ZXJhdG9yJyksXHJcbiAgICAgICAgV2ViTWVyY2F0b3JUaWxlUHlyYW1pZDogcmVxdWlyZSgnLi9iaW5uaW5nL1dlYk1lcmNhdG9yVGlsZVB5cmFtaWQnKSxcclxuXHJcbiAgICAgICAgLy8gTGF5ZXJcclxuICAgICAgICBBbm5vdGF0aW9uTGF5ZXI6IHJlcXVpcmUoJy4vbGF5ZXIvQW5ub3RhdGlvbkxheWVyJyksXHJcbiAgICAgICAgQXhpc0xheWVyOiByZXF1aXJlKCcuL2xheWVyL0F4aXNMYXllcicpLFxyXG4gICAgICAgIEJhc2VMYXllcjogcmVxdWlyZSgnLi9sYXllci9CYXNlTGF5ZXInKSxcclxuICAgICAgICBLTUxMYXllcjogcmVxdWlyZSgnLi9sYXllci9LTUxMYXllcicpLFxyXG4gICAgICAgIFNlcnZlckxheWVyOiByZXF1aXJlKCcuL2xheWVyL1NlcnZlckxheWVyJyksXHJcbiAgICAgICAgQ2xpZW50TGF5ZXI6IHJlcXVpcmUoJy4vbGF5ZXIvQ2xpZW50TGF5ZXInKSxcclxuICAgICAgICBNdWx0aVVybENsaWVudExheWVyOiByZXF1aXJlKCcuL2xheWVyL011bHRpVXJsQ2xpZW50TGF5ZXInKSxcclxuICAgICAgICBDYXJvdXNlbDogcmVxdWlyZSgnLi9sYXllci9DYXJvdXNlbCcpLFxyXG4gICAgICAgIExheWVyVXRpbDogcmVxdWlyZSgnLi9sYXllci9MYXllclV0aWwnKSxcclxuICAgICAgICBWZWN0b3JMYXllcjogcmVxdWlyZSgnLi9sYXllci9WZWN0b3JMYXllcicpLFxyXG4gICAgICAgIEh0bWxNYXJrZXI6IHJlcXVpcmUoJy4vbGF5ZXIvSHRtbE1hcmtlcicpLFxyXG4gICAgICAgIEh0bWxNYXJrZXJMYXllcjogcmVxdWlyZSgnLi9sYXllci9IdG1sTWFya2VyTGF5ZXInKSxcclxuICAgICAgICBMYXllcjogcmVxdWlyZSgnLi9sYXllci9MYXllcicpLFxyXG5cclxuICAgICAgICAvLyBSZW5kZXJlclxyXG4gICAgICAgIFJlbmRlcmVyOiByZXF1aXJlKCcuL2xheWVyL3JlbmRlcmVyL1JlbmRlcmVyJyksXHJcbiAgICAgICAgQWdncmVnYXRvcjogcmVxdWlyZSgnLi9sYXllci9yZW5kZXJlci9hZ2dyZWdhdG9yL0FnZ3JlZ2F0b3InKSxcclxuICAgICAgICBUb3BpY0NvdW50QWdncmVnYXRvcjogcmVxdWlyZSgnLi9sYXllci9yZW5kZXJlci9hZ2dyZWdhdG9yL1RvcGljQ291bnRBZ2dyZWdhdG9yJyksXHJcbiAgICAgICAgVG9waWNDb3VudEFycmF5QWdncmVnYXRvcjogcmVxdWlyZSgnLi9sYXllci9yZW5kZXJlci9hZ2dyZWdhdG9yL1RvcGljQ291bnRBcnJheUFnZ3JlZ2F0b3InKSxcclxuICAgICAgICBUb3BpY0ZyZXF1ZW5jeUFnZ3JlZ2F0b3I6IHJlcXVpcmUoJy4vbGF5ZXIvcmVuZGVyZXIvYWdncmVnYXRvci9Ub3BpY0ZyZXF1ZW5jeUFnZ3JlZ2F0b3InKSxcclxuICAgICAgICBUd2VldHNCeVRvcGljQWdncmVnYXRvcjogcmVxdWlyZSgnLi9sYXllci9yZW5kZXJlci9hZ2dyZWdhdG9yL1R3ZWV0c0J5VG9waWNBZ2dyZWdhdG9yJyksXHJcbiAgICAgICAgRnJlcXVlbmNpZXNCeVRvcGljQWdncmVnYXRvcjogcmVxdWlyZSgnLi9sYXllci9yZW5kZXJlci9hZ2dyZWdhdG9yL0ZyZXF1ZW5jaWVzQnlUb3BpY0FnZ3JlZ2F0b3InKSxcclxuICAgICAgICBGcmVxdWVuY3lBcnJheXNCeVRvcGljQWdncmVnYXRvcjogcmVxdWlyZSgnLi9sYXllci9yZW5kZXJlci9hZ2dyZWdhdG9yL0ZyZXF1ZW5jeUFycmF5c0J5VG9waWNBZ2dyZWdhdG9yJyksXHJcbiAgICAgICAgUmVuZGVyZXJVdGlsOiByZXF1aXJlKCcuL2xheWVyL3JlbmRlcmVyL1JlbmRlcmVyVXRpbCcpLFxyXG4gICAgICAgIEdyYXBoTGFiZWxSZW5kZXJlcjogcmVxdWlyZSgnLi9sYXllci9yZW5kZXJlci9HcmFwaExhYmVsUmVuZGVyZXInKSxcclxuICAgICAgICBHcmFwaE5vZGVSZW5kZXJlcjogcmVxdWlyZSgnLi9sYXllci9yZW5kZXJlci9HcmFwaE5vZGVSZW5kZXJlcicpLFxyXG4gICAgICAgIFBvaW50QWdncmVnYXRlUmVuZGVyZXI6IHJlcXVpcmUoJy4vbGF5ZXIvcmVuZGVyZXIvUG9pbnRBZ2dyZWdhdGVSZW5kZXJlcicpLFxyXG4gICAgICAgIFBvaW50UmVuZGVyZXI6IHJlcXVpcmUoJy4vbGF5ZXIvcmVuZGVyZXIvUG9pbnRSZW5kZXJlcicpLFxyXG4gICAgICAgIFRleHRCeUZyZXF1ZW5jeVJlbmRlcmVyOiByZXF1aXJlKCcuL2xheWVyL3JlbmRlcmVyL1RleHRCeUZyZXF1ZW5jeVJlbmRlcmVyJyksXHJcbiAgICAgICAgVGV4dFNjb3JlV2VpZ2h0ZWRSZW5kZXJlcjogcmVxdWlyZSgnLi9sYXllci9yZW5kZXJlci9UZXh0U2NvcmVXZWlnaHRlZFJlbmRlcmVyJyksXHJcblx0XHRUZXh0QnlUb3BpY1JlbmRlcmVyOiByZXF1aXJlKCcuL2xheWVyL3JlbmRlcmVyL1RleHRCeVRvcGljUmVuZGVyZXInKSxcclxuICAgICAgICBXb3JkQ2xvdWRSZW5kZXJlcjogcmVxdWlyZSgnLi9sYXllci9yZW5kZXJlci9Xb3JkQ2xvdWRSZW5kZXJlcicpLFxyXG4gICAgICAgIFJlbmRlclRoZW1lOiByZXF1aXJlKCcuL2xheWVyL3JlbmRlcmVyL1JlbmRlclRoZW1lJyksXHJcblxyXG4gICAgICAgIC8vIE1hcFxyXG4gICAgICAgIE1hcDogcmVxdWlyZSgnLi9tYXAvTWFwJyksXHJcbiAgICAgICAgTWFwVXRpbDogcmVxdWlyZSgnLi9tYXAvTWFwVXRpbCcpLFxyXG4gICAgICAgIE1hcmtlcjogcmVxdWlyZSgnLi9tYXAvTWFya2VyJyksXHJcbiAgICAgICAgQXhpczogcmVxdWlyZSgnLi9tYXAvQXhpcycpLFxyXG4gICAgICAgIEF4aXNVdGlsOiByZXF1aXJlKCcuL21hcC9BeGlzVXRpbCcpLFxyXG5cclxuICAgICAgICAvLyBSRVNUXHJcbiAgICAgICAgQW5ub3RhdGlvblNlcnZpY2U6IHJlcXVpcmUoJy4vcmVzdC9Bbm5vdGF0aW9uU2VydmljZScpLFxyXG4gICAgICAgIExheWVyU2VydmljZTogcmVxdWlyZSgnLi9yZXN0L0xheWVyU2VydmljZScpLFxyXG4gICAgICAgIExlZ2VuZFNlcnZpY2U6IHJlcXVpcmUoJy4vcmVzdC9MZWdlbmRTZXJ2aWNlJyksXHJcbiAgICAgICAgVGlsZVNlcnZpY2U6IHJlcXVpcmUoJy4vcmVzdC9UaWxlU2VydmljZScpLFxyXG5cclxuICAgICAgICAvLyBVSVxyXG4gICAgICAgIExheWVyQ29udHJvbHM6IHJlcXVpcmUoJy4vdWkvTGF5ZXJDb250cm9scycpLFxyXG5cclxuICAgICAgICAvLyBVdGlsXHJcbiAgICAgICAgUHViU3ViOiByZXF1aXJlKCcuL3V0aWwvUHViU3ViJyksXHJcbiAgICAgICAgVXRpbDogcmVxdWlyZSgnLi91dGlsL1V0aWwnKVxyXG4gICAgfTtcclxuXHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW50aWF0ZSBhbiBBcmVhT2ZJbnRlcmVzdFRpbGVQeXJhbWlkIG9iamVjdC5cclxuICAgICAqIEBjbGFzcyBBcmVhT2ZJbnRlcmVzdFRpbGVQeXJhbWlkXHJcbiAgICAgKiBAY2xhc3NkZXNjIEEgVGlsZVB5cmFtaWQgaW1wbGVtZW50YXRpb24sIHRoZSBlcXVpdmFsZW50IG9mIEFPSVRpbGVQeXJhbWlkIGluXHJcbiAgICAgKiAgICAgICAgICAgIHRpbGUtc2VydmljZS9iaW5uaW5nLXV0aWxpdGllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlYyAtIFRoZSBzcGVjaWZpY2F0aW9uIG9iamVjdC5cclxuICAgICAqL1xyXG5cdGZ1bmN0aW9uIEFyZWFPZkludGVyZXN0VGlsZVB5cmFtaWQoIHNwZWMgKSB7XHJcbiAgICAgICAgdGhpcy5taW5YID0gc3BlYy5taW5YO1xyXG4gICAgICAgIHRoaXMubWluWSA9IHNwZWMubWluWTtcclxuICAgICAgICB0aGlzLm1heFggPSBzcGVjLm1heFg7XHJcbiAgICAgICAgdGhpcy5tYXhZID0gc3BlYy5tYXhZO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcHJvamVjdGlvbiBjb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHlyYW1pZC5cclxuICAgICAqIEBtZW1iZXJvZiBBcmVhT2ZJbnRlcmVzdFRpbGVQeXJhbWlkXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHByb2plY3Rpb24gY29kZS5cclxuICAgICAqL1xyXG4gICAgQXJlYU9mSW50ZXJlc3RUaWxlUHlyYW1pZC5wcm90b3R5cGUuZ2V0UHJvamVjdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBcIkVQU0c6NDMyNlwiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHRpbGUgc2NoZW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHlyYW1pZC5cclxuICAgICAqIEBtZW1iZXJvZiBBcmVhT2ZJbnRlcmVzdFRpbGVQeXJhbWlkXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHNjaGVtZSBjb2RlLlxyXG4gICAgICovXHJcblx0QXJlYU9mSW50ZXJlc3RUaWxlUHlyYW1pZC5wcm90b3R5cGUuZ2V0VGlsZVNjaGVtZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBcIlRNU1wiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYSBmcmFjdGlvbmFsIHRpbGUgY29vcmRpbmF0ZSB0byBhIHBvaW50IGluIHRoZSByb290IGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAgICogQG1lbWJlcm9mIEFyZWFPZkludGVyZXN0VGlsZVB5cmFtaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGlsZSAtIFRoZSBmcmFjdGlvbmFsIHRpbGUgY29vcmRpbmF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcm9vdCBjb29yZGluYXRlLlxyXG4gICAgICovXHJcbiAgICBBcmVhT2ZJbnRlcmVzdFRpbGVQeXJhbWlkLnByb3RvdHlwZS5mcmFjdGlvbmFsVGlsZVRvUm9vdCA9IGZ1bmN0aW9uKCB0aWxlICkge1xyXG4gICAgICAgIHZhciBwb3cyLCB0aWxlWFNpemUsIHRpbGVZU2l6ZTtcclxuICAgICAgICBwb3cyID0gMSA8PCB0aWxlLmxldmVsO1xyXG4gICAgICAgIHRpbGVYU2l6ZSA9ICh0aGlzLm1heFggLSB0aGlzLm1pblgpIC8gcG93MjtcclxuICAgICAgICB0aWxlWVNpemUgPSAodGhpcy5tYXhZIC0gdGhpcy5taW5ZKSAvIHBvdzI7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogdGhpcy5taW5YICsgdGlsZVhTaXplICogdGlsZS54SW5kZXgsXHJcbiAgICAgICAgICAgIHk6IHRoaXMubWluWSArIHRpbGVZU2l6ZSAqIHRpbGUueUluZGV4XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGEgcG9pbnQgZnJvbSB0aGUgcm9vdCBjb29yZGluYXRlIHN5c3RlbSB0byBhIGZyYWN0aW9uYWwgdGlsZSBjb29yZGluYXRlLlxyXG4gICAgICogQG1lbWJlcm9mIEFyZWFPZkludGVyZXN0VGlsZVB5cmFtaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IHJvb3QgY29vcmRpbmF0ZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgcm9vdCBjb29yZGluYXRlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBsZXZlbCAtIFRoZSB6b29tIGxldmVsLlxyXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBiaW5zIC0gVGhlIG51bWJlciBvZiBiaW5zIHBlciBkaW1lbnNpb24gaW4gYSB0aWxlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmcmFjdGlvbmFsIHRpbGUgY29vcmRpbmF0ZS5cclxuICAgICAqL1xyXG5cdEFyZWFPZkludGVyZXN0VGlsZVB5cmFtaWQucHJvdG90eXBlLnJvb3RUb0ZyYWN0aW9uYWxUaWxlID0gZnVuY3Rpb24oIHgsIHksIGxldmVsLCBiaW5zICkge1xyXG5cdFx0YmlucyA9IGJpbnMgfHwgMjU2O1xyXG4gICAgICAgIHZhciBudW1EaXZzLCB0aWxlWCwgdGlsZVk7XHJcbiAgICAgICAgbnVtRGl2cyA9IDEgPDwgbGV2ZWw7XHJcbiAgICAgICAgdGlsZVggPSBudW1EaXZzICogKHggLSB0aGlzLm1pblgpIC8gKHRoaXMubWF4WCAtIHRoaXMubWluWCk7XHJcbiAgICAgICAgdGlsZVkgPSBudW1EaXZzICogKHkgLSB0aGlzLm1pblkpIC8gKHRoaXMubWF4WSAtIHRoaXMubWluWSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ2xldmVsJzogbGV2ZWwsXHJcbiAgICAgICAgICAgICd4SW5kZXgnOiB0aWxlWCxcclxuICAgICAgICAgICAgJ3lJbmRleCc6IHRpbGVZLFxyXG4gICAgICAgICAgICB4QmluQ291bnQ6IGJpbnMsXHJcbiAgICAgICAgICAgIHlCaW5Db3VudDogYmluc1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhIHBvaW50IGZyb20gdGhlIHJvb3QgY29vcmRpbmF0ZSBzeXN0ZW0gdG8gYSB0aWxlIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQXJlYU9mSW50ZXJlc3RUaWxlUHlyYW1pZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggcm9vdCBjb29yZGluYXRlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSByb290IGNvb3JkaW5hdGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGxldmVsIC0gVGhlIHpvb20gbGV2ZWwuXHJcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGJpbnMgLSBUaGUgbnVtYmVyIG9mIGJpbnMgcGVyIGRpbWVuc2lvbiBpbiBhIHRpbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHRpbGUgY29vcmRpbmF0ZS5cclxuICAgICAqL1xyXG4gICAgQXJlYU9mSW50ZXJlc3RUaWxlUHlyYW1pZC5wcm90b3R5cGUucm9vdFRvVGlsZSA9IGZ1bmN0aW9uKCB4LCB5LCBsZXZlbCwgYmlucyApIHtcclxuXHRcdHZhciByZXN1bHQgPSB0aGlzLnJvb3RUb0ZyYWN0aW9uYWxUaWxlKCB4LCB5LCBsZXZlbCwgYmlucyApO1xyXG5cdFx0cmVzdWx0LnhJbmRleCA9IE1hdGguZmxvb3IoIHJlc3VsdC54SW5kZXggKTtcclxuXHRcdHJlc3VsdC55SW5kZXggPSBNYXRoLmZsb29yKCByZXN1bHQueUluZGV4ICk7XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcblx0LyoqXHJcbiAgICAgKiBNYXBzIGEgcG9pbnQgZnJvbSB0aGUgcm9vdCBjb29yZGluYXRlIHN5c3RlbSB0byBhIHNwZWNpZmljIGJpbiBmcmFjdGlvbmFsXHJcblx0ICogY29vcmRpbmF0ZS5cclxuICAgICAqIEBtZW1iZXJvZiBBcmVhT2ZJbnRlcmVzdFRpbGVQeXJhbWlkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCByb290IGNvb3JkaW5hdGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IHJvb3QgY29vcmRpbmF0ZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aWxlIC0gVGhlIHRpbGUgY29vcmRpbmF0ZSB0aGF0IGhvbGRzIHRoZSB0YXJnZXQgYmluLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBiaW4gY29vcmRpbmF0ZS5cclxuICAgICAqL1xyXG4gICAgQXJlYU9mSW50ZXJlc3RUaWxlUHlyYW1pZC5wcm90b3R5cGUucm9vdFRvRnJhY3Rpb25hbEJpbiA9IGZ1bmN0aW9uKCB4LCB5LCB0aWxlICkge1xyXG4gICAgICAgIHZhciBwb3cyLCB0aWxlWFNpemUsIHRpbGVZU2l6ZSwgeEluVGlsZSwgeUluVGlsZSwgYmluWCwgYmluWTtcclxuICAgICAgICBwb3cyID0gMSA8PCB0aWxlLmxldmVsO1xyXG4gICAgICAgIHRpbGVYU2l6ZSA9ICh0aGlzLm1heFggLSB0aGlzLm1pblgpIC8gcG93MjtcclxuICAgICAgICB0aWxlWVNpemUgPSAodGhpcy5tYXhZIC0gdGhpcy5taW5ZKSAvIHBvdzI7XHJcbiAgICAgICAgeEluVGlsZSA9IHggLSB0aGlzLm1pblggLSB0aWxlLnhJbmRleCAqIHRpbGVYU2l6ZTtcclxuICAgICAgICB5SW5UaWxlID0geSAtIHRoaXMubWluWSAtIHRpbGUueUluZGV4ICogdGlsZVlTaXplO1xyXG4gICAgICAgIGJpblggPSB4SW5UaWxlICogdGlsZS54QmluQ291bnQgLyB0aWxlWFNpemU7XHJcbiAgICAgICAgYmluWSA9IHlJblRpbGUgKiB0aWxlLnlCaW5Db3VudCAvIHRpbGVZU2l6ZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBiaW5YLFxyXG4gICAgICAgICAgICB5OiB0aWxlLnlCaW5Db3VudCAtIDEgLSBiaW5ZXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG5cdC8qKlxyXG4gICAgICogTWFwcyBhIHBvaW50IGZyb20gdGhlIHJvb3QgY29vcmRpbmF0ZSBzeXN0ZW0gdG8gYSBzcGVjaWZpYyBiaW4gY29vcmRpbmF0ZS5cclxuICAgICAqIEBtZW1iZXJvZiBBcmVhT2ZJbnRlcmVzdFRpbGVQeXJhbWlkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCByb290IGNvb3JkaW5hdGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IHJvb3QgY29vcmRpbmF0ZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aWxlIC0gVGhlIHRpbGUgY29vcmRpbmF0ZSB0aGF0IGhvbGRzIHRoZSB0YXJnZXQgYmluLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBiaW4gY29vcmRpbmF0ZS5cclxuICAgICAqL1xyXG4gICAgQXJlYU9mSW50ZXJlc3RUaWxlUHlyYW1pZC5wcm90b3R5cGUucm9vdFRvQmluID0gZnVuY3Rpb24oIHgsIHksIHRpbGUgKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yb290VG9GcmFjdGlvbmFsQmluKCB4LCB5LCB0aWxlICk7XHJcblx0XHRyZXN1bHQueCA9IE1hdGguZmxvb3IoIHJlc3VsdC54ICk7XHJcblx0XHRyZXN1bHQueSA9IE1hdGguZmxvb3IoIHJlc3VsdC55ICk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGEgcG9pbnQgZnJvbSB0aGUgcm9vdCBjb29yZGluYXRlIHN5c3RlbSB0byBhIHNwZWNpZmljIGJpbiBjb29yZGluYXRlLlxyXG4gICAgICogQG1lbWJlcm9mIEFyZWFPZkludGVyZXN0VGlsZVB5cmFtaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IHJvb3QgY29vcmRpbmF0ZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgcm9vdCBjb29yZGluYXRlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRpbGUgLSBUaGUgdGlsZSBjb29yZGluYXRlIHRoYXQgaG9sZHMgdGhlIHRhcmdldCBiaW4uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGJpbiBjb29yZGluYXRlLlxyXG4gICAgICovXHJcbiAgICBBcmVhT2ZJbnRlcmVzdFRpbGVQeXJhbWlkLnByb3RvdHlwZS5yb290VG9CaW4gPSBmdW5jdGlvbiggeCwgeSwgdGlsZSApIHtcclxuICAgICAgICB2YXIgcG93MiwgdGlsZVhTaXplLCB0aWxlWVNpemUsIHhJblRpbGUsIHlJblRpbGUsIGJpblgsIGJpblk7XHJcbiAgICAgICAgcG93MiA9IDEgPDwgdGlsZS5sZXZlbDtcclxuICAgICAgICB0aWxlWFNpemUgPSAodGhpcy5tYXhYIC0gdGhpcy5taW5YKSAvIHBvdzI7XHJcbiAgICAgICAgdGlsZVlTaXplID0gKHRoaXMubWF4WSAtIHRoaXMubWluWSkgLyBwb3cyO1xyXG4gICAgICAgIHhJblRpbGUgPSB4IC0gdGhpcy5taW5YIC0gdGlsZS54SW5kZXggKiB0aWxlWFNpemU7XHJcbiAgICAgICAgeUluVGlsZSA9IHkgLSB0aGlzLm1pblkgLSB0aWxlLnlJbmRleCAqIHRpbGVZU2l6ZTtcclxuICAgICAgICBiaW5YID0gTWF0aC5mbG9vcih4SW5UaWxlICogdGlsZS54QmluQ291bnQgLyB0aWxlWFNpemUpO1xyXG4gICAgICAgIGJpblkgPSBNYXRoLmZsb29yKHlJblRpbGUgKiB0aWxlLnlCaW5Db3VudCAvIHRpbGVZU2l6ZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogYmluWCxcclxuICAgICAgICAgICAgeTogdGlsZS55QmluQ291bnQgLSAxIC0gYmluWVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYm91bmRzIG9mIGEgcGFydGljdWxhciB0aWxlIGluIHRoZSByb290IGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAgICogQG1lbWJlcm9mIEFyZWFPZkludGVyZXN0VGlsZVB5cmFtaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGlsZSAtIFRoZSB0aWxlIGNvb3JkaW5hdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGJvdW5kcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIEFyZWFPZkludGVyZXN0VGlsZVB5cmFtaWQucHJvdG90eXBlLmdldFRpbGVCb3VuZHMgPSBmdW5jdGlvbiggdGlsZSApIHtcclxuICAgICAgICB2YXIgcG93MiwgdGlsZVhTaXplLCB0aWxlWVNpemU7XHJcbiAgICAgICAgcG93MiA9IDEgPDwgdGlsZS5sZXZlbDtcclxuICAgICAgICB0aWxlWFNpemUgPSAodGhpcy5tYXhYIC0gdGhpcy5taW5YKSAvIHBvdzI7XHJcbiAgICAgICAgdGlsZVlTaXplID0gKHRoaXMubWF4WSAtIHRoaXMubWluWSkgLyBwb3cyO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1pblg6IHRoaXMubWluWCArIHRpbGVYU2l6ZSAqIHRpbGUueEluZGV4LFxyXG4gICAgICAgICAgICBtaW5ZOiB0aGlzLm1pblkgKyB0aWxlWVNpemUgKiB0aWxlLnlJbmRleCxcclxuICAgICAgICAgICAgbWF4WDogdGhpcy5taW5YICsgdGlsZVhTaXplICogKHRpbGUueEluZGV4ICsgMSksXHJcbiAgICAgICAgICAgIG1heFk6IHRoaXMubWluWSArIHRpbGVZU2l6ZSAqICh0aWxlLnlJbmRleCArIDEpLFxyXG4gICAgICAgICAgICBjZW50ZXJYOiB0aGlzLm1pblggKyB0aWxlWFNpemUgKiAodGlsZS54SW5kZXggKyAwLjUpLFxyXG4gICAgICAgICAgICBjZW50ZXJZOiB0aGlzLm1pblkgKyB0aWxlWVNpemUgKiAodGlsZS55SW5kZXggKyAwLjUpLFxyXG4gICAgICAgICAgICB3aWR0aDogdGlsZVhTaXplLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRpbGVZU2l6ZVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYm91bmRzIG9mIGEgcGFydGljdWxhciBiaW4gaW4gdGhlIHJvb3QgY29vcmRpbmF0ZSBzeXN0ZW0uXHJcbiAgICAgKiBAbWVtYmVyb2YgQXJlYU9mSW50ZXJlc3RUaWxlUHlyYW1pZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aWxlIC0gVGhlIHRpbGUgY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiaW4gLSBUaGUgYmluIGNvb3JkaW5hdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGJvdW5kcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIEFyZWFPZkludGVyZXN0VGlsZVB5cmFtaWQucHJvdG90eXBlLmdldEJpbkJvdW5kcyA9IGZ1bmN0aW9uKCB0aWxlLCBiaW4gKSB7XHJcbiAgICAgICAgdmFyIHBvdzIsIHRpbGVYU2l6ZSwgdGlsZVlTaXplLCBiaW5YU2l6ZSwgYmluWVNpemUsIGFkanVzdGVkWSxcclxuICAgICAgICAgICAgbGVmdCwgYm90dG9tO1xyXG4gICAgICAgIHBvdzIgPSAxIDw8IHRpbGUubGV2ZWw7XHJcbiAgICAgICAgdGlsZVhTaXplID0gKHRoaXMubWF4WCAtIHRoaXMubWluWCkgLyBwb3cyO1xyXG4gICAgICAgIHRpbGVZU2l6ZSA9ICh0aGlzLm1heFkgLSB0aGlzLm1pblkpIC8gcG93MjtcclxuICAgICAgICBiaW5YU2l6ZSA9IHRpbGVYU2l6ZSAvIHRpbGUueEJpbkNvdW50O1xyXG4gICAgICAgIGJpbllTaXplID0gdGlsZVlTaXplIC8gdGlsZS55QmluQ291bnQ7XHJcbiAgICAgICAgYWRqdXN0ZWRZID0gdGlsZS55QmluQ291bnQgLSAxIC0gYmluLnk7XHJcbiAgICAgICAgbGVmdCA9IHRoaXMubWluWCArIHRpbGVYU2l6ZSAqIHRpbGUueEluZGV4O1xyXG4gICAgICAgIGJvdHRvbSA9IHRoaXMubWluWSArIHRpbGVZU2l6ZSAqIHRpbGUueUluZGV4O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1pblg6IGxlZnQgKyBiaW5YU2l6ZSAqIGJpbi54LFxyXG4gICAgICAgICAgICBtaW5ZOiBib3R0b20gKyBiaW5ZU2l6ZSAqIGFkanVzdGVkWSxcclxuICAgICAgICAgICAgbWF4WDogbGVmdCArIGJpblhTaXplICogKGJpbi54ICsgMSksXHJcbiAgICAgICAgICAgIG1heFk6IGJvdHRvbSArIGJpbllTaXplICogKGFkanVzdGVkWSArIDEpLFxyXG4gICAgICAgICAgICBjZW50ZXJYOiBsZWZ0ICsgYmluWFNpemUgKiAoYmluLnggKyAwLjUpLFxyXG4gICAgICAgICAgICBjZW50ZXJZOiBib3R0b20gKyBiaW5ZU2l6ZSAqIChhZGp1c3RlZFkgKyAwLjUpLFxyXG4gICAgICAgICAgICB3aWR0aDogYmluWFNpemUsXHJcbiAgICAgICAgICAgIGhlaWdodDogYmluWVNpemVcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0aWxlIHB5cmFtaWQgYXMgYSBzdHJpbmcuXHJcbiAgICAgKiBAbWVtYmVyb2YgQXJlYU9mSW50ZXJlc3RUaWxlUHlyYW1pZFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBib3VuZHMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBBcmVhT2ZJbnRlcmVzdFRpbGVQeXJhbWlkLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gJ3snK1xyXG4gICAgICAgICAgICAnXCJ0eXBlXCI6IFwiQXJlYU9mSW50ZXJlc3RcIiwnICtcclxuICAgICAgICAgICAgJ1wibWluWFwiOiB0aGlzLm1pblgsJyArXHJcbiAgICAgICAgICAgICdcIm1heFhcIjogdGhpcy5tYXhYLCcgK1xyXG4gICAgICAgICAgICAnXCJtaW5ZXCI6IHRoaXMubWluWSwnICtcclxuICAgICAgICAgICAgJ1wibWF4WVwiOiB0aGlzLm1heFknICtcclxuICAgICAgICAnfSc7XHJcbiAgICB9O1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IEFyZWFPZkludGVyZXN0VGlsZVB5cmFtaWQ7XHJcblxyXG59KCkpO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAcGFja2FnZSBiaW5uaW5nXHJcbiAqL1xyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGUgYSBUaWxlSXRlcmF0b3Igb2JqZWN0LlxyXG5cclxuICAgICAqIEBjbGFzcyBUaWxlSXRlcmF0b3JcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBUaWxlSXRlcmF0b3IgY2xhc3MsIHRoZSBlcXVpdmFsZW50IG9mIFRpbGVJdGVyYXRvclxyXG4gICAgICogICAgICAgICAgICBpbiB0aWxlLXNlcnZpY2UvYmlubmluZy11dGlsaXRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNwZWMgLSBUaGUgc3BlY2lmaWNhdGlvbiBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFRpbGVJdGVyYXRvciggc3BlYyApIHtcclxuICAgICAgICB0aGlzLnB5cmFtaWQgPSBzcGVjLnB5cmFtaWQ7XHJcbiAgICAgICAgdGhpcy5sZXZlbCA9IHNwZWMubGV2ZWw7XHJcbiAgICAgICAgdGhpcy5taW5UaWxlID0gc3BlYy5weXJhbWlkLnJvb3RUb1RpbGUoIHNwZWMubWluWCwgc3BlYy5taW5ZLCBzcGVjLmxldmVsICk7XHJcbiAgICAgICAgdGhpcy5tYXhUaWxlID0gc3BlYy5weXJhbWlkLnJvb3RUb1RpbGUoIHNwZWMubWF4WCwgc3BlYy5tYXhZLCBzcGVjLmxldmVsICk7XHJcbiAgICAgICAgdGhpcy5jdXJYID0gdGhpcy5taW5UaWxlLnhJbmRleDtcclxuICAgICAgICB0aGlzLmN1clkgPSB0aGlzLm1pblRpbGUueUluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGFub3RoZXIgdGlsZSwgZmFsc2UgaWYgdGhlcmUgaXNuJ3QuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGlsZUl0ZXJhdG9yXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IGEgbmV4dCB0aWxlIGV4aXN0cy5cclxuICAgICAqL1xyXG4gICAgVGlsZUl0ZXJhdG9yLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmN1clggPD0gdGhpcy5tYXhUaWxlLnhJbmRleCAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJZIDw9IHRoaXMubWF4VGlsZS55SW5kZXgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5leHQgdGlsZSBpbiB0aGUgaXRlcmF0b3IuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGlsZUl0ZXJhdG9yXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5leHQgdGlsZSBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIFRpbGVJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aWxlID0ge1xyXG4gICAgICAgICAgICB4SW5kZXg6IHRoaXMuY3VyWCxcclxuICAgICAgICAgICAgeUluZGV4OiB0aGlzLmN1clksXHJcbiAgICAgICAgICAgIGxldmVsOiB0aGlzLmxldmVsLFxyXG4gICAgICAgICAgICB4QmluQ291bnQ6IDI1NixcclxuICAgICAgICAgICAgeUJpbkNvdW50OiAyNTZcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuY3VyWCA9IHRoaXMuY3VyWCArIDE7XHJcbiAgICAgICAgaWYgKCB0aGlzLmN1clggPiB0aGlzLm1heFRpbGUueEluZGV4ICkge1xyXG4gICAgICAgICAgICB0aGlzLmN1clggPSB0aGlzLm1pblRpbGUueEluZGV4O1xyXG4gICAgICAgICAgICB0aGlzLmN1clkgPSB0aGlzLmN1clkgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGlsZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCByZW1haW5pbmcgdGlsZXMgdGhlIGl0ZXJhdG9yLlxyXG4gICAgICogQG1lbWJlcm9mIFRpbGVJdGVyYXRvclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQWxsIHRpbGVzIGxlZnQgaW4gdGhlIGl0ZXJhdG9yLlxyXG4gICAgICovXHJcbiAgICBUaWxlSXRlcmF0b3IucHJvdG90eXBlLmdldFJlc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFsbCA9IFtdO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICBhbGxbYWxsLmxlbmd0aF0gPSB0aGlzLm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFsbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5pbmcgYWxsIHJlbWFpbmluZyB0aWxlIGluZGljZXMgaW4gdGhlIGl0ZXJhdG9yLlxyXG4gICAgICogQG1lbWJlcm9mIFRpbGVJdGVyYXRvclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXh0IHRpbGUgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBUaWxlSXRlcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzcmVwID0gXCJcIiwgaW5kZXg7XHJcbiAgICAgICAgd2hpbGUgKCB0aGlzLmhhc05leHQoKSApIHtcclxuICAgICAgICAgICAgaWYgKCBzcmVwLmxlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBzcmVwID0gc3JlcCArIFwifFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5uZXh0KCk7XHJcbiAgICAgICAgICAgIHNyZXAgPSBzcmVwICsgXCJbXCIraW5kZXgueEluZGV4K1wiL1wiK2luZGV4LnhCaW5Db3VudCtcIixcIitpbmRleC55SW5kZXgrXCIvXCIraW5kZXgueUJpbkNvdW50K1wiLCBsdmwgXCIraW5kZXgubGV2ZWwrXCJdXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzcmVwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHRpbGUgYm91bmRzIG9mIGFsbCB0aWxlcyB3aXRoaW4gdGhlIGl0ZXJhdG9yLlxyXG4gICAgICogQG1lbWJlcm9mIFRpbGVJdGVyYXRvclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSB0aWxlIGJvdW5kcyBvZiB0aGUgaXRlcmF0b3IuXHJcbiAgICAgKi9cclxuICAgIFRpbGVJdGVyYXRvci5wcm90b3R5cGUudG9UaWxlQm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICdtaW5YJzogdGhpcy5taW5UaWxlLnhJbmRleCxcclxuICAgICAgICAgICAgJ21heFgnOiB0aGlzLm1heFRpbGUueEluZGV4LFxyXG4gICAgICAgICAgICAnbWluWSc6IHRoaXMubWluVGlsZS55SW5kZXgsXHJcbiAgICAgICAgICAgICdtYXhZJzogdGhpcy5tYXhUaWxlLnlJbmRleCxcclxuICAgICAgICAgICAgJ21pblonOiB0aGlzLmxldmVsLFxyXG4gICAgICAgICAgICAnbWF4Wic6IHRoaXMubGV2ZWxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRpbGVJdGVyYXRvcjtcclxufSgpKTtcclxuXHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cdHZhciBFUFNHXzkwMDkxM19TQ0FMRV9GQUNUT1IgPSAyMDAzNzUwOC4zNDI3ODkyNDQsXHJcblx0ICAgIEVQU0dfOTAwOTEzX0xBVElUVURFID0gODUuMDUxMTI4NzgsXHJcblx0ICAgIERFR1JFRVNfVE9fUkFESUFOUyA9IE1hdGguUEkgLyAxODAuMCxcdC8vIEZhY3RvciBmb3IgY2hhbmdpbmcgZGVncmVlcyB0byByYWRpYW5zXHJcblx0ICAgIFJBRElBTlNfVE9fREVHUkVFUyA9IDE4MC4wIC8gTWF0aC5QSTtcdC8vIEZhY3RvciBmb3IgY2hhbmdpbmcgcmFkaWFucyB0byBkZWdyZWVzXHJcblxyXG5cdGZ1bmN0aW9uIHJvb3RUb1RpbGVNZXJjYXRvciggbG9uLCBsYXQsIGxldmVsICkge1xyXG5cdFx0dmFyIGxhdFIgPSBsYXQgKiBERUdSRUVTX1RPX1JBRElBTlMsXHJcblx0XHQgICAgcG93MiA9IDEgPDwgbGV2ZWwsXHJcblx0XHQgICAgeCA9IChsb24gKyAxODAuMCkgLyAzNjAuMCAqIHBvdzIsXHJcblx0XHQgICAgeSA9IChwb3cyICogKDEgLSBNYXRoLmxvZyhNYXRoLnRhbihsYXRSKSArIDEgLyBNYXRoLmNvcyhsYXRSKSkgLyBNYXRoLlBJKSAvIDIpO1xyXG5cdFx0cmV0dXJuIHtcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogcG93MiAtIHlcclxuICAgICAgICB9O1xyXG5cdH1cclxuXHJcbiAgICBmdW5jdGlvbiBzaW5oKCBhcmcgKSB7XHJcbiAgICAgICAgcmV0dXJuIChNYXRoLmV4cChhcmcpIC0gTWF0aC5leHAoLWFyZykpIC8gMi4wO1xyXG4gICAgfVxyXG5cclxuXHRmdW5jdGlvbiB0aWxlVG9Mb24oIHgsIGxldmVsICkge1xyXG5cdFx0dmFyIHBvdzIgPSAxIDw8IGxldmVsO1xyXG5cdFx0cmV0dXJuIHggLyBwb3cyICogMzYwLjAgLSAxODAuMDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRpbGVUb0xhdCggeSwgbGV2ZWwgKSB7XHJcblx0XHR2YXIgcG93MiA9IDEgPDwgbGV2ZWwsXHJcblx0XHQgICAgbiAgICA9IC1NYXRoLlBJICsgKDIuMCAqIE1hdGguUEkgKiB5KSAvIHBvdzI7XHJcblx0XHRyZXR1cm4gTWF0aC5hdGFuKHNpbmgobikpICogUkFESUFOU19UT19ERUdSRUVTO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gbGluZWFyVG9HdWRlcm1hbm5pYW4oIHZhbHVlICkge1xyXG5cdFx0ZnVuY3Rpb24gZ3VkZXJtYW5uaWFuKCB5ICkge1xyXG5cdFx0XHQvLyBjb252ZXJ0cyBhIHkgdmFsdWUgZnJvbSAtUEkoYm90dG9tKSB0byBQSSh0b3ApIGludG8gdGhlXHJcblx0XHRcdC8vIG1lcmNhdG9yIHByb2plY3Rpb24gbGF0aXR1ZGVcclxuXHRcdFx0cmV0dXJuIE1hdGguYXRhbihzaW5oKHkpKSAqIFJBRElBTlNfVE9fREVHUkVFUztcclxuXHRcdH1cclxuXHRcdHJldHVybiBndWRlcm1hbm5pYW4oICh2YWx1ZSAvIEVQU0dfOTAwOTEzX0xBVElUVURFKSAqIE1hdGguUEkgKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGd1ZGVybWFubmlhblRvTGluZWFyKHZhbHVlKSB7XHJcblx0XHRmdW5jdGlvbiBndWRlcm1hbm5pYW5JbnYoIGxhdGl0dWRlICkge1xyXG5cdFx0XHQvLyBjb252ZXJ0cyBhIGxhdGl0dWRlIHZhbHVlIGZyb20gLUVQU0dfOTAwOTEzX0xBVElUVURFIHRvIEVQU0dfOTAwOTEzX0xBVElUVURFIGludG9cclxuXHRcdFx0Ly8gYSB5IHZhbHVlIGZyb20gLVBJKGJvdHRvbSkgdG8gUEkodG9wKVxyXG5cdFx0XHR2YXIgc2lnbiA9ICggbGF0aXR1ZGUgIT09IDAgKSA/IGxhdGl0dWRlIC8gTWF0aC5hYnMobGF0aXR1ZGUpIDogMCxcclxuXHRcdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdGl0dWRlICogREVHUkVFU19UT19SQURJQU5TICogc2lnbik7XHJcblx0XHRcdHJldHVybiBzaWduICogKE1hdGgubG9nKCgxLjAgKyBzaW4pIC8gKDEuMCAtIHNpbikpIC8gMi4wKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAoZ3VkZXJtYW5uaWFuSW52KCB2YWx1ZSApIC8gTWF0aC5QSSkgKiBFUFNHXzkwMDkxM19MQVRJVFVERTtcclxuXHR9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW50aWF0ZSBhIFdlYk1lcmNhdG9yVGlsZVB5cmFtaWQgb2JqZWN0LlxyXG4gICAgICogQGNsYXNzIFdlYk1lcmNhdG9yVGlsZVB5cmFtaWRcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBUaWxlUHlyYW1pZCBpbXBsZW1lbnRhdGlvbiwgdGhlIGVxdWl2YWxlbnQgb2YgV2ViTWVyY2F0b3JUaWxlUHlyYW1pZFxyXG4gICAgICogICAgICAgICAgICBpbiB0aWxlLXNlcnZpY2UvYmlubmluZy11dGlsaXRpZXMuXHJcbiAgICAgKi9cclxuXHRmdW5jdGlvbiBXZWJNZXJjYXRvclRpbGVQeXJhbWlkKCkge1xyXG4gICAgICAgIHRoaXMubWluWCA9IC0xODAuMDtcclxuICAgICAgICB0aGlzLm1pblkgPSAtODUuMDU7XHJcbiAgICAgICAgdGhpcy5tYXhYID0gMTgwLjA7XHJcbiAgICAgICAgdGhpcy5tYXhZID0gODUuMDU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uIGNvZGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBweXJhbWlkLlxyXG4gICAgICogQG1lbWJlcm9mIFdlYk1lcmNhdG9yVGlsZVB5cmFtaWRcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcHJvamVjdGlvbiBjb2RlLlxyXG4gICAgICovXHJcbiAgICBXZWJNZXJjYXRvclRpbGVQeXJhbWlkLnByb3RvdHlwZS5nZXRQcm9qZWN0aW9uID0gZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gXCJFUFNHOjkwMDkxM1wiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHRpbGUgc2NoZW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHlyYW1pZC5cclxuICAgICAqIEBtZW1iZXJvZiBXZWJNZXJjYXRvclRpbGVQeXJhbWlkXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHNjaGVtZSBjb2RlLlxyXG4gICAgICovXHJcbiAgICBXZWJNZXJjYXRvclRpbGVQeXJhbWlkLnByb3RvdHlwZS5nZXRUaWxlU2NoZW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiVE1TXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhIGZyYWN0aW9uYWwgdGlsZSBjb29yZGluYXRlIHRvIGEgcG9pbnQgaW4gdGhlIHJvb3QgY29vcmRpbmF0ZSBzeXN0ZW0uXHJcbiAgICAgKiBAbWVtYmVyb2YgV2ViTWVyY2F0b3JUaWxlUHlyYW1pZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aWxlIC0gVGhlIGZyYWN0aW9uYWwgdGlsZSBjb29yZGluYXRlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByb290IGNvb3JkaW5hdGUuXHJcbiAgICAgKi9cclxuICAgIFdlYk1lcmNhdG9yVGlsZVB5cmFtaWQucHJvdG90eXBlLmZyYWN0aW9uYWxUaWxlVG9Sb290ID0gZnVuY3Rpb24oIHRpbGUgKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbG9uOiB0aWxlVG9Mb24oIHRpbGUueEluZGV4LCB0aWxlLmxldmVsICksXHJcbiAgICAgICAgICAgIGxhdDogdGlsZVRvTGF0KCB0aWxlLnlJbmRleCwgdGlsZS5sZXZlbCApXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGEgcG9pbnQgZnJvbSB0aGUgcm9vdCBjb29yZGluYXRlIHN5c3RlbSB0byBhIGZyYWN0aW9uYWwgdGlsZSBjb29yZGluYXRlLlxyXG4gICAgICogQG1lbWJlcm9mIFdlYk1lcmNhdG9yVGlsZVB5cmFtaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9uIC0gVGhlIGxvbmdpdHVkZSBjb29yZGluYXRlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhdCAtIFRoZSBsYXRpdHVkZSBjb29yZGluYXRlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBsZXZlbCAtIFRoZSB6b29tIGxldmVsLlxyXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBiaW5zIC0gVGhlIG51bWJlciBvZiBiaW5zIHBlciBkaW1lbnNpb24gaW4gYSB0aWxlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmcmFjdGlvbmFsIHRpbGUgY29vcmRpbmF0ZS5cclxuICAgICAqL1xyXG4gICAgV2ViTWVyY2F0b3JUaWxlUHlyYW1pZC5wcm90b3R5cGUucm9vdFRvRnJhY3Rpb25hbFRpbGUgPSBmdW5jdGlvbiggbG9uLCBsYXQsIGxldmVsLCBiaW5zICkge1xyXG5cdFx0YmlucyA9IGJpbnMgfHwgMjU2O1xyXG4gICAgICAgIHZhciB0aWxlTWVyY2F0b3IgPSByb290VG9UaWxlTWVyY2F0b3IoIGxvbiwgbGF0LCBsZXZlbCApO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcclxuICAgICAgICAgICAgeEluZGV4OiB0aWxlTWVyY2F0b3IueCxcclxuICAgICAgICAgICAgeUluZGV4OiB0aWxlTWVyY2F0b3IueSxcclxuICAgICAgICAgICAgeEJpbkNvdW50OiBiaW5zLFxyXG4gICAgICAgICAgICB5QmluQ291bnQ6IGJpbnNcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYSBwb2ludCBmcm9tIHRoZSByb290IGNvb3JkaW5hdGUgc3lzdGVtIHRvIGEgdGlsZSBjb29yZGluYXRlLlxyXG4gICAgICogQG1lbWJlcm9mIFdlYk1lcmNhdG9yVGlsZVB5cmFtaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9uIC0gVGhlIGxvbmdpdHVkZSBjb29yZGluYXRlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhdCAtIFRoZSBsYXRpdHVkZSBjb29yZGluYXRlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBsZXZlbCAtIFRoZSB6b29tIGxldmVsLlxyXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBiaW5zIC0gVGhlIG51bWJlciBvZiBiaW5zIHBlciBkaW1lbnNpb24gaW4gYSB0aWxlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSB0aWxlIGNvb3JkaW5hdGUuXHJcbiAgICAgKi9cclxuICAgIFdlYk1lcmNhdG9yVGlsZVB5cmFtaWQucHJvdG90eXBlLnJvb3RUb1RpbGUgPSBmdW5jdGlvbiggbG9uLCBsYXQsIGxldmVsLCBiaW5zICkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IHRoaXMucm9vdFRvRnJhY3Rpb25hbFRpbGUoIGxvbiwgbGF0LCBsZXZlbCwgYmlucyApO1xyXG5cdFx0cmVzdWx0LnhJbmRleCA9IE1hdGguZmxvb3IoIHJlc3VsdC54SW5kZXggKTtcclxuXHRcdHJlc3VsdC55SW5kZXggPSBNYXRoLmZsb29yKCByZXN1bHQueUluZGV4ICk7XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcblx0LyoqXHJcbiAgICAgKiBNYXBzIGEgcG9pbnQgZnJvbSB0aGUgcm9vdCBjb29yZGluYXRlIHN5c3RlbSB0byBhIHNwZWNpZmljIGZyYWN0aW9uYWxcclxuXHQgKiBiaW4gY29vcmRpbmF0ZS5cclxuICAgICAqIEBtZW1iZXJvZiBXZWJNZXJjYXRvclRpbGVQeXJhbWlkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvbiAtIFRoZSBsb25naXR1ZGUgY29vcmRpbmF0ZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgLSBUaGUgbGF0aXR1ZGUgY29vcmRpbmF0ZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aWxlIC0gVGhlIHRpbGUgY29vcmRpbmF0ZSB0aGF0IGhvbGRzIHRoZSB0YXJnZXQgYmluLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBiaW4gY29vcmRpbmF0ZS5cclxuICAgICAqL1xyXG4gICAgV2ViTWVyY2F0b3JUaWxlUHlyYW1pZC5wcm90b3R5cGUucm9vdFRvRnJhY3Rpb25hbEJpbiA9IGZ1bmN0aW9uKCBsb24sIGxhdCwgdGlsZSApIHtcclxuICAgICAgICB2YXIgdGlsZU1lcmNhdG9yID0gcm9vdFRvVGlsZU1lcmNhdG9yKCBsb24sIGxhdCwgdGlsZS5sZXZlbCApO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6ICh0aWxlTWVyY2F0b3IueCAtIHRpbGUueEluZGV4KSAqIHRpbGUueEJpbkNvdW50LFxyXG4gICAgICAgICAgICB5OiB0aWxlLnlCaW5Db3VudCAtIDEgLSAodGlsZU1lcmNhdG9yLnkgLSB0aWxlLnlJbmRleCApICogdGlsZS55QmluQ291bnRcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYSBwb2ludCBmcm9tIHRoZSByb290IGNvb3JkaW5hdGUgc3lzdGVtIHRvIGEgc3BlY2lmaWMgYmluIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgV2ViTWVyY2F0b3JUaWxlUHlyYW1pZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb24gLSBUaGUgbG9uZ2l0dWRlIGNvb3JkaW5hdGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF0IC0gVGhlIGxhdGl0dWRlIGNvb3JkaW5hdGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGlsZSAtIFRoZSB0aWxlIGNvb3JkaW5hdGUgdGhhdCBob2xkcyB0aGUgdGFyZ2V0IGJpbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgYmluIGNvb3JkaW5hdGUuXHJcbiAgICAgKi9cclxuICAgIFdlYk1lcmNhdG9yVGlsZVB5cmFtaWQucHJvdG90eXBlLnJvb3RUb0JpbiA9IGZ1bmN0aW9uKCBsb24sIGxhdCwgdGlsZSApIHtcclxuXHRcdHZhciByZXN1bHQgPSB0aGlzLnJvb3RUb0ZyYWN0aW9uYWxCaW4oIGxvbiwgbGF0LCB0aWxlICk7XHJcblx0XHRyZXN1bHQueCA9IE1hdGguZmxvb3IoIHJlc3VsdC54ICk7XHJcblx0XHRyZXN1bHQueSA9IE1hdGguZmxvb3IoIHJlc3VsdC55ICk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBib3VuZHMgb2YgYSBwYXJ0aWN1bGFyIHRpbGUgaW4gRVBTRyA5MDA5MTMgbWV0ZXIgdW5pdHMuXHJcbiAgICAgKiBAbWVtYmVyb2YgV2ViTWVyY2F0b3JUaWxlUHlyYW1pZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aWxlIC0gVGhlIHRpbGUgY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiaW4gLSBUaGUgYmluIGNvb3JkaW5hdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGJvdW5kcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIFdlYk1lcmNhdG9yVGlsZVB5cmFtaWQucHJvdG90eXBlLmdldEVQU0c5MDA5MTNCb3VuZHMgPSBmdW5jdGlvbiggdGlsZSwgYmluICkge1xyXG4gICAgICAgIHZhciBwb3cyID0gMSA8PCB0aWxlLmxldmVsLFxyXG4gICAgICAgICAgICB0aWxlSW5jcmVtZW50ID0gMS4wL3BvdzIsXHJcbiAgICAgICAgICAgIG1pblggPSB0aWxlLnhJbmRleCAqIHRpbGVJbmNyZW1lbnQgLSAwLjUsXHJcbiAgICAgICAgICAgIG1pblkgPSB0aWxlLnlJbmRleCAqIHRpbGVJbmNyZW1lbnQgLSAwLjUsXHJcbiAgICAgICAgICAgIG1heFgsXHJcbiAgICAgICAgICAgIG1heFksXHJcbiAgICAgICAgICAgIGxpbk1pblksXHJcbiAgICAgICAgICAgIGxpbk1heFksXHJcbiAgICAgICAgICAgIGJpblhJbmMsXHJcbiAgICAgICAgICAgIGJpbllJbmMsXHJcbiAgICAgICAgICAgIGNlbnRlclk7XHJcblxyXG4gICAgICAgIGlmICggYmluICkge1xyXG4gICAgICAgICAgICBtYXhYID0gbWluWCArIHRpbGVJbmNyZW1lbnQ7XHJcbiAgICAgICAgICAgIG1heFkgPSBtaW5ZICsgdGlsZUluY3JlbWVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBiaW5YSW5jID0gdGlsZUluY3JlbWVudCAvIHRpbGUueEJpbkNvdW50O1xyXG4gICAgICAgICAgICBiaW5ZSW5jID0gdGlsZUluY3JlbWVudCAvIHRpbGUueUJpbkNvdW50O1xyXG4gICAgICAgICAgICBtaW5YID0gbWluWCArIGJpbi54ICogYmluWEluYztcclxuICAgICAgICAgICAgbWluWSA9IG1pblkgKyAodGlsZS55QmluQ291bnQgLSBiaW4ueSAtIDEpICogYmluWUluYztcclxuICAgICAgICAgICAgbWF4WCA9IG1pblggKyBiaW5YSW5jO1xyXG4gICAgICAgICAgICBtYXhZID0gbWluWSArIGJpbllJbmM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcyBtZXJjYXRvciBsYXRpdHVkZSBjYW5ub3QgYmUgbGluZWFybHkgaW50ZXJwb2xhdGVkLCBjb252ZXJ0IHRoZSBndWRlcm1hbm5pYW5cclxuICAgICAgICAvLyBjb29yZGluYXRlcyBiYWNrIGludG8gdGhlaXIgZXF1aXZhbGVudCBsaW5lYXIgY291bnRlcnBhcnRzLiBJbnRlcnBvbGF0ZSB0aGVzZSxcclxuICAgICAgICAvLyB0aGVuIGNvbnZlcnQgdG8gdGhlIGVxdWl2YWxlbnQgZ3VkZXJtYW5uaWFuIGNvb3JkaW5hdGUuXHJcbiAgICAgICAgbGluTWF4WSA9IGd1ZGVybWFubmlhblRvTGluZWFyKCBtYXhZICk7XHJcbiAgICAgICAgbGluTWluWSA9IGd1ZGVybWFubmlhblRvTGluZWFyKCBtaW5ZICk7XHJcbiAgICAgICAgY2VudGVyWSA9IGxpbmVhclRvR3VkZXJtYW5uaWFuKCAobGluTWF4WStsaW5NaW5ZKS8yICk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1pblg6ICAgIG1pblggKiAyLjAgKiBFUFNHXzkwMDkxM19TQ0FMRV9GQUNUT1IsXHJcbiAgICAgICAgICAgIG1pblk6ICAgIG1pblkgKiAyLjAgKiBFUFNHXzkwMDkxM19TQ0FMRV9GQUNUT1IsXHJcbiAgICAgICAgICAgIG1heFg6ICAgIG1heFggKiAyLjAgKiBFUFNHXzkwMDkxM19TQ0FMRV9GQUNUT1IsXHJcbiAgICAgICAgICAgIG1heFk6ICAgIG1heFkgKiAyLjAgKiBFUFNHXzkwMDkxM19TQ0FMRV9GQUNUT1IsXHJcbiAgICAgICAgICAgIGNlbnRlclg6IChtaW5YICsgbWF4WCkgKiBFUFNHXzkwMDkxM19TQ0FMRV9GQUNUT1IsIC8vIChtaW5YK21heFgpLzIuMCoyLjAgb3B0aW1pemVkIHRvIChtaW5YK21heFgpXHJcbiAgICAgICAgICAgIGNlbnRlclk6IGNlbnRlclkgKiAyLjAgKiBFUFNHXzkwMDkxM19TQ0FMRV9GQUNUT1IsXHJcbiAgICAgICAgICAgIHdpZHRoOiAgIChtYXhYIC0gbWluWCkgKiAyLjAgKiBFUFNHXzkwMDkxM19TQ0FMRV9GQUNUT1IsXHJcbiAgICAgICAgICAgIGhlaWdodDogIChtYXhZIC0gbWluWSkgKiAyLjAgKiBFUFNHXzkwMDkxM19TQ0FMRV9GQUNUT1JcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJvdW5kcyBvZiBhIHBhcnRpY3VsYXIgdGlsZSBpbiB0aGUgcm9vdCBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgICAqIEBtZW1iZXJvZiBXZWJNZXJjYXRvclRpbGVQeXJhbWlkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRpbGUgLSBUaGUgdGlsZSBjb29yZGluYXRlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBib3VuZHMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBXZWJNZXJjYXRvclRpbGVQeXJhbWlkLnByb3RvdHlwZS5nZXRUaWxlQm91bmRzID0gZnVuY3Rpb24oIHRpbGUgKSB7XHJcbiAgICAgICAgdmFyIGxldmVsID0gdGlsZS5sZXZlbCxcclxuICAgICAgICAgICAgbm9ydGggPSB0aWxlVG9MYXQoIHRpbGUueUluZGV4KzEsIGxldmVsICksXHJcbiAgICAgICAgICAgIHNvdXRoID0gdGlsZVRvTGF0KCB0aWxlLnlJbmRleCwgbGV2ZWwgKSxcclxuICAgICAgICAgICAgZWFzdCA9IHRpbGVUb0xvbiggdGlsZS54SW5kZXgrMSwgbGV2ZWwgKSxcclxuICAgICAgICAgICAgd2VzdCA9IHRpbGVUb0xvbiggdGlsZS54SW5kZXgsIGxldmVsICksXHJcbiAgICAgICAgICAgIC8vIGFzIG1lcmNhdG9yIGxhdGl0dWRlIGNhbm5vdCBiZSBsaW5lYXJseSBpbnRlcnBvbGF0ZWQsIGNvbnZlcnQgdGhlIGd1ZGVybWFubmlhblxyXG4gICAgICAgICAgICAvLyBjb29yZGluYXRlcyBiYWNrIGludG8gdGhlaXIgZXF1aXZhbGVudCBsaW5lYXIgY291bnRlcnBhcnRzLiBJbnRlcnBvbGF0ZSB0aGVzZSxcclxuICAgICAgICAgICAgLy8gdGhlbiBjb252ZXJ0IHRvIHRoZSBlcXVpdmFsZW50IGd1ZGVybWFubmlhbiBjb29yZGluYXRlLlxyXG4gICAgICAgICAgICBsaW5Ob3J0aCA9IGd1ZGVybWFubmlhblRvTGluZWFyKCBub3J0aCApLFxyXG4gICAgICAgICAgICBsaW5Tb3V0aCA9IGd1ZGVybWFubmlhblRvTGluZWFyKCBzb3V0aCApLFxyXG4gICAgICAgICAgICBjZW50ZXJZID0gbGluZWFyVG9HdWRlcm1hbm5pYW4oIChsaW5Ob3J0aCtsaW5Tb3V0aCkvMi4wICk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWluWDogd2VzdCxcclxuICAgICAgICAgICAgbWluWTogc291dGgsXHJcbiAgICAgICAgICAgIG1heFg6IGVhc3QsXHJcbiAgICAgICAgICAgIG1heFk6IG5vcnRoLFxyXG4gICAgICAgICAgICBjZW50ZXJYOiAoZWFzdCt3ZXN0KS8yLjAsXHJcbiAgICAgICAgICAgIGNlbnRlclk6IGNlbnRlclksXHJcbiAgICAgICAgICAgIHdpZHRoOiAoZWFzdC13ZXN0KSxcclxuICAgICAgICAgICAgaGVpZ2h0OiAobm9ydGgtc291dGgpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBib3VuZHMgb2YgYSBwYXJ0aWN1bGFyIGJpbiBpbiB0aGUgcm9vdCBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgICAqIEBtZW1iZXJvZiBXZWJNZXJjYXRvclRpbGVQeXJhbWlkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRpbGUgLSBUaGUgdGlsZSBjb29yZGluYXRlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJpbiAtIFRoZSBiaW4gY29vcmRpbmF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgYm91bmRzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgV2ViTWVyY2F0b3JUaWxlUHlyYW1pZC5wcm90b3R5cGUuZ2V0QmluQm91bmRzID0gZnVuY3Rpb24oIHRpbGUsIGJpbiApIHtcclxuICAgICAgICB2YXIgbGV2ZWwgPSB0aWxlLmxldmVsLFxyXG4gICAgICAgICAgICBiaW5YSW5jID0gMS4wIC8gdGlsZS54QmluQ291bnQsXHJcbiAgICAgICAgICAgIGJhc2VYID0gdGlsZS54SW5kZXggKyBiaW4ueCAqIGJpblhJbmMsXHJcbiAgICAgICAgICAgIGJpbllJbmMgPSAxLjAgLyB0aWxlLnlCaW5Db3VudCxcclxuICAgICAgICAgICAgYmFzZVkgPSB0aWxlLnlJbmRleCArICh0aWxlLnlCaW5Db3VudCAtIDEgLSBiaW4ueSkgKiBiaW5ZSW5jLFxyXG4gICAgICAgICAgICBub3J0aCA9IHRpbGVUb0xhdChiYXNlWSArIGJpbllJbmMsIGxldmVsKSxcclxuICAgICAgICAgICAgc291dGggPSB0aWxlVG9MYXQoYmFzZVksIGxldmVsKSxcclxuICAgICAgICAgICAgZWFzdCA9IHRpbGVUb0xvbihiYXNlWCArIGJpblhJbmMsIGxldmVsKSxcclxuICAgICAgICAgICAgd2VzdCA9IHRpbGVUb0xvbihiYXNlWCwgbGV2ZWwpLFxyXG4gICAgICAgICAgICAvLyBhcyBtZXJjYXRvciBsYXRpdHVkZSBjYW5ub3QgYmUgbGluZWFybHkgaW50ZXJwb2xhdGVkLCBjb252ZXJ0IHRoZSBndWRlcm1hbm5pYW5cclxuICAgICAgICAgICAgLy8gY29vcmRpbmF0ZXMgYmFjayBpbnRvIHRoZWlyIGVxdWl2YWxlbnQgbGluZWFyIGNvdW50ZXJwYXJ0cy4gSW50ZXJwb2xhdGUgdGhlc2UsXHJcbiAgICAgICAgICAgIC8vIHRoZW4gY29udmVydCB0byB0aGUgZXF1aXZhbGVudCBndWRlcm1hbm5pYW4gY29vcmRpbmF0ZS5cclxuICAgICAgICAgICAgbGluTm9ydGggPSBndWRlcm1hbm5pYW5Ub0xpbmVhcihub3J0aCksXHJcbiAgICAgICAgICAgIGxpblNvdXRoID0gZ3VkZXJtYW5uaWFuVG9MaW5lYXIoc291dGgpLFxyXG4gICAgICAgICAgICBjZW50ZXJZID0gbGluZWFyVG9HdWRlcm1hbm5pYW4oIChsaW5Ob3J0aCtsaW5Tb3V0aCkvMi4wICk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWluWDogd2VzdCxcclxuICAgICAgICAgICAgbWluWTogc291dGgsXHJcbiAgICAgICAgICAgIG1heFg6IGVhc3QsXHJcbiAgICAgICAgICAgIG1heFk6IG5vcnRoLFxyXG4gICAgICAgICAgICBjZW50ZXJYOiAoZWFzdCt3ZXN0KS8yLjAsXHJcbiAgICAgICAgICAgIGNlbnRlclk6IGNlbnRlclksXHJcbiAgICAgICAgICAgIHdpZHRoOiAoZWFzdC13ZXN0KSxcclxuICAgICAgICAgICAgaGVpZ2h0OiAobm9ydGgtc291dGgpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdGlsZSBweXJhbWlkIGFzIGEgc3RyaW5nLlxyXG4gICAgICogQG1lbWJlcm9mIFdlYk1lcmNhdG9yVGlsZVB5cmFtaWRcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgYm91bmRzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgV2ViTWVyY2F0b3JUaWxlUHlyYW1pZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAneycrXHJcbiAgICAgICAgICAgICdcInR5cGVcIjogXCJXZWJNZXJjYXRvclwiJytcclxuICAgICAgICAnfSc7XHJcbiAgICB9O1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFdlYk1lcmNhdG9yVGlsZVB5cmFtaWQ7XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgTGF5ZXIgPSByZXF1aXJlKCcuL0xheWVyJyksXHJcbiAgICAgICAgTGF5ZXJVdGlsID0gcmVxdWlyZSgnLi9MYXllclV0aWwnKSxcclxuICAgICAgICBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyksXHJcbiAgICAgICAgQW5ub3RhdGlvblNlcnZpY2UgPSByZXF1aXJlKCcuLi9yZXN0L0Fubm90YXRpb25TZXJ2aWNlJyksXHJcbiAgICAgICAgSHRtbFRpbGVMYXllciA9IHJlcXVpcmUoJy4vSHRtbFRpbGVMYXllcicpLFxyXG4gICAgICAgIFB1YlN1YiA9IHJlcXVpcmUoJy4uL3V0aWwvUHViU3ViJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIGFuIGFubm90YXRpb24gb2JqZWN0IG1lZXRzIHRoZSBtaW5pbXVtIGF0dHJpYnV0ZSByZXF1aXJlbWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFubm90YXRpb24gLSBUaGUgYW5ub3RhdGlvbiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNBbm5vdGF0aW9uSW5wdXRWYWxpZCggYW5ub3RhdGlvbiApIHtcclxuICAgICAgICBpZiAoIGFubm90YXRpb24ueCA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIkFubm90YXRpb24gYXJndW1lbnQgaXMgbWlzc2luZyB0aGUgJ3gnIGF0dHJpYnV0ZVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIGFubm90YXRpb24ueSA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIkFubm90YXRpb24gYXJndW1lbnQgaXMgbWlzc2luZyB0aGUgJ3knIGF0dHJpYnV0ZVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIGFubm90YXRpb24ubGV2ZWwgPT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggXCJBbm5vdGF0aW9uIGFyZ3VtZW50IGlzIG1pc3NpbmcgdGhlICdsZXZlbCcgYXR0cmlidXRlXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggYW5ub3RhdGlvbi5yYW5nZSA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIkFubm90YXRpb24gYXJndW1lbnQgaXMgbWlzc2luZyB0aGUgJ3JhbmdlJyBhdHRyaWJ1dGVcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCBhbm5vdGF0aW9uLmdyb3VwID09PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIFwiQW5ub3RhdGlvbiBhcmd1bWVudCBpcyBtaXNzaW5nIHRoZSAnZ3JvdXAnIGF0dHJpYnV0ZVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIGFubm90YXRpb24uZGF0YSA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIkFubm90YXRpb24gYXJndW1lbnQgaXMgbWlzc2luZyB0aGUgJ2RhdGEnIGF0dHJpYnV0ZVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbnRpYXRlIGFuIEFubm90YXRpb25MYXllciBvYmplY3QuXHJcbiAgICAgKiBAY2xhc3MgQW5ub3RhdGlvbkxheWVyXHJcbiAgICAgKiBAYXVnbWVudHMgTGF5ZXJcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBjbGllbnQgcmVuZGVyZWQgbGF5ZXIgb2JqZWN0LiBVc2VzIEpTT04gZGF0YSByZXRyaWV2ZWQgZnJvbSB0aGVcclxuICAgICAqICAgICAgICAgICAgc2VydmVyIGluIGNvbmp1bmN0aW9uIHdpdGggYSBSZW5kZXJlciBvYmplY3Qgb3IgaHRtbCBmdW5jdGlvbiB0b1xyXG4gICAgICogICAgICAgICAgICBjcmVhdGUgaW50ZXJhY3RhYmxlIERPTSBlbGVtZW50cy4gQW5ub3RhdGlvbkxheWVycyBkaWZmZXIgZnJvbVxyXG4gICAgICogICAgICAgICAgICBDbGllbnRMYXllcnMgaW4gdGhhdCB0aGUgZGF0YSB0aGV5IHJlcHJlc2VudCBpcyBtdXRhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIC0gVGhlIHNwZWNpZmljYXRpb24gb2JqZWN0LlxyXG4gICAgICogPHByZT5cclxuICAgICAqIHtcclxuICAgICAqICAgICBvcGFjaXR5ICB7ZmxvYXR9ICAgIC0gVGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLiBEZWZhdWx0ID0gMS4wXHJcbiAgICAgKiAgICAgZW5hYmxlZCAge2Jvb2xlYW59ICAtIFdoZXRoZXIgdGhlIGxheWVyIGlzIHZpc2libGUgb3Igbm90LiBEZWZhdWx0ID0gdHJ1ZVxyXG4gICAgICogICAgIHpJbmRleCAgIHtpbnRlZ2VyfSAgLSBUaGUgeiBpbmRleCBvZiB0aGUgbGF5ZXIuIERlZmF1bHQgPSAxMDAwXHJcbiAgICAgKiAgICAgcmVuZGVyZXIge1JlbmRlcmVyfSAtIFRoZSB0aWxlIHJlbmRlcmVyIG9iamVjdC5cclxuICAgICAqIH1cclxuICAgICAqIDwvcHJlPlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBBbm5vdGF0aW9uTGF5ZXIoIHNwZWMgKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgICAgICBnZXRVUkwgPSBzcGVjLmdldFVSTCB8fCBMYXllclV0aWwuZ2V0VVJMO1xyXG4gICAgICAgIC8vIGNhbGwgYmFzZSBjb25zdHJ1Y3RvclxyXG4gICAgICAgIExheWVyLmNhbGwoIHRoaXMsIHNwZWMgKTtcclxuICAgICAgICAvLyBzZXQgcmVhc29uYWJsZSBkZWZhdWx0c1xyXG4gICAgICAgIHRoaXMuekluZGV4ID0gKCBzcGVjLnpJbmRleCAhPT0gdW5kZWZpbmVkICkgPyBwYXJzZUludCggc3BlYy56SW5kZXgsIDEwICkgOiA1MDA7XHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBzcGVjLmZpbHRlciB8fCB7fTtcclxuICAgICAgICB0aGlzLmRvbWFpbiA9IFwiYW5ub3RhdGlvblwiO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc3BlYy5zb3VyY2U7XHJcbiAgICAgICAgdGhpcy5nZXRVUkwgPSBmdW5jdGlvbiggYm91bmRzICkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0VVJMLmNhbGwoIHRoaXMsIGJvdW5kcyApICsgdGhhdC5nZXRRdWVyeVBhcmFtU3RyaW5nKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIHNwZWMudGlsZUNsYXNzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlsZUNsYXNzID0gc3BlYy50aWxlQ2xhc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggc3BlYy5yZW5kZXJlciApIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRSZW5kZXJlciggc3BlYy5yZW5kZXJlciApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBBbm5vdGF0aW9uTGF5ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGF5ZXIucHJvdG90eXBlICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIGxheWVyIG9iamVjdC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG4gICAgICogQG1lbWJlcm9mIEFubm90YXRpb25MYXllclxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQW5ub3RhdGlvbkxheWVyLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGFkZCB0aGUgbmV3IGxheWVyXHJcbiAgICAgICAgdGhpcy5vbExheWVyID0gbmV3IEh0bWxUaWxlTGF5ZXIoXHJcbiAgICAgICAgICAgICdBbm5vdGF0aW9uIFRpbGUgTGF5ZXInLFxyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZS50bXMsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxheWVybmFtZTogdGhpcy5zb3VyY2UuaWQsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgICAgICBtYXhFeHRlbnQ6IG5ldyBPcGVuTGF5ZXJzLkJvdW5kcygtMjAwMzc1MDAsIC0yMDAzNzUwMCxcclxuICAgICAgICAgICAgICAgICAgICAyMDAzNzUwMCwgIDIwMDM3NTAwKSxcclxuICAgICAgICAgICAgICAgIGlzQmFzZUxheWVyOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGdldFVSTDogdGhpcy5nZXRVUkwsXHJcbiAgICAgICAgICAgICAgICB0aWxlQ2xhc3M6IHRoaXMudGlsZUNsYXNzLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHRoaXMucmVuZGVyZXJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gc2V0IHdoZXRoZXIgaXQgaXMgZW5hYmxlZCBvciBub3QgYmVmb3JlIGF0dGFjaGluZywgdG8gcHJldmVudFxyXG4gICAgICAgIC8vIG5lZWRsZXNzIHRpbGUgcmVxdWVzdHNcclxuICAgICAgICB0aGlzLnNldEVuYWJsZWQoIHRoaXMuaXNFbmFibGVkKCkgKTtcclxuICAgICAgICB0aGlzLnNldFRoZW1lKCB0aGlzLm1hcC5nZXRUaGVtZSgpICk7XHJcbiAgICAgICAgdGhpcy5zZXRPcGFjaXR5KCB0aGlzLmdldE9wYWNpdHkoKSApO1xyXG4gICAgICAgIHRoaXMuc2V0QnJpZ2h0bmVzcyggdGhpcy5nZXRCcmlnaHRuZXNzKCkgKTtcclxuICAgICAgICB0aGlzLnNldENvbnRyYXN0KCB0aGlzLmdldENvbnRyYXN0KCkgKTtcclxuICAgICAgICAvLyBwdWJsaXNoIGFjdGl2YXRlIGV2ZW50IGJlZm9yZSBhcHBlbmRpbmcgdG8gbWFwXHJcbiAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnYWN0aXZhdGUnLCB2YWx1ZTogdHJ1ZSB9ICk7XHJcbiAgICAgICAgLy8gYXR0YWNoIHRvIG1hcFxyXG4gICAgICAgIHRoaXMubWFwLm9sTWFwLmFkZExheWVyKCB0aGlzLm9sTGF5ZXIgKTtcclxuICAgICAgICAvLyBzZXQgei1pbmRleCBhZnRlclxyXG4gICAgICAgIHRoaXMuc2V0WkluZGV4KCB0aGlzLnpJbmRleCApO1xyXG4gICAgICAgIC8vIHB1Ymxpc2ggYWRkIGV2ZW50XHJcbiAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnYWRkJywgdmFsdWU6IHRydWUgfSApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY3RpdmF0ZXMgdGhlIGxheWVyIG9iamVjdC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG4gICAgICogQG1lbWJlcm9mIEFubm90YXRpb25MYXllclxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQW5ub3RhdGlvbkxheWVyLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLm9sTGF5ZXIgKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLm9sTWFwLnJlbW92ZUxheWVyKCB0aGlzLm9sTGF5ZXIgKTtcclxuICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAncmVtb3ZlJywgdmFsdWU6IHRydWUgfSApO1xyXG4gICAgICAgICAgICB0aGlzLm9sTGF5ZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLm9sTGF5ZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICdkZWFjdGl2YXRlJywgdmFsdWU6IHRydWUgfSApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgcmVuZGVyZXIgb2YgdGhlIGxheWVyLlxyXG4gICAgICogQG1lbWJlcm9mIEFubm90YXRpb25MYXllclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRvIGF0dGFjaCB0byB0aGUgbGF5ZXIuXHJcbiAgICAgKi9cclxuICAgICBBbm5vdGF0aW9uTGF5ZXIucHJvdG90eXBlLnNldFJlbmRlcmVyID0gZnVuY3Rpb24oIHJlbmRlcmVyICkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmF0dGFjaCggdGhpcyApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHRoZW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgQW5ub3RhdGlvbkxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRoZW1lIC0gVGhlIHRoZW1lIGlkZW50aWZpZXIgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBBbm5vdGF0aW9uTGF5ZXIucHJvdG90eXBlLnNldFRoZW1lID0gZnVuY3Rpb24oIHRoZW1lICkge1xyXG4gICAgICAgIHRoaXMudGhlbWUgPSB0aGVtZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdGhlbWUgZm9yIHRoZSBsYXllci5cclxuICAgICAqIEBtZW1iZXJvZiBBbm5vdGF0aW9uTGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdGhlbWUgaWRlbnRpZmllciBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIEFubm90YXRpb25MYXllci5wcm90b3R5cGUuZ2V0VGhlbWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aGVtZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHogaW5kZXggb2YgdGhlIGxheWVyLlxyXG4gICAgICogQG1lbWJlcm9mIEFubm90YXRpb25MYXllclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gekluZGV4IC0gVGhlIG5ldyB6LW9yZGVyIHZhbHVlIG9mIHRoZSBsYXllciwgd2hlcmUgMCBpcyBmcm9udC5cclxuICAgICAqL1xyXG4gICAgQW5ub3RhdGlvbkxheWVyLnByb3RvdHlwZS5zZXRaSW5kZXggPSBmdW5jdGlvbiAoIHpJbmRleCApIHtcclxuICAgICAgICAvLyB3ZSBieS1wYXNzIHRoZSBPcGVuTGF5ZXJzLk1hcC5zZXRMYXllckluZGV4KCkgbWV0aG9kIGFuZCBtYW51YWxseVxyXG4gICAgICAgIC8vIHNldCB0aGUgei1pbmRleCBvZiB0aGUgbGF5ZXIgZGV2LiBzZXRMYXllckluZGV4IHNldHMgYSByZWxhdGl2ZVxyXG4gICAgICAgIC8vIGluZGV4IGJhc2VkIG9uIGN1cnJlbnQgbWFwIGxheWVycywgd2hpY2ggdGhlbiBzZXRzIGEgei1pbmRleC4gVGhpc1xyXG4gICAgICAgIC8vIGNhdXNlZCBpc3N1ZXMgd2l0aCBhc3luYyBsYXllciBsb2FkaW5nLlxyXG4gICAgICAgIHRoaXMuekluZGV4ID0gekluZGV4O1xyXG4gICAgICAgIGlmICggdGhpcy5vbExheWVyICkge1xyXG4gICAgICAgICAgICAkKCB0aGlzLm9sTGF5ZXIuZGl2ICkuY3NzKCAnei1pbmRleCcsIHpJbmRleCApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICd6SW5kZXgnLCB2YWx1ZTogekluZGV4IH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbGF5ZXJzIHpJbmRleC5cclxuICAgICAqIEBtZW1iZXJvZiBBbm5vdGF0aW9uTGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIHpJbmRleCBmb3IgdGhlIGxheWVyLlxyXG4gICAgICovXHJcbiAgICBBbm5vdGF0aW9uTGF5ZXIucHJvdG90eXBlLmdldFpJbmRleCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy56SW5kZXg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGUgdGhlIGEgbmV3IGFubm90YXRpb24gdG8gdGhlIGxheWVyLlxyXG4gICAgICogQG1lbWJlcm9mIEFubm90YXRpb25MYXllclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbm5vdGF0aW9uIC0gVGhlIHRhcmdldCBhbm5vdGF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0aW5nIG9uIHN1Y2Nlc3MuXHJcbiAgICAgKi9cclxuICAgIEFubm90YXRpb25MYXllci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiggYW5ub3RhdGlvbiwgY2FsbGJhY2sgKSB7XHJcbiAgICAgICAgaWYgKCAhaXNBbm5vdGF0aW9uSW5wdXRWYWxpZCggYW5ub3RhdGlvbiApICkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEFubm90YXRpb25TZXJ2aWNlLndyaXRlQW5ub3RhdGlvbihcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2UuaWQsXHJcbiAgICAgICAgICAgIGFubm90YXRpb24sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmVmcmVzaCB0aWxlXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RpZnkgYW4gZXhpc3RpbmcgYW5ub3RhdGlvbiBpbiB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgQW5ub3RhdGlvbkxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFubm90YXRpb24gLSBUaGUgdGFyZ2V0IGFubm90YXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBleGVjdXRpbmcgb24gc3VjY2Vzcy5cclxuICAgICAqL1xyXG4gICAgQW5ub3RhdGlvbkxheWVyLnByb3RvdHlwZS5tb2RpZnkgPSBmdW5jdGlvbiggYW5ub3RhdGlvbiwgY2FsbGJhY2sgKSB7XHJcbiAgICAgICAgaWYgKCAhaXNBbm5vdGF0aW9uSW5wdXRWYWxpZCggYW5ub3RhdGlvbiApICkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEFubm90YXRpb25TZXJ2aWNlLm1vZGlmeUFubm90YXRpb24oXHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlLmlkLFxyXG4gICAgICAgICAgICBhbm5vdGF0aW9uLFxyXG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlZnJlc2ggdGlsZVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFuIGV4aXN0aW5nIGFubm90YXRpb24gZnJvbSB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgQW5ub3RhdGlvbkxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNlcnRpZmljYXRlIC0gVGhlIHRhcmdldCBhbm5vdGF0aW9uIGNlcnRpZmljYXRlLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0aW5nIG9uIHN1Y2Nlc3MuXHJcbiAgICAgKi9cclxuICAgIEFubm90YXRpb25MYXllci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oIGNlcnRpZmljYXRlLCBjYWxsYmFjayApIHtcclxuICAgICAgICBBbm5vdGF0aW9uU2VydmljZS5yZW1vdmVBbm5vdGF0aW9uKFxyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5pZCxcclxuICAgICAgICAgICAgY2VydGlmaWNhdGUsXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAvLyBUT0RPOiByZWZyZXNoIHRpbGVcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcblx0LyoqXHJcbiAgICAgKiBTZXQgdGhlIGxheWVyJ3MgZmlsdGVyIGZ1bmN0aW9uIHR5cGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQW5ub3RhdGlvbkxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbHRlclR5cGUgLSBUaGUgYW5ub3RhdGlvbiBmaWx0ZXIgdHlwZS5cclxuICAgICAqL1xyXG4gICAgQW5ub3RhdGlvbkxheWVyLnByb3RvdHlwZS5zZXRGaWx0ZXJUeXBlID0gZnVuY3Rpb24gKCBmaWx0ZXJUeXBlICkge1xyXG4gICAgICAgIGlmICggdGhpcy5maWx0ZXIudHlwZSAhPT0gZmlsdGVyVHlwZSApIHtcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXIudHlwZSA9IGZpbHRlclR5cGU7XHJcbiAgICAgICAgICAgIHRoaXMucmVkcmF3KCk7XHJcbiAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwge2ZpZWxkOiAnZmlsdGVyVHlwZScsIHZhbHVlOiBmaWx0ZXJUeXBlfSApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGxheWVycyBmaWx0ZXIgdHlwZS5cclxuICAgICAqIEBtZW1iZXJvZiBBbm5vdGF0aW9uTGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB0aWxlIGZpbHRlciB0eXBlLlxyXG4gICAgICovXHJcbiAgICBBbm5vdGF0aW9uTGF5ZXIucHJvdG90eXBlLmdldEZpbHRlclR5cGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyLnR5cGU7XHJcbiAgICB9O1xyXG5cclxuXHJcblx0LyoqXHJcbiAgICAgKiBTZXQgdGhlIGFubm90YXRpb24gZmlsdGVyIGRhdGEgYXR0cmlidXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgQW5ub3RhdGlvbkxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbHRlckRhdGEgLSBUaGUgZmlsdGVyIGRhdGEgYXR0cmlidXRlLlxyXG4gICAgICovXHJcbiAgICBBbm5vdGF0aW9uTGF5ZXIucHJvdG90eXBlLnNldEZpbHRlckRhdGEgPSBmdW5jdGlvbiAoIGZpbHRlckRhdGEgKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLmZpbHRlci5kYXRhICE9PSBmaWx0ZXJEYXRhICkge1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlci5kYXRhID0gZmlsdGVyRGF0YTtcclxuICAgICAgICAgICAgdGhpcy5yZWRyYXcoKTtcclxuICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7ZmllbGQ6ICdmaWx0ZXJEYXRhJywgdmFsdWU6IGZpbHRlckRhdGF9ICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblx0LyoqXHJcbiAgICAgKiBHZXQgdGhlIGZpbHRlciBkYXRhIGF0dHJpYnV0ZS5cclxuICAgICAqIEBtZW1iZXJvZiBBbm5vdGF0aW9uTGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdGlsZSBmaWx0ZXIgZGF0YSBhdHRyaWJ1dGUuXHJcbiAgICAgKi9cclxuICAgIEFubm90YXRpb25MYXllci5wcm90b3R5cGUuZ2V0RmlsdGVyRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIuZGF0YSB8fCB7fTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSBxdWVyeSBwYXJhbWV0ZXJzIGJhc2VkIG9uIHN0YXRlIG9mIGxheWVyXHJcbiAgICAgKiBAbWVtYmVyb2YgQW5ub3RhdGlvbkxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHF1ZXJ5IHBhcmFtZXRlciBzdHJpbmcgYmFzZWQgb24gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBsYXllci5cclxuICAgICAqL1xyXG4gICAgIEFubm90YXRpb25MYXllci5wcm90b3R5cGUuZ2V0UXVlcnlQYXJhbVN0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBxdWVyeSA9IHtcclxuICAgICAgICAgICAgZmlsdGVyOiB0aGlzLmZpbHRlclxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFV0aWwuZW5jb2RlUXVlcnlQYXJhbXMoIHF1ZXJ5ICk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVkcmF3cyB0aGUgZW50aXJlIGxheWVyLlxyXG4gICAgICogQG1lbWJlcm9mIFNlcnZlckxheWVyXHJcbiAgICAgKi9cclxuICAgIEFubm90YXRpb25MYXllci5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICggdGhpcy5vbExheWVyICkge1xyXG4gICAgICAgICAgICB0aGlzLm9sTGF5ZXIucmVkcmF3KCk7XHJcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHRoZSBUaWxlTWFuYWdlciB3ZSBuZWVkIHRvIGZvcmNlIGl0IGludG8gYSByZWZyZXNoLiBUaGVyZSBpcyBubyBuaWNlIHdheSB0b1xyXG4gICAgICAgICAgICAvLyBkbyB0aGlzIGFzIG9mIDIuMTMuMSwgc28gd2UgZmFrZSB0aGUgZXhwaXJ5IG9mIHRoZSBtb3ZlL3pvb20gdGltZW91dC5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLm9sTGF5ZXIubWFwICYmIHRoaXMub2xMYXllci5tYXAudGlsZU1hbmFnZXIgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9sTGF5ZXIubWFwLnRpbGVNYW5hZ2VyLnVwZGF0ZVRpbWVvdXQoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbExheWVyLm1hcCxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9sTGF5ZXIubWFwLnRpbGVNYW5hZ2VyLnpvb21EZWxheSxcclxuICAgICAgICAgICAgICAgICAgICB0cnVlICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQW5ub3RhdGlvbkxheWVyO1xyXG59KCkpO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIExheWVyID0gcmVxdWlyZSgnLi9MYXllcicpLFxyXG4gICAgICAgIExheWVyVXRpbCA9IHJlcXVpcmUoJy4vTGF5ZXJVdGlsJyksXHJcbiAgICAgICAgVW5pdmFyaWF0ZVRpbGVMYXllciA9IHJlcXVpcmUoJy4vVW5pdmFyaWF0ZVRpbGVMYXllcicpLFxyXG4gICAgICAgIFB1YlN1YiA9IHJlcXVpcmUoJy4uL3V0aWwvUHViU3ViJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW50aWF0ZSBhIEF4aXNMYXllciBvYmplY3QuXHJcbiAgICAgKiBAY2xhc3MgQXhpc0xheWVyXHJcbiAgICAgKiBAYXVnbWVudHMgTGF5ZXJcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBheGlzIHJlbmRlcmVkIGxheWVyIG9iamVjdC4gVXNlcyBkYXRhIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBhbmRcclxuICAgICAqICAgICAgICAgICAgcmVuZGVycyBpdCBvdmVyIHRoZSBheGlzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIC0gVGhlIHNwZWNpZmljYXRpb24gb2JqZWN0LlxyXG4gICAgICogPHByZT5cclxuICAgICAqIHtcclxuICAgICAqICAgICBvcGFjaXR5ICB7ZmxvYXR9ICAgIC0gVGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLiBEZWZhdWx0ID0gMS4wXHJcbiAgICAgKiAgICAgZW5hYmxlZCAge2Jvb2xlYW59ICAtIFdoZXRoZXIgdGhlIGxheWVyIGlzIHZpc2libGUgb3Igbm90LiBEZWZhdWx0ID0gdHJ1ZVxyXG4gICAgICogICAgIHpJbmRleCAgIHtpbnRlZ2VyfSAgLSBUaGUgeiBpbmRleCBvZiB0aGUgbGF5ZXIuIERlZmF1bHQgPSAxMDAwXHJcbiAgICAgKiAgICAgcmVuZGVyZXIge1JlbmRlcmVyfSAtIFRoZSB0aWxlIHJlbmRlcmVyIG9iamVjdC5cclxuICAgICAqIH1cclxuICAgICAqIDwvcHJlPlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBBeGlzTGF5ZXIoIHNwZWMgKSB7XHJcbiAgICAgICAgLy8gY2FsbCBiYXNlIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgTGF5ZXIuY2FsbCggdGhpcywgc3BlYyApO1xyXG4gICAgICAgIC8vIHNldCByZWFzb25hYmxlIGRlZmF1bHRzXHJcbiAgICAgICAgdGhpcy56SW5kZXggPSAoIHNwZWMuekluZGV4ICE9PSB1bmRlZmluZWQgKSA/IHBhcnNlSW50KCBzcGVjLnpJbmRleCwgMTAgKSA6IDE1MDA7XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSBcImF4aXNcIjtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNwZWMuc291cmNlO1xyXG4gICAgICAgIHRoaXMuZ2V0VVJMID0gc3BlYy5nZXRVUkwgfHwgTGF5ZXJVdGlsLmdldFVSTDtcclxuICAgICAgICB0aGlzLmRpbWVuc2lvbiA9IHNwZWMuZGltZW5zaW9uIHx8ICd4JztcclxuICAgICAgICBpZiAoIHNwZWMudGlsZUNsYXNzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlsZUNsYXNzID0gc3BlYy50aWxlQ2xhc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggc3BlYy5yZW5kZXJlciApIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRSZW5kZXJlciggc3BlYy5yZW5kZXJlciApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBBeGlzTGF5ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGF5ZXIucHJvdG90eXBlICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIGxheWVyIG9iamVjdC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG4gICAgICogQG1lbWJlcm9mIEF4aXNMYXllclxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQXhpc0xheWVyLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGFkZCB0aGUgbmV3IGxheWVyXHJcbiAgICAgICAgdGhpcy5vbExheWVyID0gbmV3IFVuaXZhcmlhdGVUaWxlTGF5ZXIoXHJcbiAgICAgICAgICAgICdBeGlzIFJlbmRlcmVkIFRpbGUgTGF5ZXInLFxyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZS50bXMsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxheWVybmFtZTogdGhpcy5zb3VyY2UuaWQsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgICAgICBtYXhFeHRlbnQ6IG5ldyBPcGVuTGF5ZXJzLkJvdW5kcygtMjAwMzc1MDAsIC0yMDAzNzUwMCxcclxuICAgICAgICAgICAgICAgICAgICAyMDAzNzUwMCwgIDIwMDM3NTAwKSxcclxuICAgICAgICAgICAgICAgIGlzQmFzZUxheWVyOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGdldFVSTDogdGhpcy5nZXRVUkwsXHJcbiAgICAgICAgICAgICAgICB0aWxlQ2xhc3M6IHRoaXMudGlsZUNsYXNzLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHRoaXMucmVuZGVyZXIsXHJcbiAgICAgICAgICAgICAgICBkaW1lbnNpb246IHRoaXMuZGltZW5zaW9uXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHNldCB3aGV0aGVyIGl0IGlzIGVuYWJsZWQgb3Igbm90IGJlZm9yZSBhdHRhY2hpbmcsIHRvIHByZXZlbnRcclxuICAgICAgICAvLyBuZWVkbGVzcyB0aWxlIHJlcXVlc3RzXHJcbiAgICAgICAgdGhpcy5zZXRFbmFibGVkKCB0aGlzLmlzRW5hYmxlZCgpICk7XHJcbiAgICAgICAgdGhpcy5zZXRUaGVtZSggdGhpcy5tYXAuZ2V0VGhlbWUoKSApO1xyXG4gICAgICAgIHRoaXMuc2V0T3BhY2l0eSggdGhpcy5nZXRPcGFjaXR5KCkgKTtcclxuICAgICAgICB0aGlzLnNldEJyaWdodG5lc3MoIHRoaXMuZ2V0QnJpZ2h0bmVzcygpICk7XHJcbiAgICAgICAgdGhpcy5zZXRDb250cmFzdCggdGhpcy5nZXRDb250cmFzdCgpICk7XHJcbiAgICAgICAgLy8gcHVibGlzaCBhY3RpdmF0ZSBldmVudCBiZWZvcmUgYXBwZW5kaW5nIHRvIG1hcFxyXG4gICAgICAgIFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ2FjdGl2YXRlJywgdmFsdWU6IHRydWUgfSApO1xyXG4gICAgICAgIC8vIGF0dGFjaCB0byBtYXBcclxuICAgICAgICB0aGlzLm1hcC5vbE1hcC5hZGRMYXllciggdGhpcy5vbExheWVyICk7XHJcbiAgICAgICAgLy8gc2V0IHotaW5kZXggYWZ0ZXJcclxuICAgICAgICB0aGlzLnNldFpJbmRleCggdGhpcy56SW5kZXggKTtcclxuICAgICAgICAvLyBwdWJsaXNoIGFkZCBldmVudFxyXG4gICAgICAgIFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ2FkZCcsIHZhbHVlOiB0cnVlIH0gKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWN0aXZhdGVzIHRoZSBsYXllciBvYmplY3QuIFRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCBtYW51YWxseS5cclxuICAgICAqIEBtZW1iZXJvZiBBeGlzTGF5ZXJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIEF4aXNMYXllci5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICggdGhpcy5vbExheWVyICkge1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5vbE1hcC5yZW1vdmVMYXllciggdGhpcy5vbExheWVyICk7XHJcbiAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ3JlbW92ZScsIHZhbHVlOiB0cnVlIH0gKTtcclxuICAgICAgICAgICAgdGhpcy5vbExheWVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5vbExheWVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnZGVhY3RpdmF0ZScsIHZhbHVlOiB0cnVlIH0gKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHJlbmRlcmVyIG9mIHRoZSBsYXllci5cclxuICAgICAqIEBtZW1iZXJvZiBBeGlzTGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0byBhdHRhY2ggdG8gdGhlIGxheWVyLlxyXG4gICAgICovXHJcbiAgICAgQXhpc0xheWVyLnByb3RvdHlwZS5zZXRSZW5kZXJlciA9IGZ1bmN0aW9uKCByZW5kZXJlciApIHtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hdHRhY2goIHRoaXMgKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB0aGVtZSBhc3NvY2lhdGVkIHdpdGggdGhlIGxheWVyLlxyXG4gICAgICogQG1lbWJlcm9mIEF4aXNMYXllclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0aGVtZSAtIFRoZSB0aGVtZSBpZGVudGlmaWVyIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgQXhpc0xheWVyLnByb3RvdHlwZS5zZXRUaGVtZSA9IGZ1bmN0aW9uKCB0aGVtZSApIHtcclxuICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHRoZW1lIGZvciB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgQXhpc0xheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHRoZW1lIGlkZW50aWZpZXIgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBBeGlzTGF5ZXIucHJvdG90eXBlLmdldFRoZW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB6IGluZGV4IG9mIHRoZSBsYXllci5cclxuICAgICAqIEBtZW1iZXJvZiBBeGlzTGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHpJbmRleCAtIFRoZSBuZXcgei1vcmRlciB2YWx1ZSBvZiB0aGUgbGF5ZXIsIHdoZXJlIDAgaXMgZnJvbnQuXHJcbiAgICAgKi9cclxuICAgIEF4aXNMYXllci5wcm90b3R5cGUuc2V0WkluZGV4ID0gZnVuY3Rpb24gKCB6SW5kZXggKSB7XHJcbiAgICAgICAgLy8gd2UgYnktcGFzcyB0aGUgT3BlbkxheWVycy5NYXAuc2V0TGF5ZXJJbmRleCgpIG1ldGhvZCBhbmQgbWFudWFsbHlcclxuICAgICAgICAvLyBzZXQgdGhlIHotaW5kZXggb2YgdGhlIGxheWVyIGRldi4gc2V0TGF5ZXJJbmRleCBzZXRzIGEgcmVsYXRpdmVcclxuICAgICAgICAvLyBpbmRleCBiYXNlZCBvbiBjdXJyZW50IG1hcCBsYXllcnMsIHdoaWNoIHRoZW4gc2V0cyBhIHotaW5kZXguIFRoaXNcclxuICAgICAgICAvLyBjYXVzZWQgaXNzdWVzIHdpdGggYXN5bmMgbGF5ZXIgbG9hZGluZy5cclxuICAgICAgICB0aGlzLnpJbmRleCA9IHpJbmRleDtcclxuICAgICAgICBpZiAoIHRoaXMub2xMYXllciApIHtcclxuICAgICAgICAgICAgJCggdGhpcy5vbExheWVyLmRpdiApLmNzcyggJ3otaW5kZXgnLCB6SW5kZXggKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnekluZGV4JywgdmFsdWU6IHpJbmRleCB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGxheWVycyB6SW5kZXguXHJcbiAgICAgKiBAbWVtYmVyb2YgQXhpc0xheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9IFRoZSB6SW5kZXggZm9yIHRoZSBsYXllci5cclxuICAgICAqL1xyXG4gICAgQXhpc0xheWVyLnByb3RvdHlwZS5nZXRaSW5kZXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuekluZGV4O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZHJhd3MgdGhlIGVudGlyZSBsYXllci5cclxuICAgICAqIEBtZW1iZXJvZiBBeGlzTGF5ZXJcclxuICAgICAqL1xyXG4gICAgQXhpc0xheWVyLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLm9sTGF5ZXIgKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2xMYXllci5yZWRyYXcoKTtcclxuICAgICAgICAgICAgLy8gSWYgd2UncmUgdXNpbmcgdGhlIFRpbGVNYW5hZ2VyIHdlIG5lZWQgdG8gZm9yY2UgaXQgaW50byBhIHJlZnJlc2guIFRoZXJlIGlzIG5vIG5pY2Ugd2F5IHRvXHJcbiAgICAgICAgICAgIC8vIGRvIHRoaXMgYXMgb2YgMi4xMy4xLCBzbyB3ZSBmYWtlIHRoZSBleHBpcnkgb2YgdGhlIG1vdmUvem9vbSB0aW1lb3V0LlxyXG4gICAgICAgICAgICBpZiAoIHRoaXMub2xMYXllci5tYXAgJiYgdGhpcy5vbExheWVyLm1hcC50aWxlTWFuYWdlciApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2xMYXllci5tYXAudGlsZU1hbmFnZXIudXBkYXRlVGltZW91dChcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9sTGF5ZXIubWFwLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2xMYXllci5tYXAudGlsZU1hbmFnZXIuem9vbURlbGF5LFxyXG4gICAgICAgICAgICAgICAgICAgIHRydWUgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBeGlzTGF5ZXI7XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cdHZhciBMYXllciA9IHJlcXVpcmUoJy4vTGF5ZXInKSxcclxuXHRcdFB1YlN1YiA9IHJlcXVpcmUoJy4uL3V0aWwvUHViU3ViJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW50aWF0ZSBhIEJhc2VMYXllciBvYmplY3QuXHJcbiAgICAgKiBAY2xhc3MgQmFzZUxheWVyXHJcbiAgICAgKiBAYXVnbWVudHMgTGF5ZXJcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBiYXNlIGxheWVyIG9iamVjdCB0aGF0IHNlcnZlcyBhcyB0aGUgdW5kZXJseWluZyBsYXllciBvZiB0aGVcclxuICAgICAqICAgICAgICAgICAgbWFwLiBTdXBwb3J0cyBibGFuayBiYXNlbGF5ZXJzIHRoYXQgYXJlIHNpbXBseSBhIGNvbG9yLCBnZW9ncmFwaGljXHJcbiAgICAgKiAgICAgICAgICAgIGJhc2VsYXllcnMgdXNpbmcgdGhlIEdvb2dsZSBNYXBzIEFQSSwgb3Igc3RhbmRhcmQgVE1TIGxheWVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3BlYyB7T2JqZWN0fSBUaGUgc3BlY2lmaWNhdGlvbiBvYmplY3QuXHJcbiAgICAgKiA8cHJlPlxyXG4gICAgICoge1xyXG4gICAgICogICAgIHR5cGUgICAge1N0cmluZ30gIC0gVGhlIHR5cGUgb2YgYmFzZWxheWVyLCBbXCJCbGFua1wiLCBcIkdvb2dsZVwiLCBcIlRNU1wiXS4gRGVmYXVsdCA9IFwiQmxhbmtcIlxyXG4gICAgICogICAgIG9wYWNpdHkge2Zsb2F0fSAgIC0gVGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLiBEZWZhdWx0ID0gMS4wXHJcbiAgICAgKiAgICAgZW5hYmxlZCB7Ym9vbGVhbn0gLSBXaGV0aGVyIHRoZSBsYXllciBpcyB2aXNpYmxlIG9yIG5vdC4gRGVmYXVsdCA9IHRydWVcclxuICAgICAqICAgICB1cmwgICAgIHtTdHJpbmd9ICAtIGlmIFRNUyBsYXllciwgdGhlIHVybCBmb3IgdGlsZSByZXF1ZXN0cy4gRGVmYXVsdCA9IHVuZGVmaW5lZFxyXG4gICAgICogICAgIG9wdGlvbnMge09iamVjdH0gIC0gdHlwZSBzcGVjaWZpYyBpbnN0YW50aWF0aW9uIGF0dHJpYnV0ZXMuIERlZmF1bHQgPSB7Y29sb3I6cmdiKDAsMCwwKX1cclxuICAgICAqIH1cclxuICAgICAqPC9wcmU+XHJcbiAgICAgKi9cclxuXHRmdW5jdGlvbiBCYXNlTGF5ZXIoIHNwZWMgKSB7XHJcbiAgICAgICAgc3BlYyA9IHNwZWMgfHwge307XHJcbiAgICAgICAgLy8gY2FsbCBiYXNlIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgTGF5ZXIuY2FsbCggdGhpcywgc3BlYyApO1xyXG4gICAgICAgIC8vIHNldCBkZWZhdWx0c1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHNwZWMudHlwZSB8fCBcImJsYW5rXCI7XHJcblx0XHR0aGlzLnVybCA9IHNwZWMudXJsO1xyXG5cdFx0dGhpcy5hdHRyaWJ1dGlvbiA9IHNwZWMuYXR0cmlidXRpb247XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gc3BlYy5vcHRpb25zIHx8IHtcclxuICAgICAgICAgICAgY29sb3IgOiBcInJnYigwLDAsMClcIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSBcImJhc2VcIjtcclxuICAgIH1cclxuXHJcbiAgICBCYXNlTGF5ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGF5ZXIucHJvdG90eXBlICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIGxheWVyIG9iamVjdC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG4gICAgICogQG1lbWJlcm9mIEJhc2VMYXllclxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQmFzZUxheWVyLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBzdHlsZWRNYXBUeXBlO1xyXG5cdFx0Ly8gY3JlYXRlIGJhc2UgbGF5ZXIgYmFzZWQgb24gaW5wdXQgdHlwZVxyXG4gICAgICAgIHN3aXRjaCAoIHRoaXMudHlwZS50b0xvd2VyQ2FzZSgpICkge1xyXG4gICAgICAgICAgICBjYXNlIFwiYmxhbmtcIjpcclxuXHRcdFx0XHQvLyBibGFuayBsYXllclxyXG4gICAgICAgICAgICAgICAgdGhpcy5vbExheWVyID0gbmV3IE9wZW5MYXllcnMuTGF5ZXIuVmVjdG9yKCBcIkJhc2VMYXllclwiLCB7fSApO1xyXG5cdFx0XHRcdHZhciBtYXBFbGVtID0gJCggdGhpcy5tYXAuZ2V0RWxlbWVudCgpICk7XHJcblx0XHRcdFx0bWFwRWxlbS5jc3MoICdiYWNrZ3JvdW5kLWNvbG9yJywgJycgKTtcclxuXHRcdFx0XHRtYXBFbGVtLmF0dHIoICdzdHlsZScsIG1hcEVsZW0uYXR0cignc3R5bGUnKSArIFwiOyBiYWNrZ3JvdW5kLWNvbG9yOiBcIiArIHRoaXMub3B0aW9ucy5jb2xvciArXCIgIWltcG9ydGFudFwiICk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImdvb2dsZVwiOlxyXG5cdFx0XHRcdC8vIGdvb2dsZSBtYXBzIGxheWVyXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMub3B0aW9ucy5zdHlsZXMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnR5cGUgPSBcInN0eWxlZFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5vbExheWVyID0gbmV3IE9wZW5MYXllcnMuTGF5ZXIuR29vZ2xlKCBcIkJhc2VMYXllclwiLCB0aGlzLm9wdGlvbnMgKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwidG1zXCI6XHJcblx0XHRcdFx0Ly8gdG1zIGxheWVyXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9sTGF5ZXIgPSBuZXcgT3BlbkxheWVycy5MYXllci5UTVMoIFwiQmFzZUxheWVyXCIsIHRoaXMudXJsLCB0aGlzLm9wdGlvbnMgKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwieHl6XCI6XHJcblx0XHRcdFx0Ly8geHl6IGxheWVyXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9sTGF5ZXIgPSBuZXcgT3BlbkxheWVycy5MYXllci5YWVooIFwiQmFzZUxheWVyXCIsIHRoaXMudXJsLCB0aGlzLm9wdGlvbnMgKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHRcdGlmICggdGhpcy5hdHRyaWJ1dGlvbiApIHtcclxuXHRcdFx0JCggdGhpcy5tYXAuZ2V0RWxlbWVudCgpICkuYXBwZW5kKFxyXG5cdFx0XHRcdCc8ZGl2IGNsYXNzPWJhc2VsYXllci1hdHRyaWJ1dGlvbj4nICtcclxuXHRcdFx0XHR0aGlzLmF0dHJpYnV0aW9uICtcclxuXHRcdFx0XHQnPC9kaXY+JyApO1xyXG5cdFx0fVxyXG4gICAgICAgIC8vIHB1Ymxpc2ggYWN0aXZhdGUgZXZlbnQgYmVmb3JlIGFwcGVuZGluZyB0byBtYXBcclxuICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICdhY3RpdmF0ZScsIHZhbHVlOiB0cnVlIH0gKTtcclxuXHRcdC8vIGNyZWF0ZSBiYXNlbGF5ZXIgYW5kIHNldCBhcyBiYXNlbGF5ZXJcclxuICAgICAgICB0aGlzLm1hcC5vbE1hcC5hZGRMYXllciggdGhpcy5vbExheWVyICk7XHJcbiAgICAgICAgdGhpcy5tYXAub2xNYXAuc2V0QmFzZUxheWVyKCB0aGlzLm9sTGF5ZXIgKTtcclxuXHRcdC8vIGlmIGdvb2dsZSBtYXBzIGxheWVyLCBzZXQgc3R5bGVzIGFjY29yZGluZyB0byBzcGVjXHJcbiAgICAgICAgaWYgKCB0aGlzLm9wdGlvbnMuc3R5bGVzICkge1xyXG4gICAgICAgICAgICBzdHlsZWRNYXBUeXBlID0gbmV3IGdvb2dsZS5tYXBzLlN0eWxlZE1hcFR5cGUoIHRoaXMub3B0aW9ucy5zdHlsZXMsIHtuYW1lOiAnU3R5bGVkIE1hcCd9ICk7XHJcbiAgICAgICAgICAgIHRoaXMub2xMYXllci5tYXBPYmplY3QubWFwVHlwZXMuc2V0KCAnc3R5bGVkJywgc3R5bGVkTWFwVHlwZSApO1xyXG4gICAgICAgIH1cclxuXHRcdGlmICggdGhpcy5vbExheWVyLm1hcE9iamVjdCApIHtcclxuXHRcdFx0dmFyIGdtYXBDb250YWluZXIgPSB0aGlzLm9sTGF5ZXIubWFwT2JqZWN0LmdldERpdigpO1xyXG5cdFx0XHQkKCBnbWFwQ29udGFpbmVyICkuY3NzKCBcImJhY2tncm91bmQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIgKTtcclxuXHRcdH1cclxuICAgICAgICAvLyBlbnN1cmUgYmFzZWxheWVyIHJlbWFpbnMgYm90dG9tIGxheWVyXHJcblx0XHQkKCB0aGlzLm9sTGF5ZXIuZGl2ICkuY3NzKCAnei1pbmRleCcsIC0xICk7XHJcbiAgICAgICAgLy8gcmVzZXQgdmlzaWJpbGl0eSAvIG9wYWNpdHlcclxuICAgICAgICB0aGlzLnNldE9wYWNpdHkoIHRoaXMuZ2V0T3BhY2l0eSgpICk7XHJcbiAgICAgICAgdGhpcy5zZXRFbmFibGVkKCB0aGlzLmlzRW5hYmxlZCgpICk7XHJcbiAgICAgICAgdGhpcy5zZXRCcmlnaHRuZXNzKCB0aGlzLmdldEJyaWdodG5lc3MoKSApO1xyXG4gICAgICAgIHRoaXMuc2V0Q29udHJhc3QoIHRoaXMuZ2V0Q29udHJhc3QoKSApO1xyXG4gICAgICAgIC8vIHB1Ymxpc2ggYWRkIGV2ZW50XHJcbiAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnYWRkJywgdmFsdWU6IHRydWUgfSApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY3RpdmF0ZXMgdGhlIGxheWVyIG9iamVjdC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG4gICAgICogQG1lbWJlcm9mIEJhc2VMYXllclxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQmFzZUxheWVyLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLm9sTGF5ZXIgKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLm9sTWFwLnJlbW92ZUxheWVyKCB0aGlzLm9sTGF5ZXIgKTtcclxuICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAncmVtb3ZlJywgdmFsdWU6IHRydWUgfSApO1xyXG4gICAgICAgICAgICB0aGlzLm9sTGF5ZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuXHRcdGlmICggdGhpcy5hdHRyaWJ1dGlvbiApIHtcclxuXHRcdFx0JCggdGhpcy5tYXAuZ2V0RWxlbWVudCgpICkuZmluZCgnLmJhc2VsYXllci1hdHRyaWJ1dGlvbicpLnJlbW92ZSgpO1xyXG5cdFx0fVxyXG4gICAgICAgIHRoaXMubWFwLmdldEVsZW1lbnQoKS5zdHlsZVsnYmFja2dyb3VuZC1jb2xvciddID0gJyc7XHJcbiAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnZGVhY3RpdmF0ZScsIHZhbHVlOiB0cnVlIH0gKTtcclxuICAgIH07XHJcblxyXG5cdC8qKlxyXG4gICAgICogU2V0IHRoZSB6IGluZGV4IG9mIHRoZSBsYXllci5cclxuICAgICAqIEBtZW1iZXJvZiBCYXNlTGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHpJbmRleCAtIFRoZSBuZXcgei1vcmRlciB2YWx1ZSBvZiB0aGUgbGF5ZXIsIHdoZXJlIDAgaXMgZnJvbnQuXHJcbiAgICAgKi9cclxuXHRCYXNlTGF5ZXIucHJvdG90eXBlLnJlc2V0WkluZGV4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHdlIGJ5LXBhc3MgdGhlIE9wZW5MYXllcnMuTWFwLnNldExheWVySW5kZXgoKSBtZXRob2QgYW5kIG1hbnVhbGx5XHJcbiAgICAgICAgLy8gc2V0IHRoZSB6LWluZGV4IG9mIHRoZSBsYXllciBkZXYuIHNldExheWVySW5kZXggc2V0cyBhIHJlbGF0aXZlXHJcbiAgICAgICAgLy8gaW5kZXggYmFzZWQgb24gY3VycmVudCBtYXAgbGF5ZXJzLCB3aGljaCB0aGVuIHNldHMgYSB6LWluZGV4LiBUaGlzXHJcbiAgICAgICAgLy8gY2F1c2VkIGlzc3VlcyB3aXRoIGFzeW5jIGxheWVyIGxvYWRpbmcuXHJcbiAgICAgICAgaWYgKCB0aGlzLm9sTGF5ZXIgKSB7XHJcbiAgICAgICAgICAgICQoIHRoaXMub2xMYXllci5kaXYgKS5jc3MoICd6LWluZGV4JywgLTEgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnekluZGV4JywgdmFsdWU6IC0xIH0pO1xyXG4gICAgfTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBCYXNlTGF5ZXI7XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgTGF5ZXIgPSByZXF1aXJlKCcuL0xheWVyJyksXHJcbiAgICAgICAgQ2xpZW50TGF5ZXIgPSByZXF1aXJlKCcuL0NsaWVudExheWVyJyksXHJcbiAgICAgICAgTGF5ZXJVdGlsID0gcmVxdWlyZSgnLi9MYXllclV0aWwnKSxcclxuICAgICAgICBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyksXHJcbiAgICAgICAgSHRtbFRpbGVMYXllciA9IHJlcXVpcmUoJy4vSHRtbFRpbGVMYXllcicpLFxyXG4gICAgICAgIFB1YlN1YiA9IHJlcXVpcmUoJy4uL3V0aWwvUHViU3ViJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2gsIGJhc2VkIG9uIHRoZSBjYXJvdXNlbCBpbmRleCBmb3IgdGhlIHBhcnRpY3VsYXJcclxuICAgICAqIHRpbGUsIHdpbGwgdXNlIHRoZSBzcGVjaWZpY2F0aW9uIHZhbHVlcyBmcm9tIHRoZSBhc3NvY2lhdGVkIGxheWVyIHRvXHJcbiAgICAgKiBwdWxsIHRpbGUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtDYXJvdXNlbH0gY2Fyb3VzZWwgLSBUaGUgY2Fyb3VzZWwgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIGdldFVSTCBmdW5jdGlvbiBmb3IgdGhlIGNhcm91c2VsLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRVUkxGdW5jdGlvbiggY2Fyb3VzZWwgKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBib3VuZHMgKSB7XHJcbiAgICAgICAgICAgIHZhciB0aWxlSW5kZXggPSBMYXllclV0aWwuZ2V0VGlsZUluZGV4KCB0aGlzLCBib3VuZHMgKSxcclxuICAgICAgICAgICAgICAgIHggPSB0aWxlSW5kZXgueEluZGV4LFxyXG4gICAgICAgICAgICAgICAgeSA9IHRpbGVJbmRleC55SW5kZXgsXHJcbiAgICAgICAgICAgICAgICB6ID0gdGlsZUluZGV4LmxldmVsLFxyXG4gICAgICAgICAgICAgICAgdGlsZWtleSA9IHogKyBcIixcIiArIHggKyBcIixcIiArIHksXHJcbiAgICAgICAgICAgICAgICBsYXllckluZGV4ID0gY2Fyb3VzZWwuZ2V0TGF5ZXJJbmRleEZvclRpbGUoIHRpbGVrZXkgKSxcclxuICAgICAgICAgICAgICAgIGxheWVyU3BlYyA9IGNhcm91c2VsLmxheWVyU3BlY3NbIGxheWVySW5kZXggXSxcclxuICAgICAgICAgICAgICAgIHR5cGUgPSBsYXllclNwZWMudHlwZSxcclxuICAgICAgICAgICAgICAgIHVybCA9IGxheWVyU3BlYy51cmwsXHJcbiAgICAgICAgICAgICAgICBsYXllcm5hbWUgPSBsYXllclNwZWMubGF5ZXJuYW1lO1xyXG4gICAgICAgICAgICBpZiAoIHggPj0gMCAmJiB5ID49IDAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsICsgbGF5ZXJuYW1lICsgXCIvXCIgKyB6ICsgXCIvXCIgKyB4ICsgXCIvXCIgKyB5ICsgXCIuXCIgKyB0eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCwgYmFzZWQgb24gdGhlIGNhcm91c2VsIGluZGV4IGZvciB0aGUgcGFydGljdWxhclxyXG4gICAgICogdGlsZSwgd2lsbCB1c2UgdGhlIHJlbmRlcmVyIGZyb20gdGhlIGFzc29jaWF0ZWQgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtDYXJvdXNlbH0gY2Fyb3VzZWwgLSBUaGUgY2Fyb3VzZWwgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIHJlbmRlcmVyIGZ1bmN0aW9uIGZvciB0aGUgY2Fyb3VzZWwuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFJlbmRlcmVyRnVuY3Rpb24oIGNhcm91c2VsICkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggYm91bmRzICkge1xyXG4gICAgICAgICAgICB2YXIgdGlsZWtleSA9IExheWVyVXRpbC5nZXRUaWxla2V5KCB0aGlzLCBib3VuZHMgKSxcclxuICAgICAgICAgICAgICAgIGxheWVySW5kZXggPSBjYXJvdXNlbC5nZXRMYXllckluZGV4Rm9yVGlsZSggdGlsZWtleSApLFxyXG4gICAgICAgICAgICAgICAgbGF5ZXJTcGVjID0gY2Fyb3VzZWwubGF5ZXJTcGVjc1sgbGF5ZXJJbmRleCBdO1xyXG4gICAgICAgICAgICByZXR1cm4gbGF5ZXJTcGVjLnJlbmRlcmVyO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVuTGF5ZXJzIHN0b3JlcyB0aWxlcyBpbiBhIGRvdWJsZSBhcnJheS4gVG8gcmVkcmF3IGFuIGluZGl2aWR1YWwgdGlsZSB3ZVxyXG4gICAgICogaXRlcmF0ZSB0aHJvdWdoIHVudGlsIHdlIGZpbmQgdGhlIG1hdGNoaW5nIHRpbGVrZXkgKCB3aGljaCBpcyBhcHBlbmRlZCB0b1xyXG4gICAgICogdGhlIHRpbGUgaW4gdGhlIEh0bWxUaWxlIGNsYXNzICkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPcGVuTGF5ZXJzLkxheWVyfSBvbExheWVyIC0gVGhlIG9wZW5sYXllcnMgbGF5ZXIgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRpbGVrZXkgLSBUaGUgdGlsZSBrZXkgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZWRyYXdUaWxlKCBvbExheWVyLCB0aWxla2V5ICkge1xyXG4gICAgICAgIHZhciBncmlkLFxyXG4gICAgICAgICAgICBpLCBqO1xyXG4gICAgICAgIGZvciAoIGk9MDsgaTxvbExheWVyLmdyaWQubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgIGdyaWQgPSBvbExheWVyLmdyaWRbaV07XHJcbiAgICAgICAgICAgIGZvciAoIGo9MDsgajxncmlkLmxlbmd0aDsgaisrICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBncmlkW2pdLnRpbGVrZXkgPT09IHRpbGVrZXkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JpZFtqXS5kcmF3KCB0cnVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGF0Y2hlcyB0aGUgZ2V0L3NldCBmdW5jdGlvbnMgb2YgdGhlIGF0dGFjaGVkIGxheWVyIGluIG9yZGVyIHRvIGRlbGVnYXRlXHJcbiAgICAgKiBiZWhhdmlvdXIgdG8gYW5kIGZyb20gdGhlIGNhcm91c2VsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Q2Fyb3VzZWx9IGNhcm91c2VsIC0gVGhlIGNhcm91c2VsIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gVGhlIGxheWVyIG9iamVjdCB0byBwYXRjaC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcGF0Y2hMYXllciggY2Fyb3VzZWwsIGxheWVyICkge1xyXG4gICAgICAgIC8vIG92ZXJyaWRlIHRoZSBsYXllcnMgb3BhY2l0eSBmdW5jdGlvbnMsIHNldHRpbmcgdGhlIG9wYWNpdHkgb2YgdGhlIGNhcm91c2VsXHJcbiAgICAgICAgLy8gd2lsbCB1cGRhdGUgdGhlIG9wYWNpdHkgb2YgQUxMIGxheWVycy5cclxuICAgICAgICBsYXllci5zZXRPcGFjaXR5ID0gZnVuY3Rpb24oIG9wYWNpdHkgKSB7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICBjYXJvdXNlbC5zZXRPcGFjaXR5KCBvcGFjaXR5ICk7XHJcbiAgICAgICAgICAgIGZvciAoIGk9MDsgaTxjYXJvdXNlbC5sYXllcnMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICBQdWJTdWIucHVibGlzaCggY2Fyb3VzZWwubGF5ZXJzW2ldLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ29wYWNpdHknLCB2YWx1ZTogb3BhY2l0eSB9ICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGxheWVyLmdldE9wYWNpdHkgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhcm91c2VsLmdldE9wYWNpdHkoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIG92ZXJyaWRlIHRoZSBsYXllcnMgZW5hYmxlIGZ1bmN0aW9ucywgZW5hYmxpbmcgYSBwYXJ0aWN1bGFyIGxheWVyXHJcbiAgICAgICAgLy8gd2lsbCBkaXNhYmxlIGFsbCBvdGhlciBsYXllcnMgYXR0YWNoZWQgdG8gdGhlIGNhcm91c2VsLlxyXG4gICAgICAgIGxheWVyLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoICFjYXJvdXNlbC5pc0VuYWJsZWQoKSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2Fyb3VzZWwubGF5ZXJzLmluZGV4T2YoIGxheWVyICkgPT09IGNhcm91c2VsLmRlZmF1bHRJbmRleDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxheWVyLnNldEVuYWJsZWQgPSBmdW5jdGlvbiggZW5hYmxlZCApIHtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGlmICggZW5hYmxlZCApIHtcclxuICAgICAgICAgICAgICAgIGNhcm91c2VsLnNldEVuYWJsZWQoIHRydWUgKTtcclxuICAgICAgICAgICAgICAgIGNhcm91c2VsLnNldFRpbGVMYXllckluZGljZXMoIGNhcm91c2VsLmxheWVycy5pbmRleE9mKCBsYXllciApICk7XHJcbiAgICAgICAgICAgICAgICBQdWJTdWIucHVibGlzaCggbGF5ZXIuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnZW5hYmxlZCcsIHZhbHVlOiBlbmFibGVkIH0gKTtcclxuICAgICAgICAgICAgICAgIGZvciAoIGk9MDsgaTxjYXJvdXNlbC5sYXllcnMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjYXJvdXNlbC5sYXllcnNbaV0gIT09IGxheWVyICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBQdWJTdWIucHVibGlzaCggY2Fyb3VzZWwubGF5ZXJzW2ldLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ2VuYWJsZWQnLCB2YWx1ZTogZmFsc2UgfSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNhcm91c2VsLnNldEVuYWJsZWQoIGZhbHNlICk7XHJcbiAgICAgICAgICAgICAgICBQdWJTdWIucHVibGlzaCggbGF5ZXIuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnZW5hYmxlZCcsIHZhbHVlOiBmYWxzZSB9ICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIG92ZXJyaWRlIHRoZSBsYXllcnMgeiBpbmRleCBmdW5jdGlvbnNcclxuICAgICAgICBsYXllci5zZXRaSW5kZXggPSBmdW5jdGlvbiggekluZGV4ICkge1xyXG4gICAgICAgICAgICBjYXJvdXNlbC5zZXRaSW5kZXgoIHpJbmRleCApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGF5ZXIuZ2V0WkluZGV4ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYXJvdXNlbC5nZXRaSW5kZXgoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIG92ZXJyaWRlIHRoZSBsYXllcnMgdGhlbWUgZnVuY3Rpb25cclxuICAgICAgICBsYXllci5zZXRUaGVtZSA9IGZ1bmN0aW9uKCB0aGVtZSApIHtcclxuICAgICAgICAgICAgY2Fyb3VzZWwuc2V0VGhlbWUoIHRoZW1lICk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBvdmVycmlkZSByZWRyYXcgZnVuY3Rpb25cclxuICAgICAgICBsYXllci5yZWRyYXcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgY2Fyb3VzZWwub2xMYXllci5yZWRyYXcoKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBsYXllciB0byBpdHMgb3JpZ2luYWwgc3RhdGUgYmUgcmVwYWlyaW5nIHRoZSBwcmV2aW91c2x5XHJcbiAgICAgICAgICogcGF0Y2hlZCBtZXRob2RzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgb2JqZWN0IHRvIHBhdGNoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXllclNwZWMgLSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yaWdpbmFsIG1ldGhvZHMuXHJcbiAgICAgICAgICovXHJcbiAgICBmdW5jdGlvbiB1bnBhdGNoTGF5ZXIoIGxheWVyLCBsYXllclNwZWMgKSB7XHJcbiAgICAgICAgLy8gcmV0dXJuIGFsbCB0aGUgbGF5ZXJzIGZ1bmN0aW9ucyB0byB0aGllciBwcmV2aW91cyBzdGF0ZVxyXG4gICAgICAgIGxheWVyLnNldE9wYWNpdHkgPSBsYXllclNwZWMuc2V0T3BhY2l0eTtcclxuICAgICAgICBsYXllci5nZXRPcGFjaXR5ID0gbGF5ZXJTcGVjLmdldE9wYWNpdHk7XHJcbiAgICAgICAgbGF5ZXIuaXNFbmFibGVkID0gbGF5ZXJTcGVjLmlzRW5hYmxlZDtcclxuICAgICAgICBsYXllci5zZXRFbmFibGVkID0gbGF5ZXJTcGVjLnNldEVuYWJsZWQ7XHJcbiAgICAgICAgbGF5ZXIuc2V0WkluZGV4ID0gbGF5ZXJTcGVjLnNldFpJbmRleDtcclxuICAgICAgICBsYXllci5zZXRUaGVtZSA9IGxheWVyU3BlYy5zZXRUaGVtZTtcclxuICAgICAgICBsYXllci5yZWRyYXcgPSBsYXllclNwZWMucmVkcmF3O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGUgYSBDYXJvdXNlbCBvYmplY3QgdG8gYWxsb3cgdGlsZS1ieS10aWxlIGNvbnRyb2wgZm9yIGFsbCBsYXllcnMgaW5cclxuICAgICAqIHRoZSBjYXJvdXNlbCAnYnVuZGxlJy5cclxuICAgICAqIFRoaXMgb2JqZWN0IG1vZGlmaWVzIHRoZSBmdW5jdGlvbmFsaXR5IGZyb20gaXRzIGJ1bmRsZWQgbGF5ZXIgb2JqZWN0cyBhcyBmb2xsb3dzOlxyXG4gICAgICogPHByZT5cclxuICAgICAqICAgICAxKSBPcGFjaXR5IGlzIHNoYXJlZCBhY3Jvc3MgYWxsIGJ1bmRsZWQgbGF5ZXJzLlxyXG4gICAgICogICAgIDIpIFotSW5kZXggaXMgc2hhcmVkIGFjcm9zcyBhbGwgYnVuZGxlZCBsYXllcnMuXHJcbiAgICAgKiAgICAgMykgVGhlbWUgaXMgc2hhcmVkIGFjcm9zcyBhbGwgYnVuZGxlZCBsYXllcnMuXHJcbiAgICAgKiAgICAgNCkgRW5hYmxpbmcgLyBkaXNhYmxpbmcgYSBsYXllciB3aWxsIHN3aXRjaCBhbGwgdGlsZXMgdG8gdGhhdCBwYXJ0aWN1bGFyIGxheWVyLlxyXG4gICAgICogPC9wcmU+XHJcbiAgICAgKiBAY2xhc3MgQ2Fyb3VzZWxcclxuICAgICAqIEBhdWdtZW50cyBMYXllclxyXG4gICAgICogQGNsYXNzZGVzYyBBIGNhcm91c2VsIG9iamVjdCB0byBhbGxvdyBjaGFuZ2luZyBpbmRpdmlkdWFsIGNsaWVudCByZW5kZXJlcmVkIHRpbGVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDYXJvdXNlbCgpIHtcclxuICAgICAgICAvLyBjYWxsIGJhc2UgY29uc3RydWN0b3JcclxuICAgICAgICBMYXllci5jYWxsKCB0aGlzLCB7fSApO1xyXG4gICAgICAgIC8vIHNldCByZWFzb25hYmxlIGRlZmF1bHRzXHJcbiAgICAgICAgdGhpcy56SW5kZXggPSAxNTAwO1xyXG4gICAgICAgIHRoaXMuZG9tYWluID0gXCJjYXJvdXNlbFwiO1xyXG4gICAgICAgIHRoaXMubGF5ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5sYXllclNwZWNzID0gW107XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzQnlUaWxlID0ge307XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0SW5kZXggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIENhcm91c2VsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENsaWVudExheWVyLnByb3RvdHlwZSApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGNsaWVudCByZW5kZXJlZCBsYXllciB0byB0aGUgY2Fyb3VzZWwgb2JqZWN0LiBUaGlzIGludm9sdmVzXHJcbiAgICAgKiAncGF0Y2hpbmcnIHRoZSBtZXRob2RzIG9mIHRoZSBsYXllciB3aXRoIHRob3NlIGZyb20gdGhlIGNhcm91c2VsIHRvXHJcbiAgICAgKiBnaXZlIHRoZSByZXF1aXJlZCBmdW5jdGlvbmFsaXR5LlxyXG4gICAgICogQG1lbWJlcm9mIENhcm91c2VsXHJcbiAgICAgICAgICpcclxuICAgICAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gVGhlIGNsaWVudCByZW5kZXJlZCBsYXllciBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIENhcm91c2VsLnByb3RvdHlwZS5hZGRMYXllciA9IGZ1bmN0aW9uKCBsYXllciApIHtcclxuXHJcbiAgICAgICAgaWYgKCAhKCBsYXllciBpbnN0YW5jZW9mIENsaWVudExheWVyICkgKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcIk9ubHkgQ2xpZW50TGF5ZXJzIGNhbiBiZSBhZGRlZCB0byBhIGNhcm91c2VsIG9iamVjdC5cIiApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoICF0aGlzLm1hcCApIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gbWFwIGl0IG1lYW5zIHRoYXQgdGhlIGNhcm91c2VsXHJcbiAgICAgICAgICAgIC8vIGhhcyBub3QgYmVlbiBhZGRlZCB5ZXQsIG9yIHRoZSBtYXAgaXMgbm90IHJlYWR5XHJcbiAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBsYXllciBmb3IgbGF0ZXIgYWRkaW5nXHJcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWRzID0gdGhpcy5kZWZlcnJlZHMgfHwgW107XHJcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWRzLnB1c2goIGxheWVyICk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHN0b3JlIHRoZSBsYXllciBzcGVjaWZpY2F0aW9uXHJcbiAgICAgICAgdmFyIGxheWVyU3BlYyA9IHtcclxuICAgICAgICAgICAgICAgIHVybDogbGF5ZXIuc291cmNlLnRtcyxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgICAgIGxheWVybmFtZTogbGF5ZXIuc291cmNlLmlkLFxyXG4gICAgICAgICAgICAgICAgc2V0T3BhY2l0eTogbGF5ZXIuc2V0T3BhY2l0eSxcclxuICAgICAgICAgICAgICAgIGdldE9wYWNpdHk6IGxheWVyLmdldE9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICBpc0VuYWJsZWQ6IGxheWVyLmlzRW5hYmxlZCxcclxuICAgICAgICAgICAgICAgIHNldEVuYWJsZWQ6IGxheWVyLnNldEVuYWJsZWQsXHJcbiAgICAgICAgICAgICAgICBzZXRaSW5kZXg6IGxheWVyLnNldFpJbmRleCxcclxuICAgICAgICAgICAgICAgIHNldFRoZW1lOiBsYXllci5zZXRUaGVtZSxcclxuICAgICAgICAgICAgICAgIHJlZHJhdzogbGF5ZXIucmVkcmF3XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgLy8gc2V0IHRoZSByZW5kZXJlciBwYXJlbnQgdG8gdGhlIGNhcm91c2VsXHJcbiAgICAgICAgaWYgKCBsYXllci5yZW5kZXJlciApIHtcclxuICAgICAgICAgICAgbGF5ZXJTcGVjLnJlbmRlcmVyID0gbGF5ZXIucmVuZGVyZXI7XHJcbiAgICAgICAgICAgIGxheWVyU3BlYy5yZW5kZXJlci5tZXRhID0gbGF5ZXIuc291cmNlLm1ldGEubWV0YTtcclxuICAgICAgICAgICAgbGF5ZXJTcGVjLnJlbmRlcmVyLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxheWVyLmNhcm91c2VsID0gdGhpcztcclxuICAgICAgICAvLyBzdG9yZSB0aGUgbGF5ZXIgYW5kIGl0cyBzcGVjaWZpY2F0aW9uXHJcbiAgICAgICAgdGhpcy5sYXllclNwZWNzLnB1c2goIGxheWVyU3BlYyApO1xyXG4gICAgICAgIHRoaXMubGF5ZXJzLnB1c2goIGxheWVyICk7XHJcbiAgICAgICAgLy8gcGF0Y2ggdGhlIGxheWVyXHJcbiAgICAgICAgcGF0Y2hMYXllciggdGhpcywgbGF5ZXIgKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYSBsYXllciBmcm9tIHRoZSBjYXJvdXNlbC4gVGhpcyB3aWxsICd1bnBhdGNoJyB0aGVcclxuICAgICAqIGxheWVycyBhbmQgcmV0dXJuIHRoZW0gdG8gdGhlaXIgb3JpZ2luYWwgc3RhdGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2Fyb3VzZWxcclxuICAgICAgICAgKlxyXG4gICAgICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBDYXJvdXNlbC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIgPSBmdW5jdGlvbiggbGF5ZXIgKSB7XHJcblxyXG4gICAgICAgIGlmICggIXRoaXMubWFwICYmIHRoaXMuZGVmZXJyZWRzICkge1xyXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBtYXAgaXQgbWVhbnMgdGhhdCB0aGUgY2Fyb3VzZWxcclxuICAgICAgICAgICAgLy8gaGFzIG5vdCBiZWVuIGFkZGVkIHlldCwgc28gc2ltcGx5IHJlbW92ZSBpdCBmcm9tXHJcbiAgICAgICAgICAgIC8vIHRoZSBkZWZlcnJlZHMgYXJyYXkuXHJcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWRzLnNwbGljZSggdGhpcy5kZWZlcnJlZHMuaW5kZXhPZiggbGF5ZXIgKSwgMSApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxheWVycy5pbmRleE9mKCBsYXllciApO1xyXG4gICAgICAgIGlmICggaW5kZXggIT09IC0xICkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMubGF5ZXJzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm1hcCApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCAnQSBjYXJvdXNlbCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGxheWVyIHRvIGJlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhdHRhY2hlZCB0byBhIG1hcCwgcmVtb3ZlIHRoZSBjYXJvdXNlbCBmcm9tIHRoZSBtYXAgZmlyc3QuJyApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggbGF5ZXIucmVuZGVyZXIgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHBhcmVudCBwcm9wZXJ0eSBvZiB0aGUgcmVuZGVyZXJcclxuICAgICAgICAgICAgICAgIGxheWVyLnJlbmRlcmVyLnBhcmVudCA9IGxheWVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlbGV0ZSBsYXllci5jYXJvdXNlbDtcclxuICAgICAgICAgICAgdW5wYXRjaExheWVyKCBsYXllciwgdGhpcy5sYXllclNwZWNzWyBpbmRleCBdICk7XHJcbiAgICAgICAgICAgIHRoaXMubGF5ZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcclxuICAgICAgICAgICAgdGhpcy5sYXllclNwZWNzLnNwbGljZSggaW5kZXgsIDEgKTtcclxuICAgICAgICAgICAgLy8gc2V0IHRoZSBkZWZhdWx0IGluZGV4IGFjY29yZGluZ2x5XHJcbiAgICAgICAgICAgIGlmICggaW5kZXggPCB0aGlzLmRlZmF1bHRJbmRleCB8fCB0aGlzLmRlZmF1bHRJbmRleCA9PT0gdGhpcy5sYXllcnMubGVuZ3RoICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0SW5kZXgtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZXNldCB2aWV3XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VGlsZUxheWVySW5kaWNlcyggdGhpcy5kZWZhdWx0SW5kZXggKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAqIEFjdGl2YXRlcyB0aGUgY2Fyb3VzZWwgb2JqZWN0LiBUaGlzIHNob3VsZCBuZXZlciBiZSBjYWxsZWQgbWFudWFsbHkuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2Fyb3VzZWxcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIENhcm91c2VsLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMubGF5ZXJzLmxlbmd0aCA9PT0gMCAmJlxyXG4gICAgICAgICAgICAoICF0aGlzLmRlZmVycmVkcyB8fCB0aGlzLmRlZmVycmVkcy5sZW5ndGggPT09IDAgKSApIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coICdBIGNhcm91c2VsIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbGF5ZXIgYXR0YWNoZWQgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAnYmVmb3JlIGl0IGNhbiBiZSBhZGRlZCB0byBhIG1hcC4nKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYWRkIHRoZSBuZXcgbGF5ZXJcclxuICAgICAgICB0aGlzLm9sTGF5ZXIgPSBuZXcgSHRtbFRpbGVMYXllcihcclxuICAgICAgICAgICAgJ0NsaWVudCBSZW5kZXJlZCBDYXJvdXNlbCBUaWxlIExheWVyJyxcclxuICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGF5ZXJuYW1lOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICAgICAgbWF4RXh0ZW50OiBuZXcgT3BlbkxheWVycy5Cb3VuZHMoLTIwMDM3NTAwLCAtMjAwMzc1MDAsXHJcbiAgICAgICAgICAgICAgICAgICAgMjAwMzc1MDAsICAyMDAzNzUwMCksXHJcbiAgICAgICAgICAgICAgICBpc0Jhc2VMYXllcjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBnZXRVUkw6IGdldFVSTEZ1bmN0aW9uKCB0aGlzICksXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlcjogZ2V0UmVuZGVyZXJGdW5jdGlvbiggdGhpcyApXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLm1hcC5vbE1hcC5hZGRMYXllciggdGhpcy5vbExheWVyICk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0WkluZGV4KCB0aGlzLnpJbmRleCApO1xyXG4gICAgICAgIHRoaXMuc2V0T3BhY2l0eSggdGhpcy5vcGFjaXR5ICk7XHJcbiAgICAgICAgdGhpcy5zZXRFbmFibGVkKCB0aGlzLmVuYWJsZWQgKTtcclxuICAgICAgICB0aGlzLnNldFRoZW1lKCB0aGlzLm1hcC5nZXRUaGVtZSgpICk7XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZSBsYXllcnMgYXJlIGFscmVhZHkgYXR0YWNoZWQgdG8gdGhlIG1hcCwgcmVtb3ZlIHRoZW0gZmlyc3QuXHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yICggaT0wOyBpPHRoaXMubGF5ZXJzLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5yZW1vdmUoIHRoaXMubGF5ZXJzW2ldICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhZGQgYWxsIGRlZmVycmVkIGxheWVycywgaWYgdGhleSBleGlzdFxyXG4gICAgICAgIGlmICggdGhpcy5kZWZlcnJlZHMgKSB7XHJcbiAgICAgICAgICAgIGZvciAoIGk9MDsgaTx0aGlzLmRlZmVycmVkcy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGF5ZXIoIHRoaXMuZGVmZXJyZWRzW2ldICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGVmZXJyZWRzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmNyZW1lbnQgd2hpY2ggbGF5ZXIgaW5kZXggdGhlIGN1cnJlbnQgdGlsZSBwb2ludHMgdG8uIFRoaXMgd2lsbFxyXG4gICAgICogcmVkcmF3IHRoZSBtb2RpZmllZCB0aWxlLlxyXG4gICAgICogQG1lbWJlcm9mIENhcm91c2VsXHJcbiAgICAgICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0aWxla2V5IC0gVGhlIHRpbGUga2V5IHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLmluY3JlbWVudFRpbGVMYXllckluZGV4ID0gZnVuY3Rpb24oIHRpbGVrZXkgKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLmluZGljZXNCeVRpbGVbIHRpbGVrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICB0aGlzLmluZGljZXNCeVRpbGVbIHRpbGVrZXkgXSA9ICggdGhpcy5kZWZhdWx0SW5kZXggKyAxICkgJSB0aGlzLmxheWVycy5sZW5ndGg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5pbmRpY2VzQnlUaWxlWyB0aWxla2V5IF0gPSAoIHRoaXMuaW5kaWNlc0J5VGlsZVsgdGlsZWtleSBdICsgMSApICUgdGhpcy5sYXllcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuaW5kaWNlc0J5VGlsZVsgdGlsZWtleSBdID09PSB0aGlzLmRlZmF1bHRJbmRleCApIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmluZGljZXNCeVRpbGVbIHRpbGVrZXkgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZWRyYXdUaWxlKCB0aGlzLm9sTGF5ZXIsIHRpbGVrZXkgKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNyZW1lbnQgd2hpY2ggbGF5ZXIgaW5kZXggdGhlIGN1cnJlbnQgdGlsZSBwb2ludHMgdG8uIFRoaXMgd2lsbFxyXG4gICAgICogcmVkcmF3IHRoZSBtb2RpZmllZCB0aWxlLlxyXG4gICAgICogQG1lbWJlcm9mIENhcm91c2VsXHJcbiAgICAgICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0aWxla2V5IC0gVGhlIHRpbGUga2V5IHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLmRlY3JlbWVudFRpbGVMYXllckluZGV4ID0gZnVuY3Rpb24oIHRpbGVrZXkgKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLmluZGljZXNCeVRpbGVbIHRpbGVrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICB0aGlzLmluZGljZXNCeVRpbGVbIHRpbGVrZXkgXSA9IFV0aWwubW9kKCB0aGlzLmRlZmF1bHRJbmRleCAtMSwgdGhpcy5sYXllcnMubGVuZ3RoICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5pbmRpY2VzQnlUaWxlWyB0aWxla2V5IF0gPSBVdGlsLm1vZCggdGhpcy5pbmRpY2VzQnlUaWxlWyB0aWxla2V5IF0gLSAxLCAgdGhpcy5sYXllcnMubGVuZ3RoICk7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5pbmRpY2VzQnlUaWxlWyB0aWxla2V5IF0gPT09IHRoaXMuZGVmYXVsdEluZGV4ICkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5kaWNlc0J5VGlsZVsgdGlsZWtleSBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZHJhd1RpbGUoIHRoaXMub2xMYXllciwgdGlsZWtleSApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB3aGljaCBsYXllciBpbmRleCB0aGUgY3VycmVudCB0aWxlIHBvaW50cyB0by4gVGhpcyB3aWxsXHJcbiAgICAgKiByZWRyYXcgdGhlIG1vZGlmaWVkIHRpbGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2Fyb3VzZWxcclxuICAgICAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRpbGVrZXkgLSBUaGUgdGlsZSBrZXkgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIG5ldyBsYXllciBpbmRleCBmb3IgdGhlIHRpbGUuXHJcbiAgICAgKi9cclxuICAgIENhcm91c2VsLnByb3RvdHlwZS5zZXRUaWxlTGF5ZXJJbmRleCA9IGZ1bmN0aW9uKCB0aWxla2V5LCBpbmRleCApIHtcclxuICAgICAgICBpZiAoIGluZGV4ID09PSB0aGlzLmRlZmF1bHRJbmRleCApIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5kaWNlc0J5VGlsZVsgdGlsZWtleSBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kaWNlc0J5VGlsZVsgdGlsZWtleSBdID0gaW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZHJhd1RpbGUoIHRoaXMub2xMYXllciwgdGlsZWtleSApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbGF5ZXIgaW5kZXggZm9yIGFsbCB0aWxlcy4gVGhpcyB3aWxsIHJlZHJhdyB0aGUgZW50aXJlXHJcbiAgICAgKiBsYXllci5cclxuICAgICAqIEBtZW1iZXJvZiBDYXJvdXNlbFxyXG4gICAgICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5kZXggLSBUaGUgbGF5ZXIgaW5kZXggZm9yIGFsbCB0aWxlcy5cclxuICAgICAqL1xyXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnNldFRpbGVMYXllckluZGljZXMgPSBmdW5jdGlvbiggaW5kZXggKSB7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0SW5kZXggPSBVdGlsLm1vZCggaW5kZXgsIHRoaXMubGF5ZXJzLmxlbmd0aCApO1xyXG4gICAgICAgIHRoaXMuaW5kaWNlc0J5VGlsZSA9IHt9O1xyXG4gICAgICAgIHRoaXMub2xMYXllci5yZWRyYXcoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXllciBpbmRleCBmb3IgYSBwYXJ0aWN1bGFyIHRpbGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2Fyb3VzZWxcclxuICAgICAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRpbGVrZXkgLSBUaGUgdGlsZSBrZXkgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBsYXllciBpbmRleCBmb3IgdGhlIHRpbGUuXHJcbiAgICAgKi9cclxuICAgIENhcm91c2VsLnByb3RvdHlwZS5nZXRMYXllckluZGV4Rm9yVGlsZSA9IGZ1bmN0aW9uKCB0aWxla2V5ICkge1xyXG4gICAgICAgIHZhciBsYXllckluZGV4ID0gdGhpcy5pbmRpY2VzQnlUaWxlWyB0aWxla2V5IF07XHJcbiAgICAgICAgcmV0dXJuIGxheWVySW5kZXggIT09IHVuZGVmaW5lZCA/IGxheWVySW5kZXggOiB0aGlzLmRlZmF1bHRJbmRleDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZW5kZXJlciBmb3IgYSBwYXJ0aWN1bGFyIHRpbGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2Fyb3VzZWxcclxuICAgICAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRpbGVrZXkgLSBUaGUgdGlsZSBrZXkgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByZW5kZXJlciBmb3IgdGhlIHRpbGUuXHJcbiAgICAgKi9cclxuICAgIENhcm91c2VsLnByb3RvdHlwZS5nZXRSZW5kZXJlckZvclRpbGUgPSBmdW5jdGlvbiggdGlsZWtleSApIHtcclxuICAgICAgICB2YXIgbGF5ZXJJbmRleCA9IHRoaXMuZ2V0TGF5ZXJJbmRleEZvclRpbGUoIHRpbGVrZXkgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5sYXllcnNbIGxheWVySW5kZXggXS5yZW5kZXJlcjtcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDYXJvdXNlbDtcclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xyXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cclxuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBMYXllciA9IHJlcXVpcmUoJy4vTGF5ZXInKSxcclxuICAgICAgICBMYXllclV0aWwgPSByZXF1aXJlKCcuL0xheWVyVXRpbCcpLFxyXG4gICAgICAgIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKSxcclxuICAgICAgICBIdG1sVGlsZUxheWVyID0gcmVxdWlyZSgnLi9IdG1sVGlsZUxheWVyJyksXHJcbiAgICAgICAgUHViU3ViID0gcmVxdWlyZSgnLi4vdXRpbC9QdWJTdWInKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByaXZhdGU6IFJldHVybnMgdGhlIHpvb20gY2FsbGJhY2sgZnVuY3Rpb24gdG8gdXBkYXRlIGxldmVsIG1pbiBhbmQgbWF4ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxheWVyIHtTZXJ2ZXJMYXllcn0gVGhlIGxheWVyIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gem9vbUNhbGxiYWNrKCBsYXllciApIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggbGF5ZXIub2xMYXllciApIHtcclxuICAgICAgICAgICAgICAgIGxheWVyLnNldExldmVsTWluTWF4KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGUgYSBDbGllbnRMYXllciBvYmplY3QuXHJcbiAgICAgKiBAY2xhc3MgQ2xpZW50TGF5ZXJcclxuICAgICAqIEBhdWdtZW50cyBMYXllclxyXG4gICAgICogQGNsYXNzZGVzYyBBIGNsaWVudCByZW5kZXJlZCBsYXllciBvYmplY3QuIFVzZXMgSlNPTiBkYXRhIHJldHJpZXZlZCBmcm9tIHRoZVxyXG4gICAgICogICAgICAgICAgICBzZXJ2ZXIgaW4gY29uanVuY3Rpb24gd2l0aCBhIFJlbmRlcmVyIG9iamVjdCBvciBodG1sIGZ1bmN0aW9uIHRvXHJcbiAgICAgKiAgICAgICAgICAgIGNyZWF0ZSBpbnRlcmFjdGFibGUgRE9NIGVsZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIC0gVGhlIHNwZWNpZmljYXRpb24gb2JqZWN0LlxyXG4gICAgICogPHByZT5cclxuICAgICAqIHtcclxuICAgICAqICAgICBvcGFjaXR5ICB7ZmxvYXR9ICAgIC0gVGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLiBEZWZhdWx0ID0gMS4wXHJcbiAgICAgKiAgICAgZW5hYmxlZCAge2Jvb2xlYW59ICAtIFdoZXRoZXIgdGhlIGxheWVyIGlzIHZpc2libGUgb3Igbm90LiBEZWZhdWx0ID0gdHJ1ZVxyXG4gICAgICogICAgIHpJbmRleCAgIHtpbnRlZ2VyfSAgLSBUaGUgeiBpbmRleCBvZiB0aGUgbGF5ZXIuIERlZmF1bHQgPSAxMDAwXHJcbiAgICAgKiAgICAgcmVuZGVyZXIge1JlbmRlcmVyfSAtIFRoZSB0aWxlIHJlbmRlcmVyIG9iamVjdC5cclxuICAgICAqIH1cclxuICAgICAqIDwvcHJlPlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDbGllbnRMYXllciggc3BlYyApIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXHJcbiAgICAgICAgICAgIGdldFVSTCA9IHNwZWMuZ2V0VVJMIHx8IExheWVyVXRpbC5nZXRVUkw7XHJcbiAgICAgICAgLy8gY2FsbCBiYXNlIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgTGF5ZXIuY2FsbCggdGhpcywgc3BlYyApO1xyXG4gICAgICAgIC8vIHNldCByZWFzb25hYmxlIGRlZmF1bHRzXHJcbiAgICAgICAgdGhpcy56SW5kZXggPSAoIHNwZWMuekluZGV4ICE9PSB1bmRlZmluZWQgKSA/IHBhcnNlSW50KCBzcGVjLnpJbmRleCwgMTAgKSA6IDEwMDA7XHJcbiAgICAgICAgdGhpcy50aWxlVHJhbnNmb3JtID0gc3BlYy50aWxlVHJhbnNmb3JtIHx8IHt9O1xyXG4gICAgICAgIHRoaXMuZG9tYWluID0gXCJjbGllbnRcIjtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNwZWMuc291cmNlO1xyXG4gICAgICAgIHRoaXMuZ2V0VVJMID0gZnVuY3Rpb24oIGJvdW5kcyApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldFVSTC5jYWxsKCB0aGlzLCBib3VuZHMgKSArIHRoYXQuZ2V0UXVlcnlQYXJhbVN0cmluZygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCBzcGVjLnRpbGVDbGFzcyApIHtcclxuICAgICAgICAgICAgdGhpcy50aWxlQ2xhc3MgPSBzcGVjLnRpbGVDbGFzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCBzcGVjLnJlbmRlcmVyICkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFJlbmRlcmVyKCBzcGVjLnJlbmRlcmVyICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggc3BlYy5hZ2dyZWdhdG9ycyApIHtcclxuICAgICAgICAgICAgXy5mb3JJbiggc3BlYy5hZ2dyZWdhdG9ycywgZnVuY3Rpb24oIGFnZywga2V5ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBZ2dyZWdhdG9yKCBrZXksIGFnZyApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQ2xpZW50TGF5ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGF5ZXIucHJvdG90eXBlICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIGxheWVyIG9iamVjdC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG4gICAgICogQG1lbWJlcm9mIENsaWVudExheWVyXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBDbGllbnRMYXllci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBzZXQgY2FsbGJhY2sgaGVyZSBzbyBpdCBjYW4gYmUgcmVtb3ZlZCBsYXRlclxyXG4gICAgICAgIHRoaXMuem9vbUNhbGxiYWNrID0gem9vbUNhbGxiYWNrKCB0aGlzICk7XHJcbiAgICAgICAgLy8gc2V0IGNhbGxiYWNrIHRvIHVwZGF0ZSByYW1wIG1pbi9tYXggb24gem9vbVxyXG4gICAgICAgIHRoaXMubWFwLm9uKCBcInpvb21lbmRcIiwgdGhpcy56b29tQ2FsbGJhY2sgKTtcclxuICAgICAgICAvLyBhZGQgdGhlIG5ldyBsYXllclxyXG4gICAgICAgIHRoaXMub2xMYXllciA9IG5ldyBIdG1sVGlsZUxheWVyKFxyXG4gICAgICAgICAgICAnQ2xpZW50IFJlbmRlcmVkIFRpbGUgTGF5ZXInLFxyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZS50bXMsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxheWVybmFtZTogdGhpcy5zb3VyY2UuaWQsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgICAgICBtYXhFeHRlbnQ6IG5ldyBPcGVuTGF5ZXJzLkJvdW5kcygtMjAwMzc1MDAsIC0yMDAzNzUwMCxcclxuICAgICAgICAgICAgICAgICAgICAyMDAzNzUwMCwgIDIwMDM3NTAwKSxcclxuICAgICAgICAgICAgICAgIGlzQmFzZUxheWVyOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGdldFVSTDogdGhpcy5nZXRVUkwsXHJcbiAgICAgICAgICAgICAgICB0aWxlQ2xhc3M6IHRoaXMudGlsZUNsYXNzLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHRoaXMucmVuZGVyZXJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gc2V0IHdoZXRoZXIgaXQgaXMgZW5hYmxlZCBvciBub3QgYmVmb3JlIGF0dGFjaGluZywgdG8gcHJldmVudFxyXG4gICAgICAgIC8vIG5lZWRsZXNzIHRpbGUgcmVxZWVzdHNcclxuICAgICAgICB0aGlzLnNldEVuYWJsZWQoIHRoaXMuaXNFbmFibGVkKCkgKTtcclxuICAgICAgICB0aGlzLnNldFRoZW1lKCB0aGlzLm1hcC5nZXRUaGVtZSgpICk7XHJcbiAgICAgICAgdGhpcy5zZXRPcGFjaXR5KCB0aGlzLmdldE9wYWNpdHkoKSApO1xyXG4gICAgICAgIHRoaXMuc2V0QnJpZ2h0bmVzcyggdGhpcy5nZXRCcmlnaHRuZXNzKCkgKTtcclxuICAgICAgICB0aGlzLnNldENvbnRyYXN0KCB0aGlzLmdldENvbnRyYXN0KCkgKTtcclxuICAgICAgICAvLyBwdWJsaXNoIGFjdGl2YXRlIGV2ZW50IGJlZm9yZSBhcHBlbmRpbmcgdG8gbWFwXHJcbiAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnYWN0aXZhdGUnLCB2YWx1ZTogdHJ1ZSB9ICk7XHJcbiAgICAgICAgLy8gYXR0YWNoIHRvIG1hcFxyXG4gICAgICAgIHRoaXMubWFwLm9sTWFwLmFkZExheWVyKCB0aGlzLm9sTGF5ZXIgKTtcclxuICAgICAgICAvLyBzZXQgei1pbmRleCBhZnRlclxyXG4gICAgICAgIHRoaXMuc2V0WkluZGV4KCB0aGlzLnpJbmRleCApO1xyXG4gICAgICAgIHRoaXMuc2V0TGV2ZWxNaW5NYXgoKTsgLy8gc2V0IGxldmVsIG1pbiAvIG1heFxyXG4gICAgICAgIC8vIHB1Ymxpc2ggYWRkIGV2ZW50XHJcbiAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnYWRkJywgdmFsdWU6IHRydWUgfSApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY3RpdmF0ZXMgdGhlIGxheWVyIG9iamVjdC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG4gICAgICogQG1lbWJlcm9mIENsaWVudExheWVyXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBDbGllbnRMYXllci5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICggdGhpcy5vbExheWVyICkge1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5vbE1hcC5yZW1vdmVMYXllciggdGhpcy5vbExheWVyICk7XHJcbiAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ3JlbW92ZScsIHZhbHVlOiB0cnVlIH0gKTtcclxuICAgICAgICAgICAgdGhpcy5vbExheWVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5vbExheWVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXAub2ZmKCBcInpvb21lbmRcIiwgdGhpcy56b29tQ2FsbGJhY2sgKTtcclxuICAgICAgICB0aGlzLnpvb21DYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnZGVhY3RpdmF0ZScsIHZhbHVlOiB0cnVlIH0gKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHJlbmRlcmVyIG9mIHRoZSBsYXllci5cclxuICAgICAqIEBtZW1iZXJvZiBDbGllbnRMYXllclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRvIGF0dGFjaCB0byB0aGUgbGF5ZXIuXHJcbiAgICAgKi9cclxuICAgIENsaWVudExheWVyLnByb3RvdHlwZS5zZXRSZW5kZXJlciA9IGZ1bmN0aW9uKCByZW5kZXJlciApIHtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hdHRhY2goIHRoaXMgKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGFnZ3JlZ2F0b3IgdG8gdGhlIGxheWVyLlxyXG4gICAgICogQG1lbWJlcm9mIENsaWVudExheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gVGhlIGFnZ3JlZ2F0b3IgaWQuXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0byBhdHRhY2ggdG8gdGhlIGxheWVyLlxyXG4gICAgICovXHJcbiAgICBDbGllbnRMYXllci5wcm90b3R5cGUuYWRkQWdncmVnYXRvciA9IGZ1bmN0aW9uKCBpZCwgYWdncmVnYXRvciApIHtcclxuICAgICAgICB0aGlzLmFnZ3JlZ2F0b3JzID0gdGhpcy5hZ2dyZWdhdG9ycyB8fCB7fTtcclxuICAgICAgICB0aGlzLmFnZ3JlZ2F0b3JzWyBpZCBdID0gYWdncmVnYXRvcjtcclxuICAgICAgICB0aGlzLmFnZ3JlZ2F0b3JzWyBpZCBdLmF0dGFjaCggdGhpcyApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYW4gYWdncmVnYXRvciBieSBpZC5cclxuICAgICAqIEBtZW1iZXJvZiBDbGllbnRMYXllclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIFRoZSBhZ2dyZWdhdG9yIGlkLlxyXG4gICAgICovXHJcbiAgICBDbGllbnRMYXllci5wcm90b3R5cGUuZ2V0QWdncmVnYXRvciA9IGZ1bmN0aW9uKCBpZCApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZ2dyZWdhdG9yc1sgaWQgXTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB0aGVtZSBhc3NvY2lhdGVkIHdpdGggdGhlIGxheWVyLlxyXG4gICAgICogQG1lbWJlcm9mIENsaWVudExheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRoZW1lIC0gVGhlIHRoZW1lIGlkZW50aWZpZXIgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBDbGllbnRMYXllci5wcm90b3R5cGUuc2V0VGhlbWUgPSBmdW5jdGlvbiggdGhlbWUgKSB7XHJcbiAgICAgICAgdGhpcy50aGVtZSA9IHRoZW1lO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY3VycmVudCB0aGVtZSBmb3IgdGhlIGxheWVyLlxyXG4gICAgICogQG1lbWJlcm9mIENsaWVudExheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHRoZW1lIGlkZW50aWZpZXIgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBDbGllbnRMYXllci5wcm90b3R5cGUuZ2V0VGhlbWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aGVtZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHogaW5kZXggb2YgdGhlIGxheWVyLlxyXG4gICAgICogQG1lbWJlcm9mIENsaWVudExheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSB6SW5kZXggLSBUaGUgbmV3IHotb3JkZXIgdmFsdWUgb2YgdGhlIGxheWVyLCB3aGVyZSAwIGlzIGZyb250LlxyXG4gICAgICovXHJcbiAgICBDbGllbnRMYXllci5wcm90b3R5cGUuc2V0WkluZGV4ID0gZnVuY3Rpb24gKCB6SW5kZXggKSB7XHJcbiAgICAgICAgLy8gd2UgYnktcGFzcyB0aGUgT3BlbkxheWVycy5NYXAuc2V0TGF5ZXJJbmRleCgpIG1ldGhvZCBhbmQgbWFudWFsbHlcclxuICAgICAgICAvLyBzZXQgdGhlIHotaW5kZXggb2YgdGhlIGxheWVyIGRldi4gc2V0TGF5ZXJJbmRleCBzZXRzIGEgcmVsYXRpdmVcclxuICAgICAgICAvLyBpbmRleCBiYXNlZCBvbiBjdXJyZW50IG1hcCBsYXllcnMsIHdoaWNoIHRoZW4gc2V0cyBhIHotaW5kZXguIFRoaXNcclxuICAgICAgICAvLyBjYXVzZWQgaXNzdWVzIHdpdGggYXN5bmMgbGF5ZXIgbG9hZGluZy5cclxuICAgICAgICB0aGlzLnpJbmRleCA9IHpJbmRleDtcclxuICAgICAgICBpZiAoIHRoaXMub2xMYXllciApIHtcclxuICAgICAgICAgICAgJCggdGhpcy5vbExheWVyLmRpdiApLmNzcyggJ3otaW5kZXgnLCB6SW5kZXggKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnekluZGV4JywgdmFsdWU6IHpJbmRleCB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGxheWVycyB6SW5kZXguXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2xpZW50TGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIHpJbmRleCBmb3IgdGhlIGxheWVyLlxyXG4gICAgICovXHJcbiAgICBDbGllbnRMYXllci5wcm90b3R5cGUuZ2V0WkluZGV4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnpJbmRleDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGxheWVycyB0aWxlIHRyYW5zZm9ybSBmdW5jdGlvbiB0eXBlLlxyXG4gICAgICogQG1lbWJlcm9mIENsaWVudExheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zZm9ybVR5cGUgLSBUaGUgdGlsZSB0cmFuc2Zvcm1lciB0eXBlLlxyXG4gICAgICovXHJcbiAgICBDbGllbnRMYXllci5wcm90b3R5cGUuc2V0VGlsZVRyYW5zZm9ybVR5cGUgPSBmdW5jdGlvbiAoIHRyYW5zZm9ybVR5cGUgKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLnRpbGVUcmFuc2Zvcm0udHlwZSAhPT0gdHJhbnNmb3JtVHlwZSApIHtcclxuICAgICAgICAgICAgdGhpcy50aWxlVHJhbnNmb3JtLnR5cGUgPSB0cmFuc2Zvcm1UeXBlO1xyXG4gICAgICAgICAgICB0aGlzLnJlZHJhdygpO1xyXG4gICAgICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHtmaWVsZDogJ3RpbGVUcmFuc2Zvcm1UeXBlJywgdmFsdWU6IHRyYW5zZm9ybVR5cGV9ICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbGF5ZXJzIHRyYW5zZm9ybWVyIHR5cGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2xpZW50TGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB0aWxlIHRyYW5zZm9ybSB0eXBlLlxyXG4gICAgICovXHJcbiAgICBDbGllbnRMYXllci5wcm90b3R5cGUuZ2V0VGlsZVRyYW5zZm9ybVR5cGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVRyYW5zZm9ybS50eXBlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgdGlsZSB0cmFuc2Zvcm0gZGF0YSBiYXNlZCBvbiB0aGUgdGltZSByYW5nZSBwYXNzZWQgaW5cclxuICAgICAqIEBtZW1iZXJvZiBDbGllbnRMYXllclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEEgdW5peCB0aW1lc3RhbXAgcmVwcmVzZW50aW5nIHRoZSBzdGFydCBvZiB0aGUgdGltZSByYW5nZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCAtIEEgdW5peCB0aW1lc3RhbXAgcmVwcmVzZW50aW5nIHRoZSBlbmQgb2YgdGhlIHRpbWUgcmFuZ2VcclxuICAgICAqL1xyXG4gICAgQ2xpZW50TGF5ZXIucHJvdG90eXBlLnNldFRpbGVUcmFuc2Zvcm1SYW5nZSA9IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcclxuXHRcdHZhciBtZXRhID0gdGhpcy5zb3VyY2UubWV0YS5tZXRhLFxyXG5cdFx0XHRyYW5nZU1pbiA9IG1ldGEucmFuZ2VNaW4sXHJcblx0XHRcdHJhbmdlTWF4ID0gbWV0YS5yYW5nZU1heCxcclxuXHRcdFx0bnVtQnVja2V0cyA9IG1ldGEuYnVja2V0Q291bnQsXHJcbiAgICAgICAgICAgIGJ1Y2tldFNpemUgPSAoIHJhbmdlTWF4IC0gcmFuZ2VNaW4gKSAvIG51bUJ1Y2tldHM7XHJcbiAgICAgICAgaWYgKCBzdGFydCA+IHJhbmdlTWF4ICYmIGVuZCA8IHJhbmdlTWluICkge1xyXG4gICAgICAgICAgICAvLyBvdXRzaWRlIHJhbmdlIGNvbXBsZXRlbHksIHNlbmQgZW1wdHkgcmVxdWVzdFxyXG5cdFx0XHR0aGlzLnNldFRpbGVUcmFuc2Zvcm1EYXRhKHtcclxuICAgIFx0XHRcdHN0YXJ0QnVja2V0OiAtMSxcclxuICAgIFx0XHRcdGVuZEJ1Y2tldDogLTFcclxuICAgICAgICAgICAgfSk7XHJcblx0XHR9XHJcblx0XHR0aGlzLnNldFRpbGVUcmFuc2Zvcm1EYXRhKHtcclxuXHRcdFx0c3RhcnRCdWNrZXQ6IE1hdGgubWF4KCAwLCBNYXRoLmZsb29yKCAoIHN0YXJ0IC0gcmFuZ2VNaW4gKSAvIGJ1Y2tldFNpemUgKSApLFxyXG5cdFx0XHRlbmRCdWNrZXQ6IE1hdGgubWluKCBudW1CdWNrZXRzIC0gMSwgTWF0aC5mbG9vciggKCBlbmQgLSByYW5nZU1pbiApIC8gYnVja2V0U2l6ZSApIClcclxuICAgICAgICB9KTtcclxuXHR9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB0aWxlIHRyYW5zZm9ybSBkYXRhIGF0dHJpYnV0ZSBpbnRlcm5hbGx5XHJcbiAgICAgKiBAbWVtYmVyb2YgQ2xpZW50TGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtRGF0YSAtIFRoZSB0aWxlIHRyYW5zZm9ybSBkYXRhIGF0dHJpYnV0ZS5cclxuICAgICAqL1xyXG5cdENsaWVudExheWVyLnByb3RvdHlwZS5zZXRUaWxlVHJhbnNmb3JtRGF0YSA9IGZ1bmN0aW9uKCB0cmFuc2Zvcm1EYXRhICkge1xyXG4gICAgICAgIGlmICggIV8uaXNFcXVhbCggdGhpcy50aWxlVHJhbnNmb3JtLmRhdGEsIHRyYW5zZm9ybURhdGEgKSApIHtcclxuICAgICAgICAgICAgdGhpcy50aWxlVHJhbnNmb3JtLmRhdGEgPSB0cmFuc2Zvcm1EYXRhO1xyXG4gICAgICAgICAgICB0aGlzLnJlZHJhdygpO1xyXG4gICAgICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHtmaWVsZDogJ3RpbGVUcmFuc2Zvcm1EYXRhJywgdmFsdWU6IHRyYW5zZm9ybURhdGF9ICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdHJhbnNmb3JtZXIgZGF0YSBhdHRyaWJ1dGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2xpZW50TGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdGlsZSB0cmFuc2Zvcm0gZGF0YSBhdHRyaWJ1dGUuXHJcbiAgICAgKi9cclxuICAgIENsaWVudExheWVyLnByb3RvdHlwZS5nZXRUaWxlVHJhbnNmb3JtRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aWxlVHJhbnNmb3JtLmRhdGEgfHwge307XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjdXJyZW50IG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzIGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsLlxyXG4gICAgICogQG1lbWJlcm9mIENsaWVudExheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFRoZSBtaW4gYW5kIG1heCBvZiB0aGUgbGV2ZWwuXHJcbiAgICAgKi9cclxuICAgIENsaWVudExheWVyLnByb3RvdHlwZS5nZXRMZXZlbE1pbk1heCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxldmVsTWluTWF4O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIHF1ZXJ5IHBhcmFtZXRlcnMgYmFzZWQgb24gc3RhdGUgb2YgbGF5ZXJcclxuICAgICAqIEBtZW1iZXJvZiBDbGllbnRMYXllclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBxdWVyeSBwYXJhbWV0ZXIgc3RyaW5nIGJhc2VkIG9uIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgbGF5ZXIuXHJcbiAgICAgKi9cclxuICAgICBDbGllbnRMYXllci5wcm90b3R5cGUuZ2V0UXVlcnlQYXJhbVN0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBxdWVyeSA9IHtcclxuICAgICAgICAgICAgdGlsZVRyYW5zZm9ybTogdGhpcy50aWxlVHJhbnNmb3JtXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVXRpbC5lbmNvZGVRdWVyeVBhcmFtcyggcXVlcnkgKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRyYXdzIHRoZSBlbnRpcmUgbGF5ZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2xpZW50TGF5ZXJcclxuICAgICAqL1xyXG4gICAgQ2xpZW50TGF5ZXIucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIHRoaXMub2xMYXllciApIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRMZXZlbE1pbk1heCgpO1xyXG4gICAgICAgICAgICB0aGlzLm9sTGF5ZXIucmVkcmF3KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0WkluZGV4KHRoaXMuekluZGV4KTtcclxuICAgICAgICAgICAgLy8gSWYgd2UncmUgdXNpbmcgdGhlIFRpbGVNYW5hZ2VyIHdlIG5lZWQgdG8gZm9yY2UgaXQgaW50byBhIHJlZnJlc2guIFRoZXJlIGlzIG5vIG5pY2Ugd2F5IHRvXHJcbiAgICAgICAgICAgIC8vIGRvIHRoaXMgYXMgb2YgMi4xMy4xLCBzbyB3ZSBmYWtlIHRoZSBleHBpcnkgb2YgdGhlIG1vdmUvem9vbSB0aW1lb3V0LlxyXG4gICAgICAgICAgICBpZiAoIHRoaXMub2xMYXllci5tYXAgJiYgdGhpcy5vbExheWVyLm1hcC50aWxlTWFuYWdlciApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2xMYXllci5tYXAudGlsZU1hbmFnZXIudXBkYXRlVGltZW91dChcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9sTGF5ZXIubWFwLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2xMYXllci5tYXAudGlsZU1hbmFnZXIuem9vbURlbGF5LFxyXG4gICAgICAgICAgICAgICAgICAgIHRydWUgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBsYXllcnMgbWluIGFuZCBtYXggdmFsdWVzIGZvciB0aGUgZ2l2ZW4gem9vbSBsZXZlbC5cclxuICAgICAqIEBtZW1iZXJvZiBDbGllbnRMYXllclxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSBsYXllciB7T2JqZWN0fSB0aGUgbGF5ZXIgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBDbGllbnRMYXllci5wcm90b3R5cGUuc2V0TGV2ZWxNaW5NYXggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgem9vbUxldmVsID0gdGhpcy5tYXAuZ2V0Wm9vbSgpLFxyXG4gICAgICAgICAgICBzb3VyY2UgPSB0aGlzLnNvdXJjZSxcclxuICAgICAgICAgICAgbWV0YSA9IHNvdXJjZS5tZXRhICYmIHNvdXJjZS5tZXRhLm1ldGEgPyBzb3VyY2UubWV0YS5tZXRhWyB6b29tTGV2ZWwgXSA6IG51bGwsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybURhdGEgPSB0aGlzLnRpbGVUcmFuc2Zvcm0uZGF0YSB8fCB7fSxcclxuICAgICAgICAgICAgbGV2ZWxNaW5NYXggPSBtZXRhLFxyXG4gICAgICAgICAgICByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsXHJcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZWQ7XHJcbiAgICAgICAgaWYgKCBtZXRhICkge1xyXG4gICAgICAgICAgICAvLyBhZ2dyZWdhdGUgdGhlIGRhdGEgaWYgdGhlcmUgaXMgYW4gYWdncmVnYXRvciBhdHRhY2hlZFxyXG4gICAgICAgICAgICBpZiAoIHJlbmRlcmVyICYmIHJlbmRlcmVyLmFnZ3JlZ2F0b3IgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhZ2dyZWdhdGUgdGhlIG1ldGEgZGF0YSBidWNrZXRzXHJcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkID0gcmVuZGVyZXIuYWdncmVnYXRvci5hZ2dyZWdhdGUoXHJcbiAgICAgICAgICAgICAgICAgICAgbWV0YS5iaW5zIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEuc3RhcnRCdWNrZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5lbmRCdWNrZXQgKTtcclxuICAgICAgICAgICAgICAgIGlmICggYWdncmVnYXRlZCBpbnN0YW5jZW9mIEFycmF5ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRha2UgdGhlIGZpcnN0IGFuZCBsYXN0IGluZGV4LCB3aGljaCBjb3JyZXNwb25kIHRvIG1heCAvIG1pblxyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsTWluTWF4ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBhZ2dyZWdhdGVkW2FnZ3JlZ2F0ZWQubGVuZ3RoIC0gMV0gfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogYWdncmVnYXRlZFswXSB8fCBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICBsZXZlbE1pbk1heCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogYWdncmVnYXRlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogYWdncmVnYXRlZFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXZlbE1pbk1heCA9IHtcclxuICAgICAgICAgICAgICAgIG1pbmltdW06IG51bGwsXHJcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiBudWxsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGV2ZWxNaW5NYXggPSBsZXZlbE1pbk1heDtcclxuICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICdsZXZlbE1pbk1heCcsIHZhbHVlOiBsZXZlbE1pbk1heCB9KTtcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDbGllbnRMYXllcjtcclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xyXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cclxuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBNYXBVdGlsID0gcmVxdWlyZSgnLi4vbWFwL01hcFV0aWwnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbnRpYXRlIGEgSHRtbE1hcmtlciBvYmplY3QuXHJcbiAgICAgKiBAY2xhc3MgSHRtbE1hcmtlclxyXG4gICAgICogQGNsYXNzZGVzYyBBIEh0bWxNYXJrZXIgb2JqZWN0IHRoYXQgaXMgcGlubmVkIHRvIGFuIEh0bWxNYXJrZXJMYXllci5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gSHRtbE1hcmtlciggeCwgeSwgaHRtbCwgZGltZW5zaW9uICkge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLmh0bWwgPSBodG1sO1xyXG4gICAgICAgIHRoaXMuZGltZW5zaW9uID0gZGltZW5zaW9uO1xyXG4gICAgICAgIHRoaXMuaWNvbiA9IG5ldyBPcGVuTGF5ZXJzLkljb24oXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIG5ldyBPcGVuTGF5ZXJzLlNpemUoIDIsIDIgKSxcclxuICAgICAgICAgICAgbmV3IE9wZW5MYXllcnMuUGl4ZWwoIC0xLCAtMiApICk7XHJcbiAgICB9XHJcblxyXG4gICAgSHRtbE1hcmtlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFjdGl2YXRlcyB0aGUgSHRtbE1hcmtlciBvYmplY3QuIFRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCBtYW51YWxseS5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgSHRtbE1hcmtlclxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdmlld3BvcnRQeCA9IE1hcFV0aWwuZ2V0Vmlld3BvcnRQaXhlbEZyb21Db29yZCggdGhpcy5tYXAsIHRoaXMueCwgdGhpcy55ICksXHJcbiAgICAgICAgICAgICAgICBsb25sYXQgPSB0aGlzLm1hcC5vbE1hcC5nZXRMb25MYXRGcm9tVmlld1BvcnRQeCggdmlld3BvcnRQeCApO1xyXG4gICAgICAgICAgICB0aGlzLm9sTWFya2VyID0gbmV3IE9wZW5MYXllcnMuTWFya2VyKCBsb25sYXQsIHRoaXMuaWNvbi5jbG9uZSgpICk7XHJcbiAgICAgICAgICAgIHRoaXMubGF5ZXIub2xMYXllci5hZGRNYXJrZXIoIHRoaXMub2xNYXJrZXIgKTtcclxuICAgICAgICAgICAgLy8gZ2V0IG1hcmtlciBlbGVtXHJcbiAgICAgICAgICAgIHZhciAkcGFyZW50ID0gJCggdGhpcy5vbE1hcmtlci5pY29uLmltYWdlRGl2ICk7XHJcbiAgICAgICAgICAgIC8vIGhpZGUgaWNvbiBlbGVtZW50XHJcbiAgICAgICAgICAgICRwYXJlbnQuY2hpbGRyZW4oKS5jc3MoICdkaXNwbGF5JywgJ25vbmUnICk7XHJcbiAgICAgICAgICAgIHRoaXMuJGVsZW0gPSAkKCB0aGlzLmh0bWwgKTtcclxuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyID0gJHBhcmVudC5wYXJlbnQoKTtcclxuICAgICAgICAgICAgdGhpcy4kb2xDb250YWluZXIgPSB0aGlzLiRjb250YWluZXIucGFyZW50KCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRpbWVuc2lvbikge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG1hcmtlciBpcyByZXN0cmljdGVkIHRvIG1vdmUgaW4gb25lIGRpcmVjdGlvbiByZWdpc3RlciBtb3ZlIGhhbmRsZXJzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uID0gdGhpcy51cGRhdGVQb3NpdGlvbi5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXAub2xNYXAuZXZlbnRzLnJlZ2lzdGVyKCAnbW92ZScsIHRoaXMubWFwLm9sTWFwLCB0aGlzLnVwZGF0ZVBvc2l0aW9uICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYWRkIG1hcmtlclxyXG4gICAgICAgICAgICAkcGFyZW50LmFwcGVuZCggdGhpcy5odG1sICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGUtYWN0aXZhdGVzIHRoZSBIdG1sTWFya2VyIG9iamVjdC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBIdG1sTWFya2VyXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWFjdGl2YXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLm9sTWFya2VyICYmIHRoaXMubGF5ZXIub2xMYXllciApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGF5ZXIub2xMYXllci5yZW1vdmVNYXJrZXIoIHRoaXMub2xNYXJrZXIgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwLm9sTWFwLmV2ZW50cy51bnJlZ2lzdGVyKCAnbW92ZScsIHRoaXMubWFwLm9sTWFwLCB0aGlzLnVwZGF0ZVBvc2l0aW9uICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9sTWFya2VyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub2xNYXJrZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBvbiBtYXJrZXIgd2hlbiBpXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEh0bWxNYXJrZXJcclxuICAgICAgICAgKiBAcHVibGljZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXAub2xNYXAuZXZlbnRzLnVucmVnaXN0ZXIoICdtb3ZlJywgdGhpcy5tYXAub2xNYXAsIHRoaXMudXBkYXRlUG9zaXRpb24gKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNb3ZlcyB0aGUgbWFya2VyIHRvIGEgbmV3IHggYW5kIHkgY29vcmRpbmF0ZS5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgSHRtbE1hcmtlclxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgY29vcmRpbmF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uKCB4LCB5ICkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgICAgICB2YXIgdmlld3BvcnRQeCA9IE1hcFV0aWwuZ2V0Vmlld3BvcnRQaXhlbEZyb21Db29yZCggdGhpcy5tYXAsIHRoaXMueCwgdGhpcy55ICksXHJcbiAgICAgICAgICAgICAgICBsb25sYXQgPSB0aGlzLm1hcC5vbE1hcC5nZXRMb25MYXRGcm9tVmlld1BvcnRQeCggdmlld3BvcnRQeCApLFxyXG4gICAgICAgICAgICAgICAgcHggPSB0aGlzLm1hcC5vbE1hcC5nZXRMYXllclB4RnJvbUxvbkxhdCggbG9ubGF0ICk7XHJcbiAgICAgICAgICAgIHRoaXMub2xNYXJrZXIubW92ZVRvKCBweCApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGxlZCBvbiBtYXAgbW92ZSB0byBmaXggbWFya2VyIGFsb25nIGEgY29uZmlndXJlZCBheGlzXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEh0bWxNYXJrZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgJGNvbnRhaW5lciA9IHRoaXMuJG9sQ29udGFpbmVyLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gJGNvbnRhaW5lci5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuZGltZW5zaW9uID09PSBcInhcIiApIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgbWFya2VyIHkgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIHRoaXMuJGVsZW0ucGFyZW50KCkuY3NzKCAndG9wJywgLW9mZnNldC50b3AgKyBcInB4XCIgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIdG1sTWFya2VyO1xyXG59KCkpO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cdHZhciBMYXllciA9IHJlcXVpcmUoJy4vTGF5ZXInKSxcclxuXHRcdFB1YlN1YiA9IHJlcXVpcmUoJy4uL3V0aWwvUHViU3ViJyk7XHJcblxyXG5cdGZ1bmN0aW9uIGFkZE1hcmtlclRvTGF5ZXIoIGxheWVyLCBtYXJrZXIgKSB7XHJcblx0XHRtYXJrZXIubGF5ZXIgPSBsYXllcjtcclxuXHRcdG1hcmtlci5tYXAgPSBsYXllci5tYXA7XHJcblx0XHRtYXJrZXIuYWN0aXZhdGUoKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbW92ZU1hcmtlckZyb21MYXllciggbWFya2VyICkge1xyXG5cdFx0bWFya2VyLmRlYWN0aXZhdGUoKTtcclxuXHRcdG1hcmtlci5tYXAgPSBudWxsO1xyXG5cdFx0bWFya2VyLmxheWVyID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlIGEgSHRtbE1hcmtlckxheWVyIG9iamVjdC5cclxuXHQgKiBAY2xhc3MgSHRtbE1hcmtlckxheWVyXHJcblx0ICogQGF1Z21lbnRzIExheWVyXHJcblx0ICogQGNsYXNzZGVzYyBBIGNsaWVudCByZW5kZXJlZCBtYXJrZXIgbGF5ZXIgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHNwZWMgLSBUaGUgc3BlY2lmaWNhdGlvbiBvYmplY3QuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gSHRtbE1hcmtlckxheWVyKCBzcGVjICkge1xyXG5cdFx0c3BlYyA9IHNwZWMgfHwge307XHJcblx0XHQvLyBjYWxsIGJhc2UgY29uc3RydWN0b3JcclxuXHRcdExheWVyLmNhbGwoIHRoaXMsIHNwZWMgKTtcclxuXHRcdC8vIHNldCByZWFzb25hYmxlIGRlZmF1bHRzXHJcblx0XHR0aGlzLnpJbmRleCA9ICggc3BlYy56SW5kZXggIT09IHVuZGVmaW5lZCApID8gc3BlYy56SW5kZXggOiA3NDk7XHJcblx0XHR0aGlzLmRvbWFpbiA9IFwibWFya2VyXCI7XHJcblx0XHR0aGlzLnNvdXJjZSA9IHNwZWMuc291cmNlO1xyXG5cdFx0dGhpcy5tYXJrZXJzID0gc3BlYy5tYXJrZXJzIHx8IFtdO1xyXG5cdH1cclxuXHJcblx0SHRtbE1hcmtlckxheWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExheWVyLnByb3RvdHlwZSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBBY3RpdmF0ZXMgdGhlIGxheWVyIG9iamVjdC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG5cdCAqIEBtZW1iZXJvZiBIdG1sTWFya2VyTGF5ZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdEh0bWxNYXJrZXJMYXllci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMub2xMYXllciA9IG5ldyBPcGVuTGF5ZXJzLkxheWVyLk1hcmtlcnMoIFwiTWFya2Vyc1wiICk7XHJcblx0XHR0aGlzLnNldE9wYWNpdHkoIHRoaXMub3BhY2l0eSApO1xyXG5cdFx0dGhpcy5zZXRFbmFibGVkKCB0aGlzLmVuYWJsZWQgKTtcclxuXHRcdHRoaXMuc2V0VGhlbWUoIHRoaXMubWFwLmdldFRoZW1lKCkgKTtcclxuXHRcdHRoaXMubWFwLm9sTWFwLmFkZExheWVyKCB0aGlzLm9sTGF5ZXIgKTtcclxuXHRcdHRoaXMubWFya2Vycy5mb3JFYWNoKCBmdW5jdGlvbiggbWFya2VyICkge1xyXG5cdFx0XHRhZGRNYXJrZXJUb0xheWVyKCB0aGlzLCBtYXJrZXIgKTtcclxuXHRcdH0sIHRoaXMgKTtcclxuXHRcdHRoaXMuc2V0WkluZGV4KCB0aGlzLnpJbmRleCApO1xyXG5cdFx0UHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnYWN0aXZhdGUnLCB2YWx1ZTogdHJ1ZSB9ICk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogRGVjdGl2YXRlcyB0aGUgbGF5ZXIgb2JqZWN0LiBUaGlzIHNob3VsZCBuZXZlciBiZSBjYWxsZWQgbWFudWFsbHkuXHJcblx0ICogQG1lbWJlcm9mIEh0bWxNYXJrZXJMYXllclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0SHRtbE1hcmtlckxheWVyLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZiAoIHRoaXMub2xMYXllciApIHtcclxuXHRcdFx0dGhpcy5vbExheWVyLmNsZWFyTWFya2VycygpO1xyXG5cdFx0XHR0aGlzLm1hcC5vbE1hcC5yZW1vdmVMYXllciggdGhpcy5vbExheWVyICk7XHJcblx0XHRcdHRoaXMub2xMYXllci5kZXN0cm95KCk7XHJcblx0XHRcdHRoaXMub2xMYXllciA9IG51bGw7XHJcblx0XHRcdFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ2RlYWN0aXZhdGUnLCB2YWx1ZTogdHJ1ZSB9ICk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0SHRtbE1hcmtlckxheWVyLnByb3RvdHlwZS5hZGRNYXJrZXIgPSBmdW5jdGlvbiggbWFya2VyICkge1xyXG5cdFx0aWYgKCB0aGlzLm9sTGF5ZXIgKSB7XHJcblx0XHRcdC8vIGFkZCBtYXJrZXJcclxuXHRcdFx0YWRkTWFya2VyVG9MYXllciggdGhpcywgbWFya2VyICk7XHJcblx0XHR9XHJcblx0XHR0aGlzLm1hcmtlcnMucHVzaCggbWFya2VyICk7XHJcblx0fTtcclxuXHJcblx0SHRtbE1hcmtlckxheWVyLnByb3RvdHlwZS5hZGRNYXJrZXJzID0gZnVuY3Rpb24oIG1hcmtlcnMsIGNodW5rU2l6ZSwgcGF1c2UgKSB7XHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblx0XHRpZiAoIGNodW5rU2l6ZSApIHtcclxuXHRcdFx0Ly8gYWRkaW5nIGxhcmdlIHF1YW50aXRpZXMgb2YgbWFya2VycyB0byB0aGUgbWFwIGlzIHNsb3csIHNvXHJcblx0XHRcdC8vIGJyZWFrIGl0IGludG8gYXN5bmMgY2h1bmtzIHRvIGxldCB0aGUgYXBwIGJyZWF0aCBpbiBiZXR3ZWVuXHJcblx0XHRcdF8uY2h1bmsoIG1hcmtlcnMsIGNodW5rU2l6ZSApLmZvckVhY2goIGZ1bmN0aW9uKCBjaHVuaywgaW5kZXggKSB7XHJcblx0XHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRjaHVuay5mb3JFYWNoKCBmdW5jdGlvbiggbWFya2VyICkge1xyXG5cdFx0XHRcdFx0XHR0aGF0LmFkZE1hcmtlciggbWFya2VyICk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9LCBwYXVzZSAqIGluZGV4IHx8IDAgKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtYXJrZXJzLmZvckVhY2goIGZ1bmN0aW9uKCBtYXJrZXIgKSB7XHJcblx0XHRcdFx0dGhhdC5hZGRNYXJrZXIoIG1hcmtlciApO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRIdG1sTWFya2VyTGF5ZXIucHJvdG90eXBlLmRpc2FibGVNYXJrZXJzID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLm1hcmtlcnMuZm9yRWFjaCggZnVuY3Rpb24oIG1hcmtlciApIHtcclxuXHRcdFx0bWFya2VyLmRpc2FibGUoKTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdEh0bWxNYXJrZXJMYXllci5wcm90b3R5cGUucmVtb3ZlTWFya2VyID0gZnVuY3Rpb24oIG1hcmtlciApIHtcclxuXHRcdGlmICggdGhpcy5vbExheWVyICkge1xyXG5cdFx0XHRyZW1vdmVNYXJrZXJGcm9tTGF5ZXIoIG1hcmtlciApO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdEh0bWxNYXJrZXJMYXllci5wcm90b3R5cGUuY2xlYXJNYXJrZXJzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZiAoIHRoaXMub2xMYXllciApIHtcclxuXHRcdFx0dGhpcy5kaXNhYmxlTWFya2VycygpO1xyXG5cdFx0XHR0aGlzLm9sTGF5ZXIuY2xlYXJNYXJrZXJzKCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLm1hcmtlcnMgPSBbXTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoZSB0aGVtZSBhc3NvY2lhdGVkIHdpdGggdGhlIGxheWVyLlxyXG5cdCAqIEBtZW1iZXJvZiBIdG1sTWFya2VyTGF5ZXJcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0aGVtZSAtIFRoZSB0aGVtZSBpZGVudGlmaWVyIHN0cmluZy5cclxuXHQgKi9cclxuXHRIdG1sTWFya2VyTGF5ZXIucHJvdG90eXBlLnNldFRoZW1lID0gZnVuY3Rpb24oIHRoZW1lICkge1xyXG5cdFx0dGhpcy50aGVtZSA9IHRoZW1lO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgeiBpbmRleCBvZiB0aGUgbGF5ZXIuXHJcblx0ICogQG1lbWJlcm9mIEh0bWxNYXJrZXJMYXllclxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtpbnRlZ2VyfSB6SW5kZXggLSBUaGUgbmV3IHotb3JkZXIgdmFsdWUgb2YgdGhlIGxheWVyLCB3aGVyZSAwIGlzIGZyb250LlxyXG5cdCAqL1xyXG5cdEh0bWxNYXJrZXJMYXllci5wcm90b3R5cGUuc2V0WkluZGV4ID0gZnVuY3Rpb24oIHpJbmRleCApIHtcclxuXHRcdC8vIHdlIGJ5LXBhc3MgdGhlIE9wZW5MYXllcnMuTWFwLnNldExheWVySW5kZXgoKSBtZXRob2QgYW5kIG1hbnVhbGx5XHJcblx0XHQvLyBzZXQgdGhlIHotaW5kZXggb2YgdGhlIGxheWVyIGRldi4gc2V0TGF5ZXJJbmRleCBzZXRzIGEgcmVsYXRpdmVcclxuXHRcdC8vIGluZGV4IGJhc2VkIG9uIGN1cnJlbnQgbWFwIGxheWVycywgd2hpY2ggdGhlbiBzZXRzIGEgei1pbmRleC4gVGhpc1xyXG5cdFx0Ly8gY2F1c2VkIGlzc3VlcyB3aXRoIGFzeW5jIGxheWVyIGxvYWRpbmcuXHJcblx0XHR0aGlzLnpJbmRleCA9IHpJbmRleDtcclxuXHRcdGlmICggdGhpcy5vbExheWVyICkge1xyXG5cdFx0XHQkKCB0aGlzLm9sTGF5ZXIuZGl2ICkuY3NzKCAnei1pbmRleCcsIHpJbmRleCApO1xyXG5cdFx0XHRQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHtcclxuXHRcdFx0XHRmaWVsZDogJ3pJbmRleCcsXHJcblx0XHRcdFx0dmFsdWU6IHpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGxheWVycyB6SW5kZXguXHJcblx0ICogQG1lbWJlcm9mIEh0bWxNYXJrZXJMYXllclxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge2ludGVnZXJ9IFRoZSB6SW5kZXggZm9yIHRoZSBsYXllci5cclxuXHQgKi9cclxuXHRIdG1sTWFya2VyTGF5ZXIucHJvdG90eXBlLmdldFpJbmRleCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuekluZGV4O1xyXG5cdH07XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gSHRtbE1hcmtlckxheWVyO1xyXG59KCkpO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBbiBvdmVycmlkZGVuIE9wZW5MYXllcnMuVGlsZSBvYmplY3QgdG8gY3JlYXRlIERPTSBlbGVtZW50cyBiYXNlZCBvblxyXG4gKiB0aWxlIGRhdGEuIFVzZWQgYnkgSHRtbFRpbGVMYXllcnMgZm9yIGNsaWVudCByZW5kZXJlZCBsYXllcnMuIFVzZXNcclxuICogZWl0aGVyIFJlbmRlcmVyIG9iamVjdHMgb3IgaHRtbCBmdW5jdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIERPTSBlbGVtZW50c1xyXG4gKiBvciBodG1sIHN0cmluZ3MuXHJcbiAqL1xyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIE9wZW5MYXllcnMuVGlsZS5IVE1MID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy51cmwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW1nRGl2ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmltYWdlUmVsb2FkQXR0ZW1wdHMgPSBudWxsO1xyXG4gICAgICAgIE9wZW5MYXllcnMuVGlsZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZW5MYXllcnMuVGlsZS5IVE1MLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9wZW5MYXllcnMuVGlsZS5wcm90b3R5cGUgKTtcclxuXHJcbiAgICBPcGVuTGF5ZXJzLlRpbGUuSFRNTC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICggdGhpcy5pbWdEaXYgKSAge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW1nRGl2ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgT3BlbkxheWVycy5UaWxlLnByb3RvdHlwZS5kZXN0cm95LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcclxuICAgIH07XHJcblxyXG4gICAgT3BlbkxheWVycy5UaWxlLkhUTUwucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc2hvdWxkRHJhdyA9IE9wZW5MYXllcnMuVGlsZS5wcm90b3R5cGUuZHJhdy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XHJcbiAgICAgICAgaWYgKCBzaG91bGREcmF3ICkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuaXNMb2FkaW5nICkge1xyXG4gICAgICAgICAgICAgICAgLy9pZiB3ZSdyZSBhbHJlYWR5IGxvYWRpbmcsIHNlbmQgJ3JlbG9hZCcgaW5zdGVhZCBvZiAnbG9hZHN0YXJ0Jy5cclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRFdmVudCA9IFwicmVsb2FkXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkRXZlbnQgPSBcImxvYWRzdGFydFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uVGlsZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIHNob3VsZERyYXcgPT09IGZhbHNlICkge1xyXG4gICAgICAgICAgICB0aGlzLnVubG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2hvdWxkRHJhdztcclxuICAgIH07XHJcblxyXG4gICAgT3BlbkxheWVycy5UaWxlLkhUTUwucHJvdG90eXBlLmdldFVSTCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB1cmwgPSB0aGlzLmxheWVyLmdldFVSTCggdGhpcy5ib3VuZHMgKTtcclxuICAgICAgICBpZiAoIHVybCBpbnN0YW5jZW9mIEFycmF5ICkge1xyXG4gICAgICAgICAgICB1cmwgPSB1cmwuam9pbignfCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfTtcclxuXHJcbiAgICBPcGVuTGF5ZXJzLlRpbGUuSFRNTC5wcm90b3R5cGUucmVuZGVyVGlsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMudXJsID0gdGhpcy5nZXRVUkwoKTtcclxuICAgICAgICB0aGlzLmluaXRJbWFnZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBPcGVuTGF5ZXJzLlRpbGUuSFRNTC5wcm90b3R5cGUucG9zaXRpb25UaWxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5nZXRUaWxlKCkuc3R5bGUsXHJcbiAgICAgICAgICAgIHNpemUgPSB0aGlzLmxheWVyLmdldEltYWdlU2l6ZSggdGhpcy5ib3VuZHMgKSxcclxuICAgICAgICAgICAgcmF0aW8gPSAxO1xyXG4gICAgICAgIGlmICggdGhpcy5sYXllciBpbnN0YW5jZW9mIE9wZW5MYXllcnMuTGF5ZXIuR3JpZCApIHtcclxuICAgICAgICAgICAgcmF0aW8gPSB0aGlzLmxheWVyLmdldFNlcnZlclJlc29sdXRpb24oKSAvIHRoaXMubGF5ZXIubWFwLmdldFJlc29sdXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3R5bGUubGVmdCA9IHRoaXMucG9zaXRpb24ueCArIFwicHhcIjtcclxuICAgICAgICBzdHlsZS50b3AgPSB0aGlzLnBvc2l0aW9uLnkgKyBcInB4XCI7XHJcbiAgICAgICAgc3R5bGUud2lkdGggPSBNYXRoLnJvdW5kKCByYXRpbyAqIHNpemUudyApICsgXCJweFwiO1xyXG4gICAgICAgIHN0eWxlLmhlaWdodCA9IE1hdGgucm91bmQoIHJhdGlvICogc2l6ZS5oICkgKyBcInB4XCI7XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZW5MYXllcnMuVGlsZS5IVE1MLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIE9wZW5MYXllcnMuVGlsZS5wcm90b3R5cGUuY2xlYXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xyXG4gICAgICAgIHZhciBpbWcgPSB0aGlzLmltZ0RpdjtcclxuICAgICAgICBpZiAoIGltZyApIHtcclxuICAgICAgICAgICAgdmFyIHRpbGUgPSB0aGlzLmdldFRpbGUoKTtcclxuICAgICAgICAgICAgaWYgKCB0aWxlLnBhcmVudE5vZGUgPT09IHRoaXMubGF5ZXIuZGl2ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXllci5kaXYucmVtb3ZlQ2hpbGQoIHRpbGUgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNldEltZ1NyYygpO1xyXG4gICAgICAgICAgICBPcGVuTGF5ZXJzLkVsZW1lbnQucmVtb3ZlQ2xhc3MoaW1nLCBcIm9sSW1hZ2VMb2FkRXJyb3JcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBPcGVuTGF5ZXJzLlRpbGUuSFRNTC5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoICF0aGlzLmltZ0RpdiApIHtcclxuICAgICAgICAgICAgdGhpcy5pbWdEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xyXG4gICAgICAgICAgICB0aGlzLmltZ0Rpdi5jbGFzc05hbWUgPSAnb2xUaWxlSHRtbCc7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuaW1nRGl2LnN0eWxlO1xyXG4gICAgICAgICAgICBzdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcclxuICAgICAgICAgICAgc3R5bGUub3BhY2l0eSA9IDA7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5sYXllci5vcGFjaXR5IDwgMSApIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmZpbHRlciA9ICdhbHBoYShvcGFjaXR5PScgKyAodGhpcy5sYXllci5vcGFjaXR5ICogMTAwKSArICcpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1nRGl2O1xyXG4gICAgfTtcclxuXHJcbiAgICBPcGVuTGF5ZXJzLlRpbGUuSFRNTC5wcm90b3R5cGUuc2V0SW1hZ2UgPSBmdW5jdGlvbiggaW1nICkge1xyXG4gICAgICAgIHRoaXMuaW1nRGl2ID0gaW1nO1xyXG4gICAgfTtcclxuXHJcbiAgICBPcGVuTGF5ZXJzLlRpbGUuSFRNTC5wcm90b3R5cGUuaW5pdEltYWdlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCAhdGhpcy51cmwgJiYgIXRoaXMuaW1nRGl2ICkge1xyXG4gICAgICAgICAgICAvLyBmYXN0IHBhdGggb3V0IC0gaWYgdGhlcmUgaXMgbm8gdGlsZSB1cmwgYW5kIG5vIHByZXZpb3VzIGltYWdlXHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlckV2ZW50KCdiZWZvcmVsb2FkJyk7XHJcbiAgICAgICAgdGhpcy5sYXllci5kaXYuYXBwZW5kQ2hpbGQoIHRoaXMuZ2V0VGlsZSgpICk7XHJcbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlckV2ZW50KCB0aGlzLl9sb2FkRXZlbnQgKTtcclxuICAgICAgICB2YXIgaW1nID0gdGhpcy5nZXRJbWFnZSgpO1xyXG4gICAgICAgIHZhciBkYXRhVXJsID0gaW1nLmdldEF0dHJpYnV0ZSgnZGF0YS11cmwnKSB8fCAnJztcclxuICAgICAgICBpZiAoIGRhdGFVcmwgPT09IHRoaXMudXJsICkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KFxyXG4gICAgICAgICAgICAgICAgT3BlbkxheWVycy5GdW5jdGlvbi5iaW5kKCB0aGlzLm9uSW1hZ2VMb2FkLCB0aGlzICksXHJcbiAgICAgICAgICAgICAgICAwICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wTG9hZGluZygpO1xyXG4gICAgICAgICAgICB0aGlzLmltYWdlUmVsb2FkQXR0ZW1wdHMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnNldEltZ1NyYyggdGhpcy51cmwgKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZW5MYXllcnMuVGlsZS5IVE1MLnByb3RvdHlwZS5zZXRJbWdTcmMgPSBmdW5jdGlvbiggdXJsICkge1xyXG4gICAgICAgIHZhciB0aGF0ICA9IHRoaXMsXHJcbiAgICAgICAgICAgIGltZyA9IHRoaXMuaW1nRGl2O1xyXG4gICAgICAgIGlmICggdXJsICkge1xyXG4gICAgICAgICAgICB2YXIgdXJscyA9IHVybC5zcGxpdCgnfCcpO1xyXG4gICAgICAgICAgICBpbWcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICBpbWcuc3R5bGUub3BhY2l0eSA9IDA7XHJcbiAgICAgICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoIFwiZGF0YS11cmxcIiwgdXJsICk7XHJcbiAgICAgICAgICAgIHZhciBwZW5kaW5nUmVxdWVzdHMgPSB1cmxzLm1hcCggZnVuY3Rpb24oIHVybCApIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcclxuICAgICAgICAgICAgICAgICQuYWpheCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcclxuICAgICAgICAgICAgICAgIH0pLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIHJlc3VsdHMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoIHJlc3VsdHMgKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCB4aHIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCB4aHIucmVzcG9uc2VUZXh0ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIHhociApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAkLndoZW4uYXBwbHkoICQsIHBlbmRpbmdSZXF1ZXN0cyApLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHVybCA9PT0gdGhhdC51cmwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub25JbWFnZUxvYWQuYXBwbHkoIHRoYXQsIGFyZ3VtZW50cyApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHVybCA9PT0gdGhhdC51cmwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub25JbWFnZUVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSByZWZlcmVuY2UgdG8gdGhlIGltYWdlLCBhbmQgbGVhdmUgaXQgdG8gdGhlIGJyb3dzZXInc1xyXG4gICAgICAgICAgICAvLyBjYWNoaW5nIGFuZCBnYXJiYWdlIGNvbGxlY3Rpb24uXHJcbiAgICAgICAgICAgIHRoaXMuc3RvcExvYWRpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5pbWdEaXYgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIGltZy5wYXJlbnROb2RlICkge1xyXG4gICAgICAgICAgICAgICAgaW1nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGltZyApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBPcGVuTGF5ZXJzLlRpbGUuSFRNTC5wcm90b3R5cGUuZ2V0VGlsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEltYWdlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZW5MYXllcnMuVGlsZS5IVE1MLnByb3RvdHlwZS5jcmVhdGVCYWNrQnVmZmVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfTtcclxuXHJcbiAgICBPcGVuTGF5ZXJzLlRpbGUuSFRNTC5wcm90b3R5cGUucmVuZGVySHRtbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpbWdEaXYgPSB0aGlzLmltZ0RpdixcclxuICAgICAgICAgICAgdGlsZURhdGEgPSBpbWdEaXYuX3RpbGVEYXRhLFxyXG4gICAgICAgICAgICByZW5kZXJlciA9IHRoaXMuZ2V0UmVuZGVyZXIoKSxcclxuICAgICAgICAgICAgYWdncmVnYXRvcixcclxuICAgICAgICAgICAgaHRtbCxcclxuICAgICAgICAgICAgcmVuZGVyO1xyXG4gICAgICAgIC8vIGNsZWFyIHRpbGUgY29udGVudHNcclxuICAgICAgICBpbWdEaXYuaW5uZXJIVE1MID0gXCJcIjtcclxuICAgICAgICAvLyBoaWRlIHN0YW5kYXJkIHRpbGUgaG92ZXIgaW50ZXJhY3Rpb25cclxuICAgICAgICBpZiAoIHJlbmRlcmVyLnNwZWMuaGlkZVRpbGUgKSB7XHJcbiAgICAgICAgICAgIGltZ0Rpdi5jbGFzc05hbWUgPSBpbWdEaXYuY2xhc3NOYW1lICsgXCIgaGlkZVRpbGVcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCAhdGlsZURhdGEgfHwgdGlsZURhdGEubGVuZ3RoID09PSAwICkge1xyXG4gICAgICAgICAgICAvLyBubyBkYXRhLCBleGl0XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZW5zdXJlIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBzZXQgb2YgZGF0YVxyXG4gICAgICAgIC8vIHRpbGUgZGF0YSBpcyB1bmRlciAndGlsZScsIGVsYXN0aWNzZWFyY2ggaXMgdW5kZXIgJ2hpdHMnXHJcbiAgICAgICAgdmFyIGhhc1RpbGVPckhpdHMgPSBmYWxzZTtcclxuICAgICAgICB0aWxlRGF0YS5mb3JFYWNoKCBmdW5jdGlvbiggZGF0dW0gKSB7XHJcbiAgICAgICAgICAgIGlmICggZGF0dW0udGlsZSB8fCBkYXR1bS5oaXRzICkge1xyXG4gICAgICAgICAgICAgICAgaGFzVGlsZU9ySGl0cyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBubyBjb250ZW50IGluIGRhdGEsIGV4aXRcclxuICAgICAgICBpZiAoICFoYXNUaWxlT3JIaXRzICkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIGFnZ3JlZ2F0b3IsIGFnZ3JlZ2F0ZSB0aGUgZGF0YVxyXG4gICAgICAgIGFnZ3JlZ2F0b3IgPSByZW5kZXJlci5hZ2dyZWdhdG9yO1xyXG4gICAgICAgIGlmICggYWdncmVnYXRvciApIHtcclxuICAgICAgICAgICAgdmFyIG91dE9mUmFuZ2VDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHRpbGVEYXRhLmZvckVhY2goIGZ1bmN0aW9uKCBkYXR1bSApIHtcclxuICAgICAgICAgICAgICAgIGlmICggZGF0dW0udGlsZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGFnZ3JlZ2F0ZSB0aGUgZGF0YSBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIGFnZ3JlZ2F0ZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoICFkYXR1bS50aWxlLm1ldGEuYWdncmVnYXRlZCB8fCBkYXR1bS50aWxlLm1ldGEuYWdncmVnYXRpb25UeXBlICE9PSBhZ2dyZWdhdG9yICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3RGF0YSA9IGRhdHVtLnRpbGUubWV0YS5tYXAgPyBkYXR1bS50aWxlLm1ldGEubWFwLmJpbnMgOiBkYXR1bS50aWxlLm1ldGEucmF3O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXR1bS50aWxlLm1ldGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXc6IHJhd0RhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkOiBhZ2dyZWdhdG9yLmFnZ3JlZ2F0ZSggcmF3RGF0YSApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdHVtLnRpbGUubWV0YS5hZ2dyZWdhdGlvblR5cGUgPSBhZ2dyZWdhdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiByZXF1ZXN0ZWQgcmFuZ2UgaXMgb3V0c2lkZSBvZiBhdmFpbGFibGUgcmFuZ2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdHVtLnRpbGUubWV0YS5hZ2dyZWdhdGVkLmxlbmd0aCA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gZGF0YSwgZmxhZyBhcyBvdXQgb2YgcmFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0T2ZSYW5nZUNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gaWYgYWxsIGRhdGEgaXMgb3V0c2lkZSB0aGUgcmFuZ2UsIGV4aXQgZWFybHlcclxuICAgICAgICAgICAgaWYgKCBvdXRPZlJhbmdlQ291bnQgPT09IHRpbGVEYXRhLmxlbmd0aCApIHtcclxuICAgICAgICAgICAgICAgIC8vIGRhdGEgb3V0c2lkZSBvZiByYW5nZSwgZXhpdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkYXRhID0gdGlsZURhdGEubGVuZ3RoID09PSAxID8gdGlsZURhdGFbMF0gOiB0aWxlRGF0YTtcclxuICAgICAgICAvLyByZW5kZXIgZGF0YVxyXG4gICAgICAgIHJlbmRlciA9IHJlbmRlcmVyLnJlbmRlciggZGF0YSApO1xyXG4gICAgICAgIGh0bWwgPSByZW5kZXIuaHRtbDtcclxuICAgICAgICB0aGlzLmVudHJpZXMgPSByZW5kZXIuZW50cmllcztcclxuICAgICAgICAvLyBhZGQgaHRtbCB0byB0aGUgdGlsZSBkaXZcclxuICAgICAgICBpZiAoIGh0bWwgaW5zdGFuY2VvZiAkICkge1xyXG4gICAgICAgICAgICAvLyBpZiBnZW5lcmF0ZWQgYSBqcXVlcnkgb2JqZWN0LCBhcHBlbmQgaXRcclxuICAgICAgICAgICAgJCggaW1nRGl2ICkuYXBwZW5kKCBodG1sICk7XHJcbiAgICAgICAgfSBlbHNlIGlmICggaHRtbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICkge1xyXG4gICAgICAgICAgICAvLyBpZiBnZW5lcmF0ZWQgYW4gSFRNTEVsZW1lbnQsIGdldCBodG1sIHRleHRcclxuICAgICAgICAgICAgaW1nRGl2LmFwcGVuZENoaWxkKCBodG1sICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gaWYgZ2VuZXJhdGVkIHN0cmluZywgc2V0IGlubmVyIGh0bWxcclxuICAgICAgICAgICAgaW1nRGl2LmlubmVySFRNTCA9IGh0bWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluamVjdCBzZWxlY3RlZCBlbnRyeSBjbGFzc2VzXHJcbiAgICAgICAgcmVuZGVyZXIuaW5qZWN0RW50cmllcyggaW1nRGl2LmNoaWxkcmVuLCB0aGlzLmVudHJpZXMgKTtcclxuICAgICAgICAvLyBjYWxsIHJlbmRlcmVyIGhvb2sgZnVuY3Rpb25cclxuICAgICAgICByZW5kZXJlci5leGVjdXRlSG9va3MoIGltZ0Rpdi5jaGlsZHJlbiwgdGhpcy5lbnRyaWVzLCBkYXRhICk7XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZW5MYXllcnMuVGlsZS5IVE1MLnByb3RvdHlwZS5nZXRSZW5kZXJlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMubGF5ZXIucmVuZGVyZXI7XHJcbiAgICAgICAgaWYgKCB0eXBlb2YgcmVuZGVyZXIgPT09IFwiZnVuY3Rpb25cIiApIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIgPSByZW5kZXJlci5jYWxsKCB0aGlzLmxheWVyLCB0aGlzLmJvdW5kcyApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVuZGVyZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZW5MYXllcnMuVGlsZS5IVE1MLnByb3RvdHlwZS5vbkltYWdlTG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpbWcgPSB0aGlzLmltZ0RpdjtcclxuICAgICAgICB0aGlzLnN0b3BMb2FkaW5nKCk7XHJcbiAgICAgICAgaWYgKCBpbWcgKSB7XHJcbiAgICAgICAgICAgIGltZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2luaGVyaXQnO1xyXG4gICAgICAgICAgICBpbWcuc3R5bGUub3BhY2l0eSA9IHRoaXMubGF5ZXIub3BhY2l0eTtcclxuICAgICAgICAgICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgc2V0IHRoZSBkYXRhIGlmIHRoZXJlIGlzIG5ldyBkYXRhIHRvIHNldFxyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBpO1xyXG4gICAgICAgICAgICAgICAgZm9yICggaT0wOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goIGFyZ3VtZW50c1tpXSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW1nLl90aWxlRGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVuZGVyIHRoZSBkYXRhXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVySHRtbCgpO1xyXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGxvYWQgZW5kXHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXJFdmVudChcImxvYWRlbmRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBPcGVuTGF5ZXJzLlRpbGUuSFRNTC5wcm90b3R5cGUub25JbWFnZUVycm9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGltZyA9IHRoaXMuaW1nRGl2O1xyXG4gICAgICAgIGlmICggaW1nICYmIGltZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtdXJsJykgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VSZWxvYWRBdHRlbXB0cysrO1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuaW1hZ2VSZWxvYWRBdHRlbXB0cyA8PSBPcGVuTGF5ZXJzLklNQUdFX1JFTE9BRF9BVFRFTVBUUyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW1nU3JjKCB0aGlzLmdldFVSTCgpICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBPcGVuTGF5ZXJzLkVsZW1lbnQuYWRkQ2xhc3MoIGltZywgXCJvbEltYWdlTG9hZEVycm9yXCIgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXJFdmVudChcImxvYWRlcnJvclwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25JbWFnZUxvYWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgT3BlbkxheWVycy5UaWxlLkhUTUwucHJvdG90eXBlLnN0b3BMb2FkaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCggdGhpcy5fbG9hZFRpbWVvdXQgKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5fbG9hZFRpbWVvdXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZW5MYXllcnMuVGlsZS5IVE1MLnByb3RvdHlwZS5nZXRDYW52YXNDb250ZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVuTGF5ZXJzIG92ZXJyaWRlc1xyXG4gICAgICovXHJcblxyXG4gICAgaWYgKCBPcGVuTGF5ZXJzLlRpbGVNYW5hZ2VyICkge1xyXG5cclxuICAgICAgICBPcGVuTGF5ZXJzLlRpbGVNYW5hZ2VyLnByb3RvdHlwZS5hZGRUaWxlID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIGlmICggZXZ0LnRpbGUgaW5zdGFuY2VvZiBPcGVuTGF5ZXJzLlRpbGUuSW1hZ2UgfHxcclxuICAgICAgICAgICAgICAgIGV2dC50aWxlIGluc3RhbmNlb2YgT3BlbkxheWVycy5UaWxlLkhUTUwgfHxcclxuICAgICAgICAgICAgICAgIGV2dC50aWxlIGluc3RhbmNlb2YgT3BlbkxheWVycy5UaWxlLlVuaXZhcmlhdGUgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoICFldnQudGlsZS5sYXllci5zaW5nbGVUaWxlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2dC50aWxlLmV2ZW50cy5vbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZWRyYXc6IHRoaXMucXVldWVUaWxlRHJhdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlbG9hZDogdGhpcy5tYW5hZ2VUaWxlQ2FjaGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlbmQ6IHRoaXMuYWRkVG9DYWNoZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5sb2FkOiB0aGlzLnVubG9hZFRpbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMYXllciBoYXMgdGhlIHdyb25nIHRpbGUgdHlwZSwgc28gZG9uJ3QgaGFuZGxlIGl0IGFueSBsb25nZXJcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGF5ZXIoe2xheWVyOiBldnQudGlsZS5sYXllcn0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgT3BlbkxheWVycy5UaWxlTWFuYWdlci5wcm90b3R5cGUucXVldWVUaWxlRHJhdyA9IGZ1bmN0aW9uKCBldnQgKSB7XHJcbiAgICAgICAgICAgIHZhciB0aWxlID0gZXZ0Lm9iamVjdDtcclxuICAgICAgICAgICAgdmFyIHF1ZXVlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aWxlLmxheWVyO1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gdGlsZS5nZXRVUkwgPyB0aWxlLmdldFVSTCgpIDogbGF5ZXIuZ2V0VVJMKCB0aWxlLmJvdW5kcyApO1xyXG4gICAgICAgICAgICB2YXIgaW1nID0gdGhpcy50aWxlQ2FjaGVbdXJsXTtcclxuICAgICAgICAgICAgaWYgKCBpbWcgJiZcclxuICAgICAgICAgICAgICAgICFPcGVuTGF5ZXJzLkVsZW1lbnQuaGFzQ2xhc3MoIGltZywgJ29sVGlsZUltYWdlJyApICYmXHJcbiAgICAgICAgICAgICAgICAhT3BlbkxheWVycy5FbGVtZW50Lmhhc0NsYXNzKCBpbWcsICdvbFRpbGVIdG1sJyApICYmXHJcbiAgICAgICAgICAgICAgICAhT3BlbkxheWVycy5FbGVtZW50Lmhhc0NsYXNzKCBpbWcsICdvbFRpbGVVbml2YXJpYXRlJyApICkge1xyXG4gICAgICAgICAgICAgICAgLy8gY2FjaGVkIGltYWdlIG5vIGxvbmdlciB2YWxpZCwgZS5nLiBiZWNhdXNlIHdlJ3JlIG9sVGlsZVJlcGxhY2luZ1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudGlsZUNhY2hlWyB1cmwgXTtcclxuICAgICAgICAgICAgICAgIE9wZW5MYXllcnMuVXRpbC5yZW1vdmVJdGVtKCB0aGlzLnRpbGVDYWNoZUluZGV4LCB1cmwgKTtcclxuICAgICAgICAgICAgICAgIGltZyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcXVldWUgb25seSBpZiBpbWFnZSB3aXRoIHNhbWUgdXJsIG5vdCBjYWNoZWQgYWxyZWFkeVxyXG4gICAgICAgICAgICBpZiAoIGxheWVyLnVybCAmJiAoIGxheWVyLmFzeW5jIHx8ICFpbWcgKSApIHtcclxuICAgICAgICAgICAgICAgIC8vIGFkZCB0byBxdWV1ZSBvbmx5IGlmIG5vdCBpbiBxdWV1ZSBhbHJlYWR5XHJcbiAgICAgICAgICAgICAgICB2YXIgdGlsZVF1ZXVlID0gdGhpcy50aWxlUXVldWVbIGxheWVyLm1hcC5pZCBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhfk9wZW5MYXllcnMuVXRpbC5pbmRleE9mKCB0aWxlUXVldWUsIHRpbGUgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aWxlUXVldWUucHVzaCh0aWxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHF1ZXVlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICFxdWV1ZWQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgT3BlbkxheWVycy5UaWxlLkltYWdlLnByb3RvdHlwZS5jcmVhdGVCYWNrQnVmZmVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE9wZW5MYXllcnMuVGlsZS5IVE1MO1xyXG59KCkpO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBbiBvdmVycmlkZGVuIE9wZW5MYXllcnMuTGF5ZXIgb2JqZWN0IHRvIHVzZSB0aGUgSHRtbFRpbGUgb2JqZWN0IHRvXHJcbiAqIGNyZWF0ZSBjbGllbnQgcmVuZGVyZWQgZWxlbWVudHMuIFVzZXMgZWl0aGVyIGEgUmVuZGVyZXIgb3IgaHRtbCBmdW5jdGlvblxyXG4gKiB0byBnZW5lcmF0ZSB0aGUgaHRtbC5cclxuICovXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIEh0bWxUaWxlID0gcmVxdWlyZSgnLi9IdG1sVGlsZScpO1xyXG5cclxuICAgIE9wZW5MYXllcnMuTGF5ZXIuSFRNTCA9IGZ1bmN0aW9uKCBuYW1lLCB1cmwsIG9wdGlvbnMgKSB7XHJcbiAgICAgICAgT3BlbkxheWVycy5MYXllci5HcmlkLmNhbGwoIHRoaXMsIG5hbWUsIHVybCwgb3B0aW9ucyApO1xyXG4gICAgICAgIHRoaXMuZ2V0VVJMID0gb3B0aW9ucy5nZXRVUkw7XHJcbiAgICAgICAgdGhpcy5sYXllcm5hbWUgPSBvcHRpb25zLmxheWVybmFtZTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XHJcbiAgICAgICAgdGhpcy50aWxlQ2xhc3MgPSBvcHRpb25zLnRpbGVDbGFzcyB8fCBIdG1sVGlsZTtcclxuICAgICAgICB0aGlzLmh0bWwgPSBvcHRpb25zLmh0bWw7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG9wdGlvbnMucmVuZGVyZXI7XHJcbiAgICAgICAgdGhpcy5DTEFTU19OQU1FID0gJ09wZW5MYXllcnMuTGF5ZXIuSFRNTCc7XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZW5MYXllcnMuTGF5ZXIuSFRNTC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPcGVuTGF5ZXJzLkxheWVyLkdyaWQucHJvdG90eXBlICk7XHJcblxyXG4gICAgT3BlbkxheWVycy5MYXllci5IVE1MLnByb3RvdHlwZS5zZXRPcGFjaXR5ID0gZnVuY3Rpb24oIG9wYWNpdHkgKSB7XHJcbiAgICAgICAgaWYgKCBvcGFjaXR5ICE9PSB0aGlzLm9wYWNpdHkgKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IE1hdGgubWF4KCBNYXRoLm1pbiggb3BhY2l0eSwgMSApLCAwICk7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5kaXYuY2hpbGROb2RlcztcclxuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDAsIGxlbiA9IGNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kgKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzW2ldLnN0eWxlLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCB0aGlzLm1hcCAhPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwLmV2ZW50cy50cmlnZ2VyRXZlbnQoIFwiY2hhbmdlbGF5ZXJcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBcIm9wYWNpdHlcIlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gT3BlbkxheWVycy5MYXllci5IVE1MO1xyXG59KCkpO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cdHZhciBMYXllciA9IHJlcXVpcmUoJy4vTGF5ZXInKSxcclxuXHRcdFB1YlN1YiA9IHJlcXVpcmUoJy4uL3V0aWwvUHViU3ViJyk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlIGEgS01MTGF5ZXIgb2JqZWN0LlxyXG5cdCAqIEBjbGFzcyBLTUxMYXllclxyXG5cdCAqIEBhdWdtZW50cyBMYXllclxyXG5cdCAqIEBjbGFzc2Rlc2MgQSBjbGllbnQgcmVuZGVyZWQgbGF5ZXIgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHNwZWMgLSBUaGUgc3BlY2lmaWNhdGlvbiBvYmplY3QuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gS01MTGF5ZXIoIHNwZWMgKSB7XHJcblx0XHQvLyBjYWxsIGJhc2UgY29uc3RydWN0b3JcclxuXHRcdExheWVyLmNhbGwodGhpcywgc3BlYyk7XHJcblx0XHQvLyBzZXQgcmVhc29uYWJsZSBkZWZhdWx0c1xyXG5cdFx0dGhpcy56SW5kZXggPSAoIHNwZWMuekluZGV4ICE9PSB1bmRlZmluZWQgKSA/IHNwZWMuekluZGV4IDogNzQ5O1xyXG5cdFx0dGhpcy5kb21haW4gPSBcImttbFwiO1xyXG5cdFx0dGhpcy5zb3VyY2UgPSBzcGVjLnNvdXJjZTtcclxuXHRcdHRoaXMuaWQgPSBzcGVjLmlkO1xyXG5cdFx0dGhpcy5rbWwgPSBzcGVjLmttbCB8fCBbXTtcclxuXHR9XHJcblxyXG5cdEtNTExheWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGF5ZXIucHJvdG90eXBlKTtcclxuXHJcblx0LyoqXHJcblx0ICogQWN0aXZhdGVzIHRoZSBsYXllciBvYmplY3QuIFRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCBtYW51YWxseS5cclxuXHQgKiBAbWVtYmVyb2YgS01MTGF5ZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdEtNTExheWVyLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5vbExheWVycyA9IFtdO1xyXG5cclxuXHRcdHRoaXMua21sLmZvckVhY2goIGZ1bmN0aW9uKCBrbWwgKSB7XHJcblx0XHRcdHZhciBwcm9qZWN0aW9uO1xyXG5cdFx0XHR2YXIgdW5pdHMgPSBrbWwudW5pdHM7XHJcblxyXG5cdFx0XHRpZiAodHlwZW9mIHVuaXRzID09PSBcIm9iamVjdFwiKSB7XHJcblx0XHRcdFx0dW5pdHMgPSB1bml0c1trbWwudXJsLnNwbGl0KFwiL1wiKS5wb3AoKV07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN3aXRjaCAoIHVuaXRzICkge1xyXG5cdFx0XHRcdGNhc2UgXCJtZXRlclwiOlxyXG5cdFx0XHRcdGNhc2UgXCJtZXRlcnNcIjpcclxuXHRcdFx0XHRjYXNlIFwibWV0cmVzXCI6XHJcblx0XHRcdFx0Y2FzZSBcIm1ldHJlXCI6XHJcblx0XHRcdFx0Y2FzZSBcIm1cIjpcclxuXHRcdFx0XHRcdHByb2plY3Rpb24gPSBuZXcgT3BlbkxheWVycy5Qcm9qZWN0aW9uKFwiRVBTRzo5MDA5MTNcIik7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFwiZGVncmVlc1wiOlxyXG5cdFx0XHRcdGNhc2UgXCJkZWdyZWVcIjpcclxuXHRcdFx0XHRcdHByb2plY3Rpb24gPSBuZXcgT3BlbkxheWVycy5Qcm9qZWN0aW9uKFwiRVBTRzo0MzI2XCIpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdHByb2plY3Rpb24gPSBuZXcgT3BlbkxheWVycy5Qcm9qZWN0aW9uKFwiRVBTRzo0MzI2XCIpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0a21sLm9sTGF5ZXIgPSBuZXcgT3BlbkxheWVycy5MYXllci5WZWN0b3IoIFwiVmVjdG9yIExheWVyXCIsIHtcclxuXHRcdFx0XHRwcm9qZWN0aW9uOiBwcm9qZWN0aW9uLFxyXG5cdFx0XHRcdHN0cmF0ZWdpZXM6IFtcclxuXHRcdFx0XHRcdG5ldyBPcGVuTGF5ZXJzLlN0cmF0ZWd5LkZpeGVkKClcclxuXHRcdFx0XHRdLFxyXG4gICAgICAgICAgICAgICAgcHJvdG9jb2w6IG5ldyBPcGVuTGF5ZXJzLlByb3RvY29sLkhUVFAoe1xyXG4gICAgICAgICAgICAgICAgICAgIHVybDoga21sLnVybCxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IG5ldyBPcGVuTGF5ZXJzLkZvcm1hdC5LTUwoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0U3R5bGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0QXR0cmlidXRlczogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5vbExheWVycy5wdXNoKCBrbWwub2xMYXllciApO1xyXG5cdFx0fSwgdGhpcyApO1xyXG4gICAgICAgIHRoaXMuc2V0RW5hYmxlZCggdGhpcy5pc0VuYWJsZWQoKSApO1xyXG4gICAgICAgIHRoaXMuc2V0T3BhY2l0eSggdGhpcy5nZXRPcGFjaXR5KCkgKTtcclxuICAgICAgICB0aGlzLnNldEJyaWdodG5lc3MoIHRoaXMuZ2V0QnJpZ2h0bmVzcygpICk7XHJcbiAgICAgICAgdGhpcy5zZXRDb250cmFzdCggdGhpcy5nZXRDb250cmFzdCgpICk7XHJcbiAgICBcdC8vIHB1Ymxpc2ggYWN0aXZhdGUgZXZlbnQgYmVmb3JlIGFwcGVuZGluZyB0byBtYXBcclxuICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICdhY3RpdmF0ZScsIHZhbHVlOiB0cnVlIH0gKTtcclxuXHRcdHRoaXMub2xMYXllcnMuZm9yRWFjaCggZnVuY3Rpb24oIG9sTGF5ZXIgKSB7XHJcblx0XHRcdHRoaXMubWFwLm9sTWFwLmFkZExheWVyKCBvbExheWVyICk7XHJcblx0XHR9LCB0aGlzICk7XHJcblx0XHR0aGlzLnNldFpJbmRleCggdGhpcy56SW5kZXggKTtcclxuICAgICAgICAvLyBwdWJsaXNoIGFkZCBldmVudFxyXG4gICAgICAgIFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ2FkZCcsIHZhbHVlOiB0cnVlIH0gKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBEZWN0aXZhdGVzIHRoZSBsYXllciBvYmplY3QuIFRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCBtYW51YWxseS5cclxuXHQgKiBAbWVtYmVyb2YgS01MTGF5ZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdEtNTExheWVyLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZiAoIHRoaXMub2xMYXllcnMgKSB7XHJcblx0XHRcdHRoaXMub2xMYXllcnMuZm9yRWFjaCggZnVuY3Rpb24oIG9sTGF5ZXIgKSB7XHJcblx0XHRcdFx0dGhpcy5tYXAub2xNYXAucmVtb3ZlTGF5ZXIoIG9sTGF5ZXIgKTtcclxuXHRcdFx0XHRvbExheWVyLmRlc3Ryb3koKTtcclxuXHRcdFx0XHRvbExheWVyID0gbnVsbDtcclxuXHRcdFx0fSwgdGhpcyApO1xyXG4gICAgICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICdyZW1vdmUnLCB2YWx1ZTogdHJ1ZSB9ICk7XHJcblx0XHRcdHRoaXMua21sLmZvckVhY2goIGZ1bmN0aW9uKCBrbWwgKSB7XHJcblx0XHRcdFx0a21sLm9sTGF5ZXIgPSBudWxsO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5vbExheWVycyA9IFtdO1xyXG5cdFx0fVxyXG4gICAgICAgIFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ2RlYWN0aXZhdGUnLCB2YWx1ZTogdHJ1ZSB9ICk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRoZSB6IGluZGV4IG9mIHRoZSBsYXllci5cclxuXHQgKiBAbWVtYmVyb2YgS01MTGF5ZXJcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7aW50ZWdlcn0gekluZGV4IC0gVGhlIG5ldyB6LW9yZGVyIHZhbHVlIG9mIHRoZSBsYXllciwgd2hlcmUgMCBpcyBmcm9udC5cclxuXHQgKi9cclxuXHRLTUxMYXllci5wcm90b3R5cGUuc2V0WkluZGV4ID0gZnVuY3Rpb24oIHpJbmRleCApIHtcclxuXHRcdC8vIHdlIGJ5LXBhc3MgdGhlIE9wZW5MYXllcnMuTWFwLnNldExheWVySW5kZXgoKSBtZXRob2QgYW5kIG1hbnVhbGx5XHJcblx0XHQvLyBzZXQgdGhlIHotaW5kZXggb2YgdGhlIGxheWVyIGRldi4gc2V0TGF5ZXJJbmRleCBzZXRzIGEgcmVsYXRpdmVcclxuXHRcdC8vIGluZGV4IGJhc2VkIG9uIGN1cnJlbnQgbWFwIGxheWVycywgd2hpY2ggdGhlbiBzZXRzIGEgei1pbmRleC4gVGhpc1xyXG5cdFx0Ly8gY2F1c2VkIGlzc3VlcyB3aXRoIGFzeW5jIGxheWVyIGxvYWRpbmcuXHJcblx0XHR0aGlzLnpJbmRleCA9IHpJbmRleDtcclxuXHRcdGlmICggdGhpcy5vbExheWVycyApIHtcclxuXHRcdFx0dGhpcy5vbExheWVycy5mb3JFYWNoKCBmdW5jdGlvbiggb2xMYXllciwgaW5kZXggKSB7XHJcblx0XHRcdFx0JCggb2xMYXllci5kaXYgKS5jc3MoICd6LWluZGV4JywgekluZGV4ICsgKCB0aGlzLm9sTGF5ZXJzLmxlbmd0aCAtIGluZGV4ICkgKTtcclxuXHRcdFx0fSwgdGhpcyApO1xyXG5cdFx0fVxyXG5cdFx0UHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7XHJcblx0XHRcdGZpZWxkOiAnekluZGV4JyxcclxuXHRcdFx0dmFsdWU6IHpJbmRleFxyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBsYXllcnMgekluZGV4LlxyXG5cdCAqIEBtZW1iZXJvZiBLTUxMYXllclxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge2ludGVnZXJ9IFRoZSB6SW5kZXggZm9yIHRoZSBsYXllci5cclxuXHQgKi9cclxuXHRLTUxMYXllci5wcm90b3R5cGUuZ2V0WkluZGV4ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy56SW5kZXg7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0KiBTZXQgdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLlxyXG5cdCogQG1lbWJlcm9mIEtNTExheWVyXHJcblx0KlxyXG5cdCogQHBhcmFtIHtmbG9hdH0gb3BhY2l0eSAtIG9wYWNpdHkgdmFsdWUgZnJvbSAwIHRvIDEuXHJcblx0Ki9cclxuXHRLTUxMYXllci5wcm90b3R5cGUuc2V0T3BhY2l0eSA9IGZ1bmN0aW9uKCBvcGFjaXR5ICkge1xyXG5cdFx0dGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHRcdGlmICggdGhpcy5vbExheWVycyApIHtcclxuXHRcdFx0dGhpcy5vbExheWVycy5mb3JFYWNoKCBmdW5jdGlvbiggb2xMYXllciApIHtcclxuXHRcdFx0XHRvbExheWVyLnNldE9wYWNpdHkoIG9wYWNpdHkgKTtcclxuXHRcdFx0fSwgdGhpcyApO1xyXG5cdFx0fVxyXG5cdFx0UHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnb3BhY2l0eScsIHZhbHVlOiBvcGFjaXR5IH0gKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQqIFNldCB3aGV0aGVyIG9yIG5vdCB0aGUgbGF5ZXIgaXMgZW5hYmxlZC5cclxuXHQqIEBtZW1iZXJvZiBLTUxMYXllclxyXG5cdCpcclxuXHQqIEBwYXJhbSBlbmFibGVkIHtib29sZWFufSB3aGV0aGVyIHRoZSBsYXllciBpcyB2aXNpYmxlIG9yIG5vdFxyXG5cdCovXHJcblx0S01MTGF5ZXIucHJvdG90eXBlLnNldEVuYWJsZWQgPSBmdW5jdGlvbiggZW5hYmxlZCApIHtcclxuXHRcdHRoaXMuZW5hYmxlZCA9IGVuYWJsZWQ7XHJcblx0XHRpZiAoIHRoaXMub2xMYXllcnMgKSB7XHJcblx0XHRcdHRoaXMub2xMYXllcnMuZm9yRWFjaCggZnVuY3Rpb24oIG9sTGF5ZXIgKSB7XHJcblx0XHRcdFx0b2xMYXllci5zZXRWaXNpYmlsaXR5KCBlbmFibGVkICk7XHJcblx0XHRcdH0sIHRoaXMgKTtcclxuXHRcdH1cclxuXHRcdFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ2VuYWJsZWQnLCB2YWx1ZTogZW5hYmxlZCB9ICk7XHJcblx0fTtcclxuXHJcblx0S01MTGF5ZXIucHJvdG90eXBlLnNldFRpbGVUcmFuc2Zvcm1SYW5nZSA9IGZ1bmN0aW9uKCBzdGFydCApIHtcclxuXHRcdHZhciBrbWxEYXRlID0gc3RhcnQ7XHJcblx0XHRpZiAoa21sRGF0ZSA+PSB0aGlzLnNvdXJjZS5tZXRhLm1ldGEucmFuZ2VNYXgpIHtcclxuXHRcdFx0a21sRGF0ZSA9IHRoaXMuc291cmNlLm1ldGEubWV0YS5yYW5nZU1heDtcclxuXHRcdH0gZWxzZSBpZiAoa21sRGF0ZSA8PSB0aGlzLnNvdXJjZS5tZXRhLm1ldGEucmFuZ2VNaW4pIHtcclxuXHRcdFx0a21sRGF0ZSA9IHRoaXMuc291cmNlLm1ldGEubWV0YS5yYW5nZU1pbjtcclxuXHRcdH1cclxuXHRcdGlmICgga21sRGF0ZSAhPT0gdGhpcy5rbWxEYXRlICkge1xyXG5cdFx0XHR0aGlzLmttbERhdGUgPSBrbWxEYXRlO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZUtNTERhdGEoIHRydWUgKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRLTUxMYXllci5wcm90b3R5cGUuc2V0VGlsZVRyYW5zZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcclxuXHRcdC8vIFNldCBrbWwgZGF0YSB0byB0aGUgbW9zdCByZWNlbnRcclxuXHRcdGlmICggdGhpcy5zb3VyY2UubWV0YS5tZXRhLnJhbmdlTWF4ICE9PSB0aGlzLmttbERhdGUgKSB7XHJcblx0XHRcdHRoaXMua21sRGF0ZSA9IHRoaXMuc291cmNlLm1ldGEubWV0YS5yYW5nZU1heDtcclxuXHRcdFx0dGhpcy51cGRhdGVLTUxEYXRhKHRydWUpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG4gICAgS01MTGF5ZXIucHJvdG90eXBlLnVwZGF0ZUtNTERhdGEgPSBmdW5jdGlvbiAodXBkYXRlVmlldykge1xyXG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblx0ICAgIHZhciBkYXRlID0gdGhpcy5rbWxEYXRlO1xyXG5cdCAgICBpZiAodXBkYXRlVmlldykge1xyXG5cdCAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XHJcblx0ICAgIH1cclxuXHQgICAgdGhpcy5rbWwuZm9yRWFjaCggZnVuY3Rpb24oIGttbCwga21sSW5kZXggKSB7XHJcblx0ICAgICAgICBpZiAoa21sLmZpbGVzKSB7XHJcblx0XHQgICAgICAgIC8vIEZpbmQgY2xvc2VzdCBtb250aCBiZWZvcmVcclxuXHRcdCAgICAgICAgdmFyIHNtYWxsZXN0RmlsZSA9IG51bGw7XHJcblx0XHQgICAgICAgIHZhciBtaW5EaWZmO1xyXG5cclxuXHRcdCAgICAgICAga21sLmZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcclxuXHRcdCAgICAgICAgICAgIGlmICghc21hbGxlc3RGaWxlIHx8IE1hdGguYWJzKGZpbGUuZGF0ZSAtIGRhdGUpIDwgbWluRGlmZikge1xyXG5cdFx0ICAgICAgICAgICAgICAgIG1pbkRpZmYgPSBNYXRoLmFicyhmaWxlLmRhdGUgLSBkYXRlKTtcclxuXHRcdCAgICAgICAgICAgICAgICBzbWFsbGVzdEZpbGUgPSBmaWxlO1xyXG5cdFx0ICAgICAgICAgICAgfVxyXG5cdFx0ICAgICAgICB9KTtcclxuXHRcdCAgICAgICAgc2VsZi5uYW1lID0gc2VsZi5zb3VyY2UubmFtZSArIFwiIChcIiArIG1vbWVudChzbWFsbGVzdEZpbGUuZGF0ZSkuZm9ybWF0KFwiTU1NIFlZWVlcIikgKyBcIilcIjtcclxuXHJcblx0XHQgICAgICAgIGlmIChzbWFsbGVzdEZpbGUpIHtcclxuXHRcdCAgICAgICAgICAgIGttbC51cmwgPSBcInJlc3QvbGF5ZXJzL1wiICsgc2VsZi5pZCArIFwiL2ttbC9cIiArIGttbEluZGV4ICsgXCIvXCIgKyBzbWFsbGVzdEZpbGUuZmlsZU5hbWU7XHJcblx0XHQgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSk7XHJcblx0ICAgIGlmICh1cGRhdGVWaWV3KSB7XHJcblx0XHRcdHRoaXMuYWN0aXZhdGUoKTtcclxuXHRcdH1cclxuICAgIH07XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gS01MTGF5ZXI7XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvVXRpbCcpLFxyXG4gICAgICAgIFB1YlN1YiA9IHJlcXVpcmUoJy4uL3V0aWwvUHViU3ViJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW50aWF0ZSBhIExheWVyIG9iamVjdC5cclxuICAgICAqIEBjbGFzcyBMYXllclxyXG4gICAgICogQGNsYXNzZGVzYyBBIExheWVyIGNsYXNzLCB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIGxheWVyIGltcGxlbWVudGF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlYyAtIFRoZSBzcGVjaWZpY2F0aW9uIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTGF5ZXIoIHNwZWMgKSB7XHJcbiAgICAgICAgc3BlYyA9IHNwZWMgfHwge307XHJcbiAgICAgICAgdGhpcy51dWlkID0gVXRpbC5nZW5lcmF0ZVV1aWQoKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBzcGVjLm5hbWUgfHwgXCJVbm5hbWVkIExheWVyXCI7XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSBzcGVjLmRvbWFpbjtcclxuICAgICAgICB0aGlzLm1hcCA9IHNwZWMubWFwO1xyXG4gICAgICAgIHRoaXMuc2hvd1BlbmRpbmdUaWxlcyA9IHNwZWMuc2hvd1BlbmRpbmdUaWxlcyAhPT0gdW5kZWZpbmVkID8gc3BlYy5zaG93UGVuZGluZ1RpbGVzIDogdHJ1ZTtcclxuICAgICAgICB0aGlzLm9wYWNpdHkgPSAoIHNwZWMub3BhY2l0eSAhPT0gdW5kZWZpbmVkICkgPyBzcGVjLm9wYWNpdHkgOiAxLjA7XHJcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzID0gKCBzcGVjLmJyaWdodG5lc3MgIT09IHVuZGVmaW5lZCApID8gc3BlYy5icmlnaHRuZXNzIDogMS4wO1xyXG4gICAgICAgIHRoaXMuY29udHJhc3QgPSAoIHNwZWMuYnJpZ2h0bmVzcyAhPT0gdW5kZWZpbmVkICkgPyBzcGVjLmJyaWdodG5lc3MgOiAxLjA7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gKCBzcGVjLmVuYWJsZWQgIT09IHVuZGVmaW5lZCApID8gc3BlYy5lbmFibGVkIDogdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBMYXllci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIExheWVyLnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtmbG9hdH0gb3BhY2l0eSAtIG9wYWNpdHkgdmFsdWUgZnJvbSAwIHRvIDEuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0T3BhY2l0eTogZnVuY3Rpb24oIG9wYWNpdHkgKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5vbExheWVyICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbExheWVyLnNldE9wYWNpdHkoIG9wYWNpdHkgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICdvcGFjaXR5JywgdmFsdWU6IG9wYWNpdHkgfSApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBMYXllci5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtmbG9hdH0gVGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldE9wYWNpdHk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgYnJpZ2h0bmVzcyBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIExheWVyLnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtmbG9hdH0gYnJpZ2h0bmVzcyAtIG5vcm1hbGl6ZWQgYnJpZ2h0bmVzcyB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRCcmlnaHRuZXNzOiBmdW5jdGlvbiggYnJpZ2h0bmVzcyApIHtcclxuICAgICAgICAgICAgdGhpcy5icmlnaHRuZXNzID0gYnJpZ2h0bmVzcztcclxuICAgICAgICAgICAgaWYgKCB0aGlzLm9sTGF5ZXIgKSB7XHJcbiAgICAgICAgICAgICAgICAkKCB0aGlzLm9sTGF5ZXIuZGl2ICkuY3NzKCAnLXdlYmtpdC1maWx0ZXInLCBcImJyaWdodG5lc3MoXCIrICh0aGlzLmJyaWdodG5lc3MqMTAwKSArXCIlKSBjb250cmFzdChcIisgKHRoaXMuY29udHJhc3QqMTAwKSArXCIlKVwiICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnYnJpZ2h0bmVzcycsIHZhbHVlOiBicmlnaHRuZXNzIH0gKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBsYXllci5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgTGF5ZXIucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7ZmxvYXR9IFRoZSBicmlnaHRuZXNzIG9mIHRoZSBsYXllci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRCcmlnaHRuZXNzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnJpZ2h0bmVzcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIGNvbnRyYXN0IG9mIHRoZSBsYXllci5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgTGF5ZXIucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2Zsb2F0fSBjb250cmFzdCAtIG5vcm1hbGl6ZWQgY29udHJhc3QgdmFsdWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0Q29udHJhc3Q6IGZ1bmN0aW9uKCBjb250cmFzdCApIHtcclxuICAgICAgICAgICAgdGhpcy5jb250cmFzdCA9IGNvbnRyYXN0O1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMub2xMYXllciApIHtcclxuICAgICAgICAgICAgICAgICQoIHRoaXMub2xMYXllci5kaXYgKS5jc3MoICctd2Via2l0LWZpbHRlcicsIFwiYnJpZ2h0bmVzcyhcIisgKHRoaXMuYnJpZ2h0bmVzcyoxMDApICtcIiUpIGNvbnRyYXN0KFwiKyAodGhpcy5jb250cmFzdCoxMDApICtcIiUpXCIgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICdjb250cmFzdCcsIHZhbHVlOiBjb250cmFzdCB9ICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgY29udHJhc3Qgb2YgdGhlIGxheWVyLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBMYXllci5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtmbG9hdH0gVGhlIGNvbnRyYXN0IG9mIHRoZSBsYXllci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRDb250cmFzdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyYXN0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB3aGV0aGVyIG9yIG5vdCB0aGUgbGF5ZXIgaXMgZW5hYmxlZC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgTGF5ZXIucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZW5hYmxlZCB7Ym9vbGVhbn0gd2hldGhlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZSBvciBub3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRFbmFibGVkOiBmdW5jdGlvbiggZW5hYmxlZCApIHtcclxuICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gZW5hYmxlZDtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLm9sTGF5ZXIgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9sTGF5ZXIuc2V0VmlzaWJpbGl0eSggZW5hYmxlZCApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ2VuYWJsZWQnLCB2YWx1ZTogZW5hYmxlZCB9ICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHdoZXRoZXIgb3Igbm90IHRoZSBsYXllciBpcyBlbmFibGVkLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBMYXllci5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBJZiB0aGUgbGF5ZXIgaXMgdmlzaWJsZSBvciBub3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNFbmFibGVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBVVUlEIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGlzIGxheWVyLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBMYXllci5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVVUlEIG9mIHRoZSBsYXllci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRVVUlEOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXVpZDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwdWJsaXNoL3N1YnNjcmliZSBjaGFubmVsIGlkIG9mIHRoaXMgc3BlY2lmaWMgbGF5ZXIuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIExheWVyLnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHB1Ymxpc2gvc3Vic2NyaWJlIGNoYW5uZWwgZm9yIHRoZSBsYXllci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRDaGFubmVsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnbGF5ZXIuJyArIHRoaXMuZG9tYWluICsgJy4nICsgdGhpcy51dWlkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMYXllcjtcclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xyXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cclxuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSBMYXllclV0aWxcclxuICogQGNsYXNzZGVzYyBBIHV0aWxpdHkgbmFtZXNwYWNlIGNvbnRhaW5pbmcgbGF5ZXIgcmVsYXRlZCBmdW5jdGlvbmFsaXR5LlxyXG4gKi9cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBhIG1ldGEgZGF0YSBleHRyZW11bS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBUaGUgcGFyc2VkIGV4dHJlbXVtIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZUV4dHJlbXVtKCBleHRyZW11bSApIHtcclxuICAgICAgICB2YXIgcGFyc2VkO1xyXG4gICAgICAgIGlmICggdHlwZW9mIGV4dHJlbXVtID09PSAnc3RyaW5nJyApIHtcclxuICAgICAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZSggZXh0cmVtdW0gKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCBleHRyZW11bSBpbnN0YW5jZW9mIEFycmF5ICkge1xyXG4gICAgICAgICAgICBpZiAoIGV4dHJlbXVtLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV4dHJlbXVtWzBdID09PSAnc3RyaW5nJyApIHtcclxuICAgICAgICAgICAgICAgIC8vIGdyYXBoIG1ldGEgZGF0YSBlZGdlIGNhc2UsIGdyYXBoIGxheWVyIG1ldGEgZGF0YVxyXG4gICAgICAgICAgICAgICAgLy8gaXMgYSBKU09OIHN0cmluZyB3cmFwcGVkIGluIGFuIGFycmF5XHJcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKCBleHRyZW11bVswXSApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBleHRyZW11bS5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgICAgICAgICBleHRyZW11bVswXS5tYXhpbXVtICE9PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgIGV4dHJlbXVtWzBdLm1pbmltdW0gIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgIC8vIGJ1Y2tldGVkIHRpbGUgZGF0YVxyXG4gICAgICAgICAgICAgICAgcGFyc2VkID0gW107XHJcbiAgICAgICAgICAgICAgICBleHRyZW11bS5mb3JFYWNoKCBmdW5jdGlvbiggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlLm1pbmltdW0gIT09IHVuZGVmaW5lZCA/IHZhbHVlLm1pbmltdW0gOiB2YWx1ZS5tYXhpbXVtO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wdXNoKCByZXN1bHQgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VkID0gW107XHJcbiAgICAgICAgICAgICAgICBleHRyZW11bS5mb3JFYWNoKCBmdW5jdGlvbiggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnB1c2goIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcnNlZCA9IGV4dHJlbXVtO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyc2VkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgYSBnaXZlbiBsYXllcnMgbWV0YSBkYXRhIG1pbiBhbmQgbWF4LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWV0YSB7T2JqZWN0fSB0aGUgbGF5ZXJzIG1ldGEgZGF0YSBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHBhcnNlTWV0YU1pbk1heEpzb24oIG1ldGEgKSB7XHJcbiAgICAgICAgdmFyIG1pbmltdW0sXHJcbiAgICAgICAgICAgIG1heGltdW07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gaWYgbWV0YSB2YWx1ZSBpcyBhIHN0cmluZywgYXNzdW1lIGl0IGlzIHZhbGlkIGpzb25cclxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBuZXcgbWV0YSBkYXRhIGlzIHZhbGlkIGpzb24sIGh1cnJheSFcclxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKCBtZXRhICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCBtZXRhICkge1xyXG4gICAgICAgICAgICAgICAgbWF4aW11bSA9IHBhcnNlRXh0cmVtdW0oIG1ldGEubWF4aW11bSApO1xyXG4gICAgICAgICAgICAgICAgbWluaW11bSA9IHBhcnNlRXh0cmVtdW0oIG1ldGEubWluaW11bSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNvbWV0aW1lcyB0aGUgcGFyc2VkIHZhbHVlIGlzIGFsc28gd3JhcHBlZCBpbiBhbiBhcnJheVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbWF4aW11bTogbWF4aW11bSxcclxuICAgICAgICAgICAgICAgIG1pbmltdW06IG1pbmltdW0sXHJcbiAgICAgICAgICAgICAgICBiaW5zOiBtZXRhLmJpbnNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGNhdGNoICggZSApIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggXCJFcnJvciBvY2N1cmVkIHBhcnNpbmcgbGF5ZXIgbWV0YSBkYXRhLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoIFwiTGF5ZXIgbWV0YSBkYXRhIGZvcm1hdCB1bnJlY29nbml6ZWQuXCIpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWV0YSBkYXRhIG1pbmltdW0gYW5kIG1heGltdW1zIGFyZSBzdG9yZWQgYXMgbWFsZm9ybWVkIGpzb25cclxuICAgICAqIHN0cmluZ3MsIGJ1dCBhcmUgdXN1YWxseSBhY2Nlc3NlZCBhdCBhIGhpZ2ggZnJlcXVlbmN5ICggbXVsdGlwbGVcclxuICAgICAqIHRpbWVzIHBlciB0aWxlIHJlbmRlciApLiBUaGlzIHBhcnNlcyB0aGVtIGFsbCBhbmQgc3RvcmVzIHRoZW1cclxuICAgICAqIGFzIGFjdHVhbCBvYmplY3RzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXJNZXRhIHtPYmplY3R9IHRoZSAubWV0YSBub2RlIG9mIHRoZSBkYXRhIHJldHVybmVkIGZvciBhIGxheWVyXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZpY2UgY2FsbFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZUxldmVsc01pbk1heCggbGF5ZXJNZXRhICkge1xyXG4gICAgICAgIHZhciBtZXRhID0gbGF5ZXJNZXRhLm1ldGEsXHJcbiAgICAgICAgICAgIGtleTtcclxuICAgICAgICBmb3IgKCBrZXkgaW4gbWV0YSApIHtcclxuICAgICAgICAgICAgaWYgKCBtZXRhLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcclxuICAgICAgICAgICAgICAgIGlmICgga2V5ICE9PSBcImJ1Y2tldENvdW50XCIgJiZcclxuICAgICAgICAgICAgICAgICAgICBrZXkgIT09IFwicmFuZ2VNaW5cIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGtleSAhPT0gXCJyYW5nZU1heFwiICYmXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ICE9PSBcInRvcGljVHlwZVwiICYmXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ICE9PSBcInRyYW5zbGF0ZWRUb3BpY3NcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRhWyBrZXkgXSA9IHBhcnNlTWV0YU1pbk1heEpzb24oIG1ldGFba2V5XSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBMYXllclV0aWwgPSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyBhIGxheWVyIG9yIGFuIGFycmF5IG9mIGxheWVyIGRhdGEgb2JqZWN0cywgZm9ybWF0cyBtZXRhIGRhdGFcclxuICAgICAgICAgKiBtaW4gYW5kIG1heCBhbmQgcmV0dXJucyBlaXRoZXIgdGhlIHNpbmdsZSBsYXllciwgb3IgYSBtYXAgb2YgbGF5ZXJzXHJcbiAgICAgICAgICoga2V5ZWQgYnkgbGF5ZXJJZC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgTGF5ZXJVdGlsXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gbGF5ZXJEYXRhIC0gbGF5ZXIgZGF0YSBvYmplY3Qgb3IgYXJyYXkgb2YgbGF5ZXIgZGF0YSBvYmplY3RzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiggbGF5ZXJEYXRhICkge1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXJNYXAsXHJcbiAgICAgICAgICAgICAgICBpO1xyXG4gICAgICAgICAgICBpZiAoICEobGF5ZXJEYXRhIGluc3RhbmNlb2YgQXJyYXkpICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBsYXllckRhdGEubWV0YSApIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZUxldmVsc01pbk1heCggbGF5ZXJEYXRhLm1ldGEgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBsYXllckRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgZ2l2ZW4gYW4gYXJyYXksIGNvbnZlcnQgaXQgaW50byBhIG1hcCBrZXllZCBieSBsYXllcklkXHJcbiAgICAgICAgICAgIGxheWVyTWFwID0ge307XHJcbiAgICAgICAgICAgIGZvciAoIGk9MDsgaTxsYXllckRhdGEubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGxheWVyRGF0YVtpXS5tZXRhICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlTGV2ZWxzTWluTWF4KCBsYXllckRhdGFbaV0ubWV0YSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGF5ZXJNYXBbIGxheWVyRGF0YVtpXS5pZCBdID0gbGF5ZXJEYXRhW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBsYXllck1hcDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHaXZlbiBhbiBPcGVuTGF5ZXJzLkxheWVyIGNsYXNzIGFuZCBhIGJvdW5kcyBvYmplY3QsIHJldHVybiB0aGUgeCxcclxuICAgICAgICAgKiB5LCBhbmQgeSBjb21wb25lbnRzIG9mIHRoZSB0aWxlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtPcGVuTGF5ZXJzLkxheWVyKSBvbExheWVyIC0gVGhlIE9wZW5MYXllcnMgTGF5ZXIgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T3BlbkxheWVycy5Cb3VuZHN9IGJvdW5kcyAtIFRoZSBPcGVuTGF5ZXJzIEJvdW5kcyBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7e3g6IChudW1iZXIpLCB5OiAobnVtYmVyKSwgejogaW50ZWdlcn19IFRoZSB0aWxlIGluZGV4LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFRpbGVJbmRleDogZnVuY3Rpb24oIG9sTGF5ZXIsIGJvdW5kcyApIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IG9sTGF5ZXIubWFwLmdldFJlc29sdXRpb24oKSxcclxuICAgICAgICAgICAgICAgIG1heEJvdW5kcyA9IG9sTGF5ZXIubWF4RXh0ZW50LFxyXG4gICAgICAgICAgICAgICAgdGlsZVNpemUgPSBvbExheWVyLnRpbGVTaXplO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeEluZGV4OiBNYXRoLnJvdW5kKCAoYm91bmRzLmxlZnQgLSBtYXhCb3VuZHMubGVmdCkgLyAocmVzICogdGlsZVNpemUudykgKSxcclxuICAgICAgICAgICAgICAgIHlJbmRleDogTWF0aC5yb3VuZCggKGJvdW5kcy5ib3R0b20gLSBtYXhCb3VuZHMuYm90dG9tKSAvIChyZXMgKiB0aWxlU2l6ZS5oKSApLFxyXG4gICAgICAgICAgICAgICAgbGV2ZWw6IG9sTGF5ZXIubWFwLmdldFpvb20oKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdpdmVuIGFuIE9wZW5MYXllcnMuTGF5ZXIgY2xhc3MgYW5kIGEgT3BlbkxheWVycy5Cb3VuZHMgb2JqZWN0LCByZXR1cm4gdGhlXHJcbiAgICAgICAgICogdGlsZWtleS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7T3BlbkxheWVycy5MYXllcikgb2xMYXllciAtIFRoZSBPcGVuTGF5ZXJzIExheWVyIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge09wZW5MYXllcnMuQm91bmRzfSBib3VuZHMgLSBUaGUgT3BlbkxheWVycyBCb3VuZHMgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHRpbGVrZXkgZnJvbSB0aGUgYm91bmRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFRpbGVrZXk6IGZ1bmN0aW9uKCBvbExheWVyLCBib3VuZHMgKSB7XHJcbiAgICAgICAgICAgIHZhciB0aWxlSW5kZXggPSBMYXllclV0aWwuZ2V0VGlsZUluZGV4KCBvbExheWVyLCBib3VuZHMgKSxcclxuICAgICAgICAgICAgICAgIHggPSB0aWxlSW5kZXgueEluZGV4LFxyXG4gICAgICAgICAgICAgICAgeSA9IHRpbGVJbmRleC55SW5kZXgsXHJcbiAgICAgICAgICAgICAgICB6ID0gdGlsZUluZGV4LmxldmVsO1xyXG4gICAgICAgICAgICByZXR1cm4geiArIFwiLFwiICsgeCArIFwiLFwiICsgeTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZ2V0VVJMIGZ1bmN0aW9uIHBhc3NlZCB0byBhIE9wZW5MYXllcnMgVE1TIC8gR3JpZCBMYXllciB0byBnZW5lcmF0ZSB0aGVcclxuICAgICAgICAgKiB0aWxlIHVybHMuIENhbiBiZSBwYXNzZWQgYXMgaXMsIG9yIGFwcGVuZGVkIGJ5IHVzaW5nICdjYWxsJy4gVGhlICd0aGlzJ1xyXG4gICAgICAgICAqIGNvbnRleHQgaXMgc2V0IHRvIHRoZSBjb250ZXh0IG9mIHRoZSBPcGVuTGF5ZXJzIGxheWVyLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBMYXllclV0aWxcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3VuZHMgLSBUaGUgYm91bmRzIG9iamVjdCBmb3IgdGhlIGN1cnJlbnQgdGlsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRVUkw6IGZ1bmN0aW9uKCBib3VuZHMgKSB7XHJcbiAgICAgICAgICAgIHZhciB0aWxlSW5kZXggPSBMYXllclV0aWwuZ2V0VGlsZUluZGV4KCB0aGlzLCBib3VuZHMgKSxcclxuICAgICAgICAgICAgICAgIHggPSB0aWxlSW5kZXgueEluZGV4LFxyXG4gICAgICAgICAgICAgICAgeSA9IHRpbGVJbmRleC55SW5kZXgsXHJcbiAgICAgICAgICAgICAgICB6ID0gdGlsZUluZGV4LmxldmVsO1xyXG4gICAgICAgICAgICBpZiAoIHggPj0gMCAmJiB5ID49IDAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cmwgKyB0aGlzLmxheWVybmFtZSArIFwiL1wiICsgeiArIFwiL1wiICsgeCArIFwiL1wiICsgeSArIFwiLlwiICsgdGhpcy50eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExheWVyVXRpbDtcclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IMKpIDIwMTMtMjAxNSBVbmNoYXJ0ZWQgU29mdHdhcmUgSW5jLlxyXG4gKlxyXG4gKiBQcm9wZXJ0eSBvZiBVbmNoYXJ0ZWTihKIsIGZvcm1lcmx5IE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3VuY2hhcnRlZC5zb2Z0d2FyZS9cclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xyXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cclxuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBDbGllbnRMYXllciA9IHJlcXVpcmUoJy4vQ2xpZW50TGF5ZXInKSxcclxuICAgICAgICBQdWJTdWIgPSByZXF1aXJlKCcuLi91dGlsL1B1YlN1YicpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFVSTEZ1bmMoIGxheWVycyApIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGJvdW5kcyApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxheWVycy5tYXAoIGZ1bmN0aW9uKCBsYXllciApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsYXllci5vbExheWVyLmdldFVSTCggYm91bmRzICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gTXVsdGlVcmxDbGllbnRMYXllcihzcGVjKSB7XHJcbiAgICAgICAgQ2xpZW50TGF5ZXIuY2FsbCggdGhpcywgc3BlYyApO1xyXG4gICAgICAgIHRoaXMuZ2V0VVJMID0gZ2V0VVJMRnVuYyggc3BlYy5zb3VyY2UubGF5ZXJzICk7XHJcbiAgICB9XHJcblxyXG4gICAgTXVsdGlVcmxDbGllbnRMYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDbGllbnRMYXllci5wcm90b3R5cGUgKTtcclxuXHJcbiAgICAvLyBDREI6IE5vdCB3b3JraW5nIHByb3Blcmx5IHlldC5cclxuICAgIE11bHRpVXJsQ2xpZW50TGF5ZXIucHJvdG90eXBlLnNldExldmVsTWluTWF4ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHpvb21MZXZlbCA9IHRoaXMubWFwLmdldFpvb20oKSxcclxuICAgICAgICAgICAgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xyXG4gICAgICAgIC8vIGFwcGx5IHRoaXMgYWdncmVnYXRvciB0byBjaGlsZCBsYWV5cnNcclxuICAgICAgICB2YXIgbGV2ZWxNaW5NYXggPSB0aGlzLnNvdXJjZS5sYXllcnMubWFwKCBmdW5jdGlvbiggbGF5ZXIgKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBsYXllci5zb3VyY2UsXHJcbiAgICAgICAgICAgICAgICBtZXRhID0gc291cmNlLm1ldGEgJiYgc291cmNlLm1ldGEubWV0YSA/IHNvdXJjZS5tZXRhLm1ldGFbIHpvb21MZXZlbCBdIDogbnVsbCxcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEgPSBsYXllci50aWxlVHJhbnNmb3JtLmRhdGEgfHwge30sXHJcbiAgICAgICAgICAgICAgICBsZXZlbE1pbk1heCA9IG1ldGEsXHJcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkO1xyXG4gICAgICAgICAgICBpZiAoIG1ldGEgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhZ2dyZWdhdGUgdGhlIGRhdGEgaWYgdGhlcmUgaXMgYW4gYWdncmVnYXRvciBhdHRhY2hlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCByZW5kZXJlciAmJiByZW5kZXJlci5hZ2dyZWdhdG9yICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFnZ3JlZ2F0ZSB0aGUgbWV0YSBkYXRhIGJ1Y2tldHNcclxuICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkID0gcmVuZGVyZXIuYWdncmVnYXRvci5hZ2dyZWdhdGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGEuYmlucyB8fCBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5zdGFydEJ1Y2tldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5lbmRCdWNrZXQgKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGFnZ3JlZ2F0ZWQgaW5zdGFuY2VvZiBBcnJheSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFrZSB0aGUgZmlyc3QgYW5kIGxhc3QgaW5kZXgsIHdoaWNoIGNvcnJlc3BvbmQgdG8gbWF4IC8gbWluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsTWluTWF4ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogYWdncmVnYXRlZFthZ2dyZWdhdGVkLmxlbmd0aCAtIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogYWdncmVnYXRlZFswXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsTWluTWF4ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogYWdncmVnYXRlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGFnZ3JlZ2F0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXZlbE1pbk1heCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IG51bGxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGxldmVsTWluTWF4O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMubGV2ZWxNaW5NYXggPSBsZXZlbE1pbk1heDtcclxuICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICdsZXZlbE1pbk1heCcsIHZhbHVlOiBsZXZlbE1pbk1heCB9KTtcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNdWx0aVVybENsaWVudExheWVyO1xyXG59KCkpO1xyXG4iLCIoIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB2YXIgTGF5ZXIgPSByZXF1aXJlKCcuL0xheWVyJyksXHJcbiAgICAgICAgTGF5ZXJVdGlsID0gcmVxdWlyZSgnLi9MYXllclV0aWwnKSxcclxuICAgICAgICBQZW5kaW5nVGlsZSA9IHJlcXVpcmUoJy4vUGVuZGluZ1RpbGUnKSxcclxuICAgICAgICBIdG1sVGlsZUxheWVyID0gcmVxdWlyZSgnLi9IdG1sVGlsZUxheWVyJyksXHJcbiAgICAgICAgUHViU3ViID0gcmVxdWlyZSgnLi4vdXRpbC9QdWJTdWInKSxcclxuICAgICAgICBERUJPVU5DRV9ERUxBWSA9IDQwMCxcclxuICAgICAgICBfYW5pbWF0aW9ucyA9IHt9LFxyXG4gICAgICAgIF9jb3VudHMgPSB7fSxcclxuICAgICAgICBfcHJldlRpbGVrZXlzID0ge307XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0VGlsZUhhc2goIHRpbGUgKSB7XHJcbiAgICAgICAgcmV0dXJuIExheWVyVXRpbC5nZXRUaWxla2V5KCB0aWxlLmxheWVyLCB0aWxlLmJvdW5kcyApLnJlcGxhY2UoIC8sL2csIFwiLVwiICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2xlYXJQZW5kaW5nVGlsZSggdGlsZWtleSApIHtcclxuICAgICAgICBkZWxldGUgX2NvdW50c1sgdGlsZWtleSBdO1xyXG4gICAgICAgIGNsZWFyVGltZW91dCggX2FuaW1hdGlvbnNbIHRpbGVrZXkgXSApO1xyXG4gICAgICAgIF9hbmltYXRpb25zWyB0aWxla2V5IF0gPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgJCggJy5vbFRpbGVQZW5kaW5nXycgKyB0aWxla2V5ICkuY3NzKCdvcGFjaXR5JywgMCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBfYW5pbWF0aW9uc1sgdGlsZWtleSBdO1xyXG4gICAgICAgIH0sIERFQk9VTkNFX0RFTEFZICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmxhZ1BlbmRpbmdUaWxlKCB0aWxla2V5ICkge1xyXG4gICAgICAgIF9jb3VudHNbIHRpbGVrZXkgXSA9IDA7XHJcbiAgICAgICAgaWYgKCBfYW5pbWF0aW9uc1sgdGlsZWtleSBdICkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoIF9hbmltYXRpb25zWyB0aWxla2V5IF0gKTtcclxuICAgICAgICAgICAgZGVsZXRlIF9hbmltYXRpb25zWyB0aWxla2V5IF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgICQoICcub2xUaWxlUGVuZGluZ18nICsgdGlsZWtleSApLmNzcygnb3BhY2l0eScsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluY3JlbWVudFJlcXVlc3RDb3VudCggdGlsZWtleSwgdGlsZUlkICkge1xyXG4gICAgICAgIGlmICggIV9jb3VudHNbIHRpbGVrZXkgXSApIHtcclxuICAgICAgICAgICAgZmxhZ1BlbmRpbmdUaWxlKCB0aWxla2V5ICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9jb3VudHNbIHRpbGVrZXkgXSsrO1xyXG4gICAgICAgIF9wcmV2VGlsZWtleXNbIHRpbGVJZCBdID0gdGlsZWtleTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWNyZW1lbnRSZXF1ZXN0Q291bnQoIHRpbGVrZXksIHRpbGVJZCApIHtcclxuICAgICAgICBpZiAoICFfY291bnRzWyB0aWxla2V5IF0gKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgY2FuIG9jY3VyIGlmIGFuICd1bmxvYWQnIGV2ZW50IG9jY3VycyB3aGlsZSBwZW5kaW5nXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2NvdW50c1sgdGlsZWtleSBdLS07XHJcbiAgICAgICAgaWYgKCBfY291bnRzWyB0aWxla2V5IF0gPT09IDAgKSB7XHJcbiAgICAgICAgICAgIGNsZWFyUGVuZGluZ1RpbGUoIHRpbGVrZXkgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3ByZXZUaWxla2V5c1sgdGlsZUlkIF0gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbG9hZFRpbGUoIG5ld0tleSwgdGlsZUlkICkge1xyXG4gICAgICAgIHZhciBvbGRLZXkgPSBfcHJldlRpbGVrZXlzWyB0aWxlSWQgXTtcclxuICAgICAgICBkZWNyZW1lbnRSZXF1ZXN0Q291bnQoIG9sZEtleSwgdGlsZUlkICk7XHJcbiAgICAgICAgaW5jcmVtZW50UmVxdWVzdENvdW50KCBuZXdLZXksIHRpbGVJZCApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRyYWNrVGlsZXMoIGxheWVyICkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggbWVzc2FnZSApIHtcclxuICAgICAgICAgICAgaWYgKCBsYXllci5vbExheWVyICYmIG1lc3NhZ2UuZmllbGQgPT09IFwiYWN0aXZhdGVcIiApIHtcclxuICAgICAgICAgICAgICAgIGxheWVyLm9sTGF5ZXIuZXZlbnRzLnJlZ2lzdGVyKCAnYWRkdGlsZScsIGxheWVyLm9sTGF5ZXIsIGZ1bmN0aW9uKCBkYXRhICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBsaXN0ZW5lcnMgdG8gdGlsZVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGlsZS5ldmVudHMucmVnaXN0ZXIoICdsb2Fkc3RhcnQnLCBkYXRhLnRpbGUsIGZ1bmN0aW9uKCBhcmcgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudFJlcXVlc3RDb3VudCggZ2V0VGlsZUhhc2goIGFyZy5vYmplY3QgKSwgYXJnLm9iamVjdC5pZCApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGlsZS5ldmVudHMucmVnaXN0ZXIoICdsb2FkZW5kJywgZGF0YS50aWxlLCBmdW5jdGlvbiggYXJnICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRSZXF1ZXN0Q291bnQoIGdldFRpbGVIYXNoKCBhcmcub2JqZWN0ICksIGFyZy5vYmplY3QuaWQgKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnRpbGUuZXZlbnRzLnJlZ2lzdGVyKCAnbG9hZGVycm9yJywgZGF0YS50aWxlLCBmdW5jdGlvbiggYXJnICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRSZXF1ZXN0Q291bnQoIGdldFRpbGVIYXNoKCBhcmcub2JqZWN0ICksIGFyZy5vYmplY3QuaWQgKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnRpbGUuZXZlbnRzLnJlZ2lzdGVyKCAncmVsb2FkJywgZGF0YS50aWxlLCBmdW5jdGlvbiggYXJnICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxvYWRUaWxlKCBnZXRUaWxlSGFzaCggYXJnLm9iamVjdCApLCBhcmcub2JqZWN0LmlkICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50aWxlLmV2ZW50cy5yZWdpc3RlciggJ3VubG9hZCcsIGRhdGEudGlsZSwgZnVuY3Rpb24oIGFyZyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbGVJZCA9IGFyZy5vYmplY3QuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudFJlcXVlc3RDb3VudCggX3ByZXZUaWxla2V5c1sgdGlsZUlkIF0sIHRpbGVJZCApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFBlbmRpbmdMYXllciggc3BlYyApIHtcclxuICAgICAgICBMYXllci5jYWxsKCB0aGlzLCBzcGVjICk7XHJcbiAgICAgICAgdGhpcy56SW5kZXggPSA5OTk5O1xyXG4gICAgICAgIHRoaXMuZG9tYWluID0gXCJwZW5kaW5nXCI7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSB7fTtcclxuICAgICAgICB0aGlzLnRpbGVDbGFzcyA9IFBlbmRpbmdUaWxlO1xyXG4gICAgfVxyXG5cclxuICAgIFBlbmRpbmdMYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMYXllci5wcm90b3R5cGUgKTtcclxuXHJcbiAgICBQZW5kaW5nTGF5ZXIucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gYWRkIHRoZSBuZXcgbGF5ZXJcclxuICAgICAgICB0aGlzLm9sTGF5ZXIgPSBuZXcgSHRtbFRpbGVMYXllcihcclxuICAgICAgICAgICAgJ1BlbmRpbmcgVGlsZSBMYXllcicsXHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnRtcyxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGF5ZXJuYW1lOiB0aGlzLnNvdXJjZS5pZCxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgICAgIG1heEV4dGVudDogbmV3IE9wZW5MYXllcnMuQm91bmRzKFxyXG4gICAgICAgICAgICAgICAgICAgIC0yMDAzNzUwMCwgLTIwMDM3NTAwLFxyXG4gICAgICAgICAgICAgICAgICAgIDIwMDM3NTAwLCAgMjAwMzc1MDApLFxyXG4gICAgICAgICAgICAgICAgaXNCYXNlTGF5ZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgZ2V0VVJMOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgdGlsZUNsYXNzOiB0aGlzLnRpbGVDbGFzc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAvLyBzZXQgd2hldGhlciBpdCBpcyBlbmFibGVkIG9yIG5vdCBiZWZvcmUgYXR0YWNoaW5nLCB0byBwcmV2ZW50XHJcbiAgICAgICAgLy8gbmVlZGxlc3MgdGlsZSByZXFlZXN0c1xyXG4gICAgICAgIHRoaXMuc2V0RW5hYmxlZCggdGhpcy5pc0VuYWJsZWQoKSApO1xyXG4gICAgICAgIC8vIHB1Ymxpc2ggYWN0aXZhdGUgZXZlbnQgYmVmb3JlIGFwcGVuZGluZyB0byBtYXBcclxuICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICdhY3RpdmF0ZScsIHZhbHVlOiB0cnVlIH0gKTtcclxuICAgICAgICAvLyBhdHRhY2ggdG8gbWFwXHJcbiAgICAgICAgdGhpcy5tYXAub2xNYXAuYWRkTGF5ZXIoIHRoaXMub2xMYXllciApO1xyXG4gICAgICAgIC8vIHNldCB6LWluZGV4IGFmdGVyXHJcbiAgICAgICAgdGhpcy5zZXRaSW5kZXgoIHRoaXMuekluZGV4ICk7XHJcbiAgICAgICAgLy8gcHVibGlzaCBhZGQgZXZlbnRcclxuICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICdhZGQnLCB2YWx1ZTogdHJ1ZSB9ICk7XHJcbiAgICB9O1xyXG5cclxuICAgIFBlbmRpbmdMYXllci5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICggdGhpcy5vbExheWVyICkge1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5vbE1hcC5yZW1vdmVMYXllciggdGhpcy5vbExheWVyICk7XHJcbiAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ3JlbW92ZScsIHZhbHVlOiB0cnVlIH0gKTtcclxuICAgICAgICAgICAgdGhpcy5vbExheWVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5vbExheWVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnZGVhY3RpdmF0ZScsIHZhbHVlOiB0cnVlIH0gKTtcclxuICAgIH07XHJcblxyXG4gICAgUGVuZGluZ0xheWVyLnByb3RvdHlwZS5zZXRaSW5kZXggPSBmdW5jdGlvbiAoIHpJbmRleCApIHtcclxuICAgICAgICAvLyB3ZSBieS1wYXNzIHRoZSBPcGVuTGF5ZXJzLk1hcC5zZXRMYXllckluZGV4KCkgbWV0aG9kIGFuZCBtYW51YWxseVxyXG4gICAgICAgIC8vIHNldCB0aGUgei1pbmRleCBvZiB0aGUgbGF5ZXIgZGV2LiBzZXRMYXllckluZGV4IHNldHMgYSByZWxhdGl2ZVxyXG4gICAgICAgIC8vIGluZGV4IGJhc2VkIG9uIGN1cnJlbnQgbWFwIGxheWVycywgd2hpY2ggdGhlbiBzZXRzIGEgei1pbmRleC4gVGhpc1xyXG4gICAgICAgIC8vIGNhdXNlZCBpc3N1ZXMgd2l0aCBhc3luYyBsYXllciBsb2FkaW5nLlxyXG4gICAgICAgIHRoaXMuekluZGV4ID0gekluZGV4O1xyXG4gICAgICAgIGlmICggdGhpcy5vbExheWVyICkge1xyXG4gICAgICAgICAgICAkKCB0aGlzLm9sTGF5ZXIuZGl2ICkuY3NzKCAnei1pbmRleCcsIHpJbmRleCApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICd6SW5kZXgnLCB2YWx1ZTogekluZGV4IH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBQZW5kaW5nTGF5ZXIucHJvdG90eXBlLmdldFpJbmRleCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy56SW5kZXg7XHJcbiAgICB9O1xyXG5cclxuICAgIFBlbmRpbmdMYXllci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiggbGF5ZXIgKSB7XHJcbiAgICAgICAgbGF5ZXIucGVuZGluZ0Z1bmMgPSB0cmFja1RpbGVzKCBsYXllciApO1xyXG4gICAgICAgIFB1YlN1Yi5zdWJzY3JpYmUoIGxheWVyLmdldENoYW5uZWwoKSwgbGF5ZXIucGVuZGluZ0Z1bmMgKTtcclxuICAgIH07XHJcblxyXG4gICAgUGVuZGluZ0xheWVyLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24oIGxheWVyICkge1xyXG4gICAgICAgIFB1YlN1Yi51bnN1YnNjcmliZSggbGF5ZXIuZ2V0Q2hhbm5lbCgpLCBsYXllci5wZW5kaW5nRnVuYyApO1xyXG4gICAgICAgIGRlbGV0ZSBsYXllci5wZW5kaW5nRnVuYztcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQZW5kaW5nTGF5ZXI7XHJcblxyXG59KCkpO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4vKipcclxuICogQW4gb3ZlcnJpZGRlbiBPcGVuTGF5ZXJzLlRpbGUgb2JqZWN0IHRvIGNyZWF0ZSBET00gZWxlbWVudHMgYmFzZWQgb25cclxuICogdGlsZSBkYXRhLiBVc2VkIGJ5IEh0bWxUaWxlTGF5ZXJzIGZvciBjbGllbnQgcmVuZGVyZWQgbGF5ZXJzLiBVc2VzXHJcbiAqIGVpdGhlciBSZW5kZXJlciBvYmplY3RzIG9yIGh0bWwgZnVuY3Rpb25zIHRvIGdlbmVyYXRlIHRoZSBET00gZWxlbWVudHNcclxuICogb3IgaHRtbCBzdHJpbmdzLlxyXG4gKi9cclxuXHJcbiAoIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBMYXllclV0aWwgPSByZXF1aXJlKCcuL0xheWVyVXRpbCcpO1xyXG5cclxuICAgIGZ1bmN0aW9uIFBlbmRpbmdUaWxlKCkge1xyXG4gICAgICAgIE9wZW5MYXllcnMuVGlsZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XHJcbiAgICB9XHJcblxyXG4gICAgUGVuZGluZ1RpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT3BlbkxheWVycy5UaWxlLkhUTUwucHJvdG90eXBlICk7XHJcblxyXG4gICAgUGVuZGluZ1RpbGUucHJvdG90eXBlLmdldFVSTCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBMYXllclV0aWwuZ2V0VGlsZWtleSggdGhpcy5sYXllciwgdGhpcy5ib3VuZHMgKS5yZXBsYWNlKCAvLC9nLCBcIi1cIiApO1xyXG4gICAgfTtcclxuXHJcbiAgICBQZW5kaW5nVGlsZS5wcm90b3R5cGUuc2V0SW1nU3JjID0gZnVuY3Rpb24oIHVybCApIHtcclxuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzLFxyXG4gICAgICAgICAgICBpbWcgPSB0aGlzLmltZ0RpdjtcclxuICAgICAgICBpZiAoIHVybCApIHtcclxuICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSggXCJkYXRhLXVybFwiLCB1cmwgKTtcclxuICAgICAgICAgICAgdGhhdC5vbkltYWdlTG9hZC5hcHBseSggdGhhdCApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcExvYWRpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5pbWdEaXYgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIGltZy5wYXJlbnROb2RlICkge1xyXG4gICAgICAgICAgICAgICAgaW1nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGltZyApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBQZW5kaW5nVGlsZS5wcm90b3R5cGUub25JbWFnZUxvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaW1nID0gdGhpcy5pbWdEaXY7XHJcbiAgICAgICAgdGhpcy5zdG9wTG9hZGluZygpO1xyXG4gICAgICAgIGlmICggaW1nICkge1xyXG4gICAgICAgICAgICAvLyByZW5kZXIgdGhlIGRhdGFcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIdG1sKCk7XHJcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgbG9hZCBlbmRcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlckV2ZW50KFwibG9hZGVuZFwiKTtcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFBlbmRpbmdUaWxlLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICggIXRoaXMuaW1nRGl2ICkge1xyXG4gICAgICAgICAgICB0aGlzLmltZ0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XHJcbiAgICAgICAgICAgIHRoaXMuaW1nRGl2LmNsYXNzTmFtZSA9ICdvbFRpbGVIdG1sIG9sVGlsZVBlbmRpbmcnO1xyXG4gICAgICAgICAgICB0aGlzLmltZ0Rpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1nRGl2O1xyXG4gICAgfTtcclxuXHJcbiAgICBQZW5kaW5nVGlsZS5wcm90b3R5cGUucmVuZGVySHRtbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpbWdEaXYgPSB0aGlzLmltZ0RpdixcclxuICAgICAgICAgICAgdXJsID0gaW1nRGl2LmdldEF0dHJpYnV0ZSggXCJkYXRhLXVybFwiLCB1cmwgKTtcclxuICAgICAgICAvLyBjbGVhciB0aWxlIGNvbnRlbnRzXHJcbiAgICAgICAgaW1nRGl2LmNsYXNzTmFtZSA9ICdvbFRpbGVIdG1sIG9sVGlsZVBlbmRpbmcgb2xUaWxlUGVuZGluZ18nICsgdXJsO1xyXG4gICAgICAgIGltZ0Rpdi5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImNzc2xvYWQtbG9hZGVyXCI+JyArXHJcbiAgICAgICAgXHQnPHVsPicgK1xyXG4gICAgICAgIFx0XHQnPGxpPjwvbGk+JyArXHJcbiAgICAgICAgXHRcdCc8bGk+PC9saT4nICtcclxuICAgICAgICBcdFx0JzxsaT48L2xpPicgK1xyXG4gICAgICAgIFx0XHQnPGxpPjwvbGk+JyArXHJcbiAgICAgICAgXHRcdCc8bGk+PC9saT4nICtcclxuICAgICAgICBcdFx0JzxsaT48L2xpPicgK1xyXG4gICAgICAgIFx0JzwvdWw+JyArXHJcbiAgICAgICAgJzwvZGl2Pic7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUGVuZGluZ1RpbGU7XHJcblxyXG59KCkpO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKSxcclxuICAgICAgICBMYXllciA9IHJlcXVpcmUoJy4vTGF5ZXInKSxcclxuICAgICAgICBMYXllclV0aWwgPSByZXF1aXJlKCcuL0xheWVyVXRpbCcpLFxyXG4gICAgICAgIFB1YlN1YiA9IHJlcXVpcmUoJy4uL3V0aWwvUHViU3ViJyksXHJcbiAgICAgICAgTGVnZW5kU2VydmljZSA9IHJlcXVpcmUoJy4uL3Jlc3QvTGVnZW5kU2VydmljZScpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZTogUmVxdWVzdCBjb2xvdXIgcmFtcCBpbWFnZSBmcm9tIHNlcnZlciBhbmQgc2V0IGxheWVyIHByb3BlcnR5IHdoZW4gcmVjZWl2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxheWVyIC0gVGhlIGxheWVyIG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0UmFtcEltYWdlVXJsKCBsYXllciwgY2FsbGJhY2sgKSB7XHJcbiAgICAgICAgTGVnZW5kU2VydmljZS5nZXRFbmNvZGVkSW1hZ2UoIGxheWVyLnNvdXJjZS5pZCwge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IGxheWVyLnJlbmRlcmVyXHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICggdXJsICkge1xyXG4gICAgICAgICAgICAgICAgbGF5ZXIucmFtcEltYWdlVXJsID0gdXJsO1xyXG4gICAgICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goIGxheWVyLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ3JhbXBJbWFnZVVybCcsIHZhbHVlOiB1cmwgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGNhbGxiYWNrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCB1cmwgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcml2YXRlOiBTZXRzIHRoZSBsYXllcnMgbWluIGFuZCBtYXggdmFsdWVzIGZvciB0aGUgZ2l2ZW4gem9vbSBsZXZlbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIge09iamVjdH0gdGhlIGxheWVyIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0TGV2ZWxNaW5NYXgoIGxheWVyICkge1xyXG4gICAgICAgIHZhciB6b29tTGV2ZWwgPSBsYXllci5tYXAuZ2V0Wm9vbSgpLFxyXG4gICAgICAgICAgICBjb2Fyc2VuZXNzID0gbGF5ZXIucmVuZGVyZXIuY29hcnNlbmVzcyxcclxuICAgICAgICAgICAgYWRqdXN0ZWRab29tID0gTWF0aC5tYXgoIHpvb21MZXZlbCAtICggY29hcnNlbmVzcy0xICksIDAgKSxcclxuICAgICAgICAgICAgbWV0YSA9ICBsYXllci5zb3VyY2UubWV0YSxcclxuICAgICAgICAgICAgbGV2ZWxNaW5NYXggPSBtZXRhLm1ldGFbIGFkanVzdGVkWm9vbSBdLFxyXG4gICAgICAgICAgICBtaW5NYXggPSBsZXZlbE1pbk1heCA/IGxldmVsTWluTWF4IDoge1xyXG4gICAgICAgICAgICAgICAgbWluaW11bTogbnVsbCxcclxuICAgICAgICAgICAgICAgIG1heGltdW06IG51bGxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBsYXllci5sZXZlbE1pbk1heCA9IG1pbk1heDtcclxuICAgICAgICBQdWJTdWIucHVibGlzaCggbGF5ZXIuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnbGV2ZWxNaW5NYXgnLCB2YWx1ZTogbWluTWF4IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZTogUmV0dXJucyB0aGUgem9vbSBjYWxsYmFjayBmdW5jdGlvbiB0byB1cGRhdGUgbGV2ZWwgbWluIGFuZCBtYXhlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIge1NlcnZlckxheWVyfSBUaGUgbGF5ZXIgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB6b29tQ2FsbGJhY2soIGxheWVyICkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCBsYXllci5vbExheWVyICkge1xyXG4gICAgICAgICAgICAgICAgc2V0TGV2ZWxNaW5NYXgoIGxheWVyICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGUgYSBTZXJ2ZXJMYXllciBvYmplY3QuXHJcbiAgICAgKiBAY2xhc3MgU2VydmVyTGF5ZXJcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBzZXJ2ZXIgcmVuZGVyZWQgaW1hZ2UgbGF5ZXIgdGhhdCBkaXNwbGF5cyBpbWFnZXMgcmV0cmlldmVkIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAqICAgICAgICAgICAgUmVzcGVjdGl2ZSBzZXJ2ZXIgc2lkZSByZW5kZXJpbmcgcGFyYW1ldGVycyBtYXkgYmUgbW9kaWZpZWQgdXNpbmcgdGhlIGludGVyZmFjZVxyXG4gICAgICogICAgICAgICAgICBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzcGVjIHtPYmplY3R9IFRoZSBTcGVjaWZpY2F0aW9uIG9iamVjdC5cclxuICAgICAqIDxwcmU+XHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgb3BhY2l0eSB7ZmxvYXR9ICAgLSBUaGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIuIERlZmF1bHQgPSAxLjAuXHJcbiAgICAgKiAgICAgZW5hYmxlZCB7Ym9vbGVhbn0gLSBXaGV0aGVyIHRoZSBsYXllciBpcyB2aXNpYmxlIG9yIG5vdC4gRGVmYXVsdCA9IHRydWUuXHJcbiAgICAgKiAgICAgekluZGV4ICB7aW50ZWdlcn0gLSBUaGUgeiBpbmRleCBvZiB0aGUgbGF5ZXIuIERlZmF1bHQgPSAxLlxyXG4gICAgICogICAgIHJlbmRlcmVyOiB7XHJcbiAgICAgKiAgICAgICAgIGNvYXJzZW5lc3Mge2ludGVnZXJ9IC0gVGhlIHBpeGVsIGJ5IHBpeGVsIGNvYXJzZW5lc3MuIERlZmF1bHQgYmFzZWQgb24gc2VydmVyIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgKiAgICAgICAgIHJhbXAgICAgICAge1N0cmluZ30gIC0gVGhlIGNvbG9yIHJhbXAgdHlwZS4gRGVmYXVsdCBiYXNlZCBvbiBzZXJ2ZXIgY29uZmlndXJhdGlvbi5cclxuICAgICAqICAgICAgICAgcmFuZ2VNaW4gICB7aW50ZWdlcn0gLSBUaGUgbWluaW11bSBwZXJjZW50YWdlIHRvIGNsYW1wIHRoZSBsb3cgZW5kIG9mIHRoZSBjb2xvciByYW1wLiBEZWZhdWx0IGJhc2VkIG9uIHNlcnZlciBjb25maWd1cmF0aW9uLlxyXG4gICAgICogICAgICAgICByYW5nZU1heCAgIHtpbnRlZ2VyfSAtIFRoZSBtYXhpbXVtIHBlcmNlbnRhZ2UgdG8gY2xhbXAgdGhlIGhpZ2ggZW5kIG9mIHRoZSBjb2xvciByYW1wLiBEZWZhdWx0IGJhc2VkIG9uIHNlcnZlciBjb25maWd1cmF0aW9uLlxyXG4gICAgICogICAgIH0sXHJcbiAgICAgKiAgICAgdmFsdWVUcmFuc2Zvcm06IHtcclxuICAgICAqICAgICAgICAgdHlwZSB7U3RyaW5nfSAtIFZhbHVlIHRyYW5zZm9ybWVyIHR5cGUuIERlZmF1bHQgYmFzZWQgb24gc2VydmVyIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgKiAgICAgfSxcclxuICAgICAqICAgICB0aWxlVHJhbnNmb3JtOiB7XHJcbiAgICAgKiAgICAgICAgIHR5cGUge1N0cmluZ30gLSBUaWxlIHRyYW5zZm9ybWVyIHR5cGUuIERlZmF1bHQgYmFzZWQgb24gc2VydmVyIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgKiAgICAgICAgIGRhdGEge09iamVjdH0gLSBUaGUgdGlsZSB0cmFuc2Zvcm1lciBkYXRhIGluaXRpYWxpemF0aW9uIG9iamVjdC4gRGVmYXVsdCBiYXNlZCBvbiBzZXJ2ZXIgY29uZmlndXJhdGlvbi5cclxuICAgICAqICAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gU2VydmVyTGF5ZXIoIHNwZWMgKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgICAgICBnZXRVUkwgPSBzcGVjLmdldFVSTCB8fCBMYXllclV0aWwuZ2V0VVJMO1xyXG4gICAgICAgIC8vIGNhbGwgYmFzZSBjb25zdHJ1Y3RvclxyXG4gICAgICAgIExheWVyLmNhbGwoIHRoaXMsIHNwZWMgKTtcclxuICAgICAgICAvLyBzZXQgcmVhc29uYWJsZSBkZWZhdWx0c1xyXG4gICAgICAgIHRoaXMuekluZGV4ID0gKCBzcGVjLnpJbmRleCAhPT0gdW5kZWZpbmVkICkgPyBwYXJzZUludCggc3BlYy56SW5kZXgsIDEwICkgOiAxO1xyXG4gICAgICAgIHNwZWMucmVuZGVyZXIgPSBzcGVjLnJlbmRlcmVyIHx8IHt9O1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBzcGVjLnJlbmRlcmVyO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuY29hcnNlbmVzcyA9ICggc3BlYy5yZW5kZXJlci5jb2Fyc2VuZXNzICE9PSB1bmRlZmluZWQgKSA/IHBhcnNlSW50KCBzcGVjLnJlbmRlcmVyLmNvYXJzZW5lc3MsIDEwICkgOiAxO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIucmFuZ2VNaW4gPSAoIHNwZWMucmVuZGVyZXIucmFuZ2VNaW4gIT09IHVuZGVmaW5lZCApID8gcGFyc2VJbnQoIHNwZWMucmVuZGVyZXIucmFuZ2VNaW4sIDEwICkgOiAwO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIucmFuZ2VNYXggPSAoIHNwZWMucmVuZGVyZXIucmFuZ2VNYXggIT09IHVuZGVmaW5lZCApID8gcGFyc2VJbnQoIHNwZWMucmVuZGVyZXIucmFuZ2VNYXgsIDEwICkgOiAxMDA7XHJcbiAgICAgICAgdGhpcy52YWx1ZVRyYW5zZm9ybSA9IHNwZWMudmFsdWVUcmFuc2Zvcm0gfHwge307XHJcbiAgICAgICAgdGhpcy50aWxlVHJhbnNmb3JtID0gc3BlYy50aWxlVHJhbnNmb3JtIHx8IHt9O1xyXG4gICAgICAgIHRoaXMuZG9tYWluID0gXCJzZXJ2ZXJcIjtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNwZWMuc291cmNlO1xyXG4gICAgICAgIHRoaXMuZ2V0VVJMID0gZnVuY3Rpb24oIGJvdW5kcyApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldFVSTC5jYWxsKCB0aGlzLCBib3VuZHMgKSArIHRoYXQuZ2V0UXVlcnlQYXJhbVN0cmluZygpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgU2VydmVyTGF5ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGF5ZXIucHJvdG90eXBlICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIGxheWVyIG9iamVjdC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG4gICAgICogQG1lbWJlcm9mIFNlcnZlckxheWVyXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBTZXJ2ZXJMYXllci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBzZXQgY2FsbGJhY2sgaGVyZSBzbyBpdCBjYW4gYmUgcmVtb3ZlZCBsYXRlclxyXG4gICAgICAgIHRoaXMuem9vbUNhbGxiYWNrID0gem9vbUNhbGxiYWNrKCB0aGlzICk7XHJcbiAgICAgICAgLy8gc2V0IGNhbGxiYWNrIHRvIHVwZGF0ZSByYW1wIG1pbi9tYXggb24gem9vbVxyXG4gICAgICAgIHRoaXMubWFwLm9uKCBcInpvb21lbmRcIiwgdGhpcy56b29tQ2FsbGJhY2sgKTtcclxuICAgICAgICAvLyBhZGQgdGhlIG5ldyBsYXllclxyXG4gICAgICAgIHRoaXMub2xMYXllciA9IG5ldyBPcGVuTGF5ZXJzLkxheWVyLlRNUyhcclxuICAgICAgICAgICAgJ1NlcnZlciBSZW5kZXJlZCBUaWxlIExheWVyJyxcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2UudG1zLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsYXllcm5hbWU6IHRoaXMuc291cmNlLmlkLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3BuZycsXHJcbiAgICAgICAgICAgICAgICBtYXhFeHRlbnQ6IG5ldyBPcGVuTGF5ZXJzLkJvdW5kcygtMjAwMzc1MDAsIC0yMDAzNzUwMCxcclxuICAgICAgICAgICAgICAgICAgICAyMDAzNzUwMCwgIDIwMDM3NTAwKSxcclxuICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaXNCYXNlTGF5ZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgZ2V0VVJMOiB0aGlzLmdldFVSTFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAvLyBzZXQgd2hldGhlciBpdCBpcyBlbmFibGVkIG9yIG5vdCBiZWZvcmUgYXR0YWNoaW5nLCB0byBwcmV2ZW50XHJcbiAgICAgICAgLy8gbmVlZGxlc3MgdGlsZSByZXF1ZXN0c1xyXG4gICAgICAgIHRoaXMuc2V0RW5hYmxlZCggdGhpcy5pc0VuYWJsZWQoKSApO1xyXG4gICAgICAgIHRoaXMuc2V0VGhlbWUoIHRoaXMubWFwLmdldFRoZW1lKCkgKTsgIC8vIHNlbmRzIGluaXRpYWwgcmVxdWVzdCBmb3IgcmFtcCBpbWFnZVxyXG4gICAgICAgIHRoaXMuc2V0T3BhY2l0eSggdGhpcy5nZXRPcGFjaXR5KCkgKTtcclxuICAgICAgICB0aGlzLnNldEJyaWdodG5lc3MoIHRoaXMuZ2V0QnJpZ2h0bmVzcygpICk7XHJcbiAgICAgICAgdGhpcy5zZXRDb250cmFzdCggdGhpcy5nZXRDb250cmFzdCgpICk7XHJcbiAgICAgICAgLy8gcHVibGlzaCBhY3RpdmF0ZSBldmVudCBiZWZvcmUgYXBwZW5kaW5nIHRvIG1hcFxyXG4gICAgICAgIFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ2FjdGl2YXRlJywgdmFsdWU6IHRydWUgfSApO1xyXG4gICAgICAgIC8vIGF0dGFjaCB0byBtYXBcclxuICAgICAgICB0aGlzLm1hcC5vbE1hcC5hZGRMYXllciggdGhpcy5vbExheWVyICk7XHJcbiAgICAgICAgLy8gc2V0IHotaW5kZXggYWZ0ZXJcclxuICAgICAgICB0aGlzLnNldFpJbmRleCggdGhpcy56SW5kZXggKTtcclxuICAgICAgICAvLyBwdWJsaXNoIGFkZCBldmVudFxyXG4gICAgICAgIFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ2FkZCcsIHZhbHVlOiB0cnVlIH0gKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWN0aXZhdGVzIHRoZSBsYXllciBvYmplY3QuIFRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCBtYW51YWxseS5cclxuICAgICAqIEBtZW1iZXJvZiBTZXJ2ZXJMYXllclxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgU2VydmVyTGF5ZXIucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIHRoaXMub2xMYXllciApIHtcclxuICAgICAgICAgICAgdGhpcy5tYXAub2xNYXAucmVtb3ZlTGF5ZXIoIHRoaXMub2xMYXllciApO1xyXG4gICAgICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICdyZW1vdmUnLCB2YWx1ZTogdHJ1ZSB9ICk7XHJcbiAgICAgICAgICAgIHRoaXMub2xMYXllci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMub2xMYXllciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFwLm9mZiggXCJ6b29tZW5kXCIsIHRoaXMuem9vbUNhbGxiYWNrICk7XHJcbiAgICAgICAgdGhpcy56b29tQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ2RlYWN0aXZhdGUnLCB2YWx1ZTogdHJ1ZSB9ICk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgdGhlbWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBsYXllci5cclxuICAgICAqIEBtZW1iZXJvZiBTZXJ2ZXJMYXllclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0aGVtZSAtIFRoZSB0aGVtZSBpZGVudGlmaWVyIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgU2VydmVyTGF5ZXIucHJvdG90eXBlLnNldFRoZW1lID0gZnVuY3Rpb24oIHRoZW1lICkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnRoZW1lID0gdGhlbWU7XHJcbiAgICAgICAgc2V0UmFtcEltYWdlVXJsKCB0aGF0ICk7XHJcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdGhlbWUgZm9yIHRoZSBsYXllci5cclxuICAgICAqIEBtZW1iZXJvZiBTZXJ2ZXJMYXllclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0aGVtZSBpZGVudGlmaWVyIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgU2VydmVyTGF5ZXIucHJvdG90eXBlLmdldFRoZW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIudGhlbWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB6IGluZGV4IG9mIHRoZSBsYXllci5cclxuICAgICAqIEBtZW1iZXJvZiBTZXJ2ZXJMYXllclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gekluZGV4IC0gVGhlIG5ldyB6LW9yZGVyIHZhbHVlIG9mIHRoZSBsYXllciwgd2hlcmUgMCBpcyBmcm9udC5cclxuICAgICAqL1xyXG4gICAgU2VydmVyTGF5ZXIucHJvdG90eXBlLnNldFpJbmRleCA9IGZ1bmN0aW9uICggekluZGV4ICkge1xyXG4gICAgICAgIC8vIHdlIGJ5LXBhc3MgdGhlIE9wZW5MYXllcnMuTWFwLnNldExheWVySW5kZXgoKSBtZXRob2QgYW5kIG1hbnVhbGx5XHJcbiAgICAgICAgLy8gc2V0IHRoZSB6LWluZGV4IG9mIHRoZSBsYXllciBkZXYuIHNldExheWVySW5kZXggc2V0cyBhIHJlbGF0aXZlXHJcbiAgICAgICAgLy8gaW5kZXggYmFzZWQgb24gY3VycmVudCBtYXAgbGF5ZXJzLCB3aGljaCB0aGVuIHNldHMgYSB6LWluZGV4LiBUaGlzXHJcbiAgICAgICAgLy8gY2F1c2VkIGlzc3VlcyB3aXRoIGFzeW5jIGxheWVyIGxvYWRpbmcuXHJcbiAgICAgICAgdGhpcy56SW5kZXggPSB6SW5kZXg7XHJcbiAgICAgICAgaWYgKCB0aGlzLm9sTGF5ZXIgKSB7XHJcbiAgICAgICAgICAgICQoIHRoaXMub2xMYXllci5kaXYgKS5jc3MoICd6LWluZGV4JywgekluZGV4ICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ3pJbmRleCcsIHZhbHVlOiB6SW5kZXggfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBsYXllcnMgekluZGV4LlxyXG4gICAgICogQG1lbWJlcm9mIFNlcnZlckxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9IFRoZSB6SW5kZXggZm9yIHRoZSBsYXllci5cclxuICAgICAqL1xyXG4gICAgU2VydmVyTGF5ZXIucHJvdG90eXBlLmdldFpJbmRleCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy56SW5kZXg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSByYW1wIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBsYXllci5cclxuICAgICAqIEBtZW1iZXJvZiBTZXJ2ZXJMYXllclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByYW1wVHlwZSAtIFRoZSByYW1wIHR5cGUgdXNlZCB0byByZW5kZXIgdGhlIGltYWdlcy5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIFNlcnZlckxheWVyLnByb3RvdHlwZS5zZXRSYW1wVHlwZSA9IGZ1bmN0aW9uICggcmFtcFR5cGUsIGNhbGxiYWNrICkge1xyXG4gICAgICAgIGlmICggdGhpcy5yZW5kZXJlci5yYW1wICE9PSByYW1wVHlwZSApIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yYW1wID0gcmFtcFR5cGU7XHJcbiAgICAgICAgICAgIHNldFJhbXBJbWFnZVVybCggdGhpcywgY2FsbGJhY2sgKTtcclxuICAgICAgICAgICAgdGhpcy5yZWRyYXcoKTtcclxuICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7ZmllbGQ6ICdyYW1wVHlwZScsIHZhbHVlOiByYW1wVHlwZX0gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHJhbXAgdHlwZSBmb3IgbGF5ZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VydmVyTGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmFtcCBpZGVudGlmaWNhdGlvbiBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIFNlcnZlckxheWVyLnByb3RvdHlwZS5nZXRSYW1wVHlwZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnJhbXA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjdXJyZW50IG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzIGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsLlxyXG4gICAgICogQG1lbWJlcm9mIFNlcnZlckxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFRoZSBtaW4gYW5kIG1heCBvZiB0aGUgbGV2ZWwuXHJcbiAgICAgKi9cclxuICAgIFNlcnZlckxheWVyLnByb3RvdHlwZS5nZXRMZXZlbE1pbk1heCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBtaW5NYXggPSB0aGlzLmxldmVsTWluTWF4O1xyXG5cclxuICAgICAgICBpZiAodGhpcy52YWx1ZVRyYW5zZm9ybS5sYXllck1pbiAmJiB0aGlzLnZhbHVlVHJhbnNmb3JtLmxheWVyTWluICkgeyAvLyBHaXZlIHByZWNlZGVuY2UgdG8gY29uZmlnIG92ZXJyaWRlXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiB0aGlzLnZhbHVlVHJhbnNmb3JtLmxheWVyTWluLFxyXG4gICAgICAgICAgICAgICAgbWF4aW11bTogdGhpcy52YWx1ZVRyYW5zZm9ybS5sYXllck1heFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIG1pbk1heC5tYXhpbXVtIGluc3RhbmNlb2YgQXJyYXkgKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy50aWxlVHJhbnNmb3JtLmRhdGEsXHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGEuc3RhcnRCdWNrZXQgIT09IHVuZGVmaW5lZCA/IGRhdGEuc3RhcnRCdWNrZXQgOiAwLFxyXG4gICAgICAgICAgICAgICAgc3RvcCA9IGRhdGEuZW5kQnVja2V0ICE9PSB1bmRlZmluZWQgPyBkYXRhLmVuZEJ1Y2tldCA6IG1pbk1heC5tYXhpbXVtLmxlbmd0aC0xLFxyXG4gICAgICAgICAgICAgICAgbWluaW11bSA9IDAsXHJcbiAgICAgICAgICAgICAgICBtYXhpbXVtID0gMCxcclxuICAgICAgICAgICAgICAgIGk7XHJcbiAgICAgICAgICAgIGZvciAoIGk9c3RhcnQ7IGk8PXN0b3A7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIG1pbmltdW0gKz0gbWluTWF4Lm1pbmltdW1baV0gfHwgMDtcclxuICAgICAgICAgICAgICAgIG1heGltdW0gKz0gbWluTWF4Lm1heGltdW1baV0gfHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbWluaW11bTogbWluaW11bSxcclxuICAgICAgICAgICAgICAgIG1heGltdW06IG1heGltdW1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWxNaW5NYXg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHJhbXAgaW1hZ2UgVVJMIHN0cmluZy5cclxuICAgICAqIEBtZW1iZXJvZiBTZXJ2ZXJMYXllclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBlbmNvZGVkIHJhbXAgaW1hZ2UgdXJsLlxyXG4gICAgICovXHJcbiAgICBTZXJ2ZXJMYXllci5wcm90b3R5cGUuZ2V0UmFtcEltYWdlVXJsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmFtcEltYWdlVXJsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY3VycmVudCB2YWx1ZSBieSB3aGljaCB0aGUgbWluaW11bSBjb2xvciByYW1wIGlzIGNsYW1wZWQgdG8gYnkgcGVyY2VudGFnZVxyXG4gICAgICogaW4gdGhlIHJhbmdlIFswLTFdLlxyXG4gICAgICogQG1lbWJlcm9mIFNlcnZlckxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSByYW5nZSBtaW4gaW4gcGVyY2VudGFnZS5cclxuICAgICAqL1xyXG4gICAgU2VydmVyTGF5ZXIucHJvdG90eXBlLnNldFJhbmdlTWluUGVyY2VudGFnZSA9IGZ1bmN0aW9uKCBtaW4gKSB7XHJcbiAgICAgICAgbWluID0gTWF0aC5tYXgoIE1hdGgubWluKCBtaW4sIDEgKSwgMCApICogMTAwO1xyXG4gICAgICAgIGlmICggdGhpcy5yZW5kZXJlci5yYW5nZU1pbiAhPT0gbWluICkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJhbmdlTWluID0gbWluO1xyXG4gICAgICAgICAgICB0aGlzLnJlZHJhdygpO1xyXG4gICAgICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICdyYW5nZU1pbicsIHZhbHVlOiBtaW4gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBieSB3aGljaCB0aGUgbWluaW11bSBjb2xvciByYW1wIGlzIGNsYW1wZWQgdG8gYnkgcGVyY2VudGFnZVxyXG4gICAgICogaW4gdGhlIHJhbmdlIFswLTFdLlxyXG4gICAgICogQG1lbWJlcm9mIFNlcnZlckxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJhbmdlIG1heCBpbiBwZXJjZW50YWdlLlxyXG4gICAgICovXHJcbiAgICBTZXJ2ZXJMYXllci5wcm90b3R5cGUuZ2V0UmFuZ2VNaW5QZXJjZW50YWdlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmFuZ2VNaW4gLyAxMDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjdXJyZW50IHZhbHVlIGJ5IHdoaWNoIHRoZSBtYXhpbXVtIGNvbG9yIHJhbXAgaXMgY2xhbXBlZCB0byBieSBwZXJjZW50YWdlXHJcbiAgICAgKiBpbiB0aGUgcmFuZ2UgWzAtMV0uXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VydmVyTGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIHJhbmdlIG1heCBpbiBwZXJjZW50YWdlLlxyXG4gICAgICovXHJcbiAgICBTZXJ2ZXJMYXllci5wcm90b3R5cGUuc2V0UmFuZ2VNYXhQZXJjZW50YWdlID0gZnVuY3Rpb24oIG1heCApIHtcclxuICAgICAgICBtYXggPSBNYXRoLm1heCggTWF0aC5taW4oIG1heCwgMSApLCAwICkgKiAxMDA7XHJcbiAgICAgICAgaWYgKCB0aGlzLnJlbmRlcmVyLnJhbmdlTWF4ICE9PSBtYXggKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmFuZ2VNYXggPSBtYXg7XHJcbiAgICAgICAgICAgIHRoaXMucmVkcmF3KCk7XHJcbiAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwge2ZpZWxkOiAncmFuZ2VNYXgnLCB2YWx1ZTogbWF4fSApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgYnkgd2hpY2ggdGhlIG1heGltdW0gY29sb3IgcmFtcCBpcyBjbGFtcGVkIHRvIGJ5IHBlcmNlbnRhZ2VcclxuICAgICAqIGluIHRoZSByYW5nZSBbMC0xXS5cclxuICAgICAqIEBtZW1iZXJvZiBTZXJ2ZXJMYXllclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByYW5nZSBtaW4gaW4gcGVyY2VudGFnZS5cclxuICAgICAqL1xyXG4gICAgU2VydmVyTGF5ZXIucHJvdG90eXBlLmdldFJhbmdlTWF4UGVyY2VudGFnZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnJhbmdlTWF4IC8gMTAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogU2V0IHRoZSBjdXJyZW50IHZhbHVlIGJ5IHdoaWNoIHRoZSBtaW5pbXVtIGNvbG9yIHJhbXAgaXMgY2xhbXBlZCB0by5cclxuICAgICogQG1lbWJlcm9mIFNlcnZlckxheWVyXHJcbiAgICAqXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgcmFuZ2UgbWluIGJ5IHZhbHVlLlxyXG4gICAgKi9cclxuICAgIFNlcnZlckxheWVyLnByb3RvdHlwZS5zZXRSYW5nZU1pblZhbHVlID0gZnVuY3Rpb24oIG1pbiApIHtcclxuICAgICAgICB0aGlzLnNldFJhbmdlTWluUGVyY2VudGFnZShcclxuICAgICAgICAgICAgVXRpbC5ub3JtYWxpemVWYWx1ZShcclxuICAgICAgICAgICAgICAgIG1pbixcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGV2ZWxNaW5NYXgoKSxcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VmFsdWVUcmFuc2Zvcm1UeXBlKClcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgYnkgd2hpY2ggdGhlIG1pbmltdW0gY29sb3IgcmFtcCBpcyBjbGFtcGVkIHRvLlxyXG4gICAgKiBAbWVtYmVyb2YgU2VydmVyTGF5ZXJcclxuICAgICpcclxuICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJhbmdlIG1pbiBieSB2YWx1ZS5cclxuICAgICovXHJcbiAgICBTZXJ2ZXJMYXllci5wcm90b3R5cGUuZ2V0UmFuZ2VNaW5WYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBVdGlsLmRlbm9ybWFsaXplVmFsdWUoXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0UmFuZ2VNaW5QZXJjZW50YWdlKCksXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0TGV2ZWxNaW5NYXgoKSxcclxuICAgICAgICAgICAgdGhpcy5nZXRWYWx1ZVRyYW5zZm9ybVR5cGUoKSApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogU2V0IHRoZSBjdXJyZW50IHZhbHVlIGJ5IHdoaWNoIHRoZSBtYXhpbXVtIGNvbG9yIHJhbXAgaXMgY2xhbXBlZCB0by5cclxuICAgICogQG1lbWJlcm9mIFNlcnZlckxheWVyXHJcbiAgICAqXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgcmFuZ2UgbWF4IGJ5IHZhbHVlLlxyXG4gICAgKi9cclxuICAgIFNlcnZlckxheWVyLnByb3RvdHlwZS5zZXRSYW5nZU1heFZhbHVlID0gZnVuY3Rpb24oIG1heCApIHtcclxuICAgICAgICB0aGlzLnNldFJhbmdlTWF4UGVyY2VudGFnZShcclxuICAgICAgICAgICAgVXRpbC5ub3JtYWxpemVWYWx1ZShcclxuICAgICAgICAgICAgICAgIG1heCxcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGV2ZWxNaW5NYXgoKSxcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VmFsdWVUcmFuc2Zvcm1UeXBlKClcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgYnkgd2hpY2ggdGhlIG1heGltdW0gY29sb3IgcmFtcCBpcyBjbGFtcGVkIHRvLlxyXG4gICAgKiBAbWVtYmVyb2YgU2VydmVyTGF5ZXJcclxuICAgICpcclxuICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJhbmdlIG1heCBieSB2YWx1ZS5cclxuICAgICovXHJcbiAgICBTZXJ2ZXJMYXllci5wcm90b3R5cGUuZ2V0UmFuZ2VNYXhWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBVdGlsLmRlbm9ybWFsaXplVmFsdWUoXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0UmFuZ2VNYXhQZXJjZW50YWdlKCksXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0TGV2ZWxNaW5NYXgoKSxcclxuICAgICAgICAgICAgdGhpcy5nZXRWYWx1ZVRyYW5zZm9ybVR5cGUoKSApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlIHRyYW5zZm9ybSBmdW5jdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIGxheWVyLiBSZXN1bHRzIGluIGEgUE9TVFxyXG4gICAgICogcmVxdWVzdCB0byB0aGUgc2VydmVyLlxyXG4gICAgICogQG1lbWJlcm9mIFNlcnZlckxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zZm9ybVR5cGUgLSBUaGUgbmV3IG5ldyByYW1wIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBTZXJ2ZXJMYXllci5wcm90b3R5cGUuc2V0VmFsdWVUcmFuc2Zvcm1UeXBlID0gZnVuY3Rpb24gKCB0cmFuc2Zvcm1UeXBlICkge1xyXG4gICAgICAgIGlmICggdGhpcy52YWx1ZVRyYW5zZm9ybS50eXBlICE9PSB0cmFuc2Zvcm1UeXBlICkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlVHJhbnNmb3JtLnR5cGUgPSB0cmFuc2Zvcm1UeXBlO1xyXG4gICAgICAgICAgICB0aGlzLnJlZHJhdygpO1xyXG4gICAgICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICd2YWx1ZVRyYW5zZm9ybVR5cGUnLCB2YWx1ZTogdHJhbnNmb3JtVHlwZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIHRyYW5zZm9ybSBmdW5jdGlvbiB0eXBlLlxyXG4gICAgICogQG1lbWJlcm9mIFNlcnZlckxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgdmFsdWUgdHJhbnNmb3JtIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIFNlcnZlckxheWVyLnByb3RvdHlwZS5nZXRWYWx1ZVRyYW5zZm9ybVR5cGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVRyYW5zZm9ybS50eXBlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbGF5ZXJzIHRpbGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHR5cGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VydmVyTGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNmb3JtVHlwZSAtIFRoZSB0aWxlIHRyYW5zZm9ybWVyIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIFNlcnZlckxheWVyLnByb3RvdHlwZS5zZXRUaWxlVHJhbnNmb3JtVHlwZSA9IGZ1bmN0aW9uICggdHJhbnNmb3JtVHlwZSApIHtcclxuICAgICAgICBpZiAoIHRoaXMudGlsZVRyYW5zZm9ybS50eXBlICE9PSB0cmFuc2Zvcm1UeXBlICkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbGVUcmFuc2Zvcm0udHlwZSA9IHRyYW5zZm9ybVR5cGU7XHJcbiAgICAgICAgICAgIHRoaXMucmVkcmF3KCk7XHJcbiAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCB0aGlzLmdldENoYW5uZWwoKSwge2ZpZWxkOiAndGlsZVRyYW5zZm9ybVR5cGUnLCB2YWx1ZTogdHJhbnNmb3JtVHlwZX0gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBsYXllcnMgdHJhbnNmb3JtZXIgdHlwZS5cclxuICAgICAqIEBtZW1iZXJvZiBTZXJ2ZXJMYXllclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHRpbGUgdHJhbnNmb3JtIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIFNlcnZlckxheWVyLnByb3RvdHlwZS5nZXRUaWxlVHJhbnNmb3JtVHlwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aWxlVHJhbnNmb3JtLnR5cGU7XHJcbiAgICB9O1xyXG5cclxuXHQvKipcclxuICAgICAqIFNldCB0aGUgdGlsZSB0cmFuc2Zvcm0gZGF0YSBiYXNlZCBvbiB0aGUgdGltZSByYW5nZSBwYXNzZWQgaW5cclxuICAgICAqIEBtZW1iZXJvZiBTZXJ2ZXJMYXllclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEEgdW5peCB0aW1lc3RhbXAgcmVwcmVzZW50aW5nIHRoZSBzdGFydCBvZiB0aGUgdGltZSByYW5nZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCAtIEEgdW5peCB0aW1lc3RhbXAgcmVwcmVzZW50aW5nIHRoZSBlbmQgb2YgdGhlIHRpbWUgcmFuZ2VcclxuICAgICAqL1xyXG4gICAgU2VydmVyTGF5ZXIucHJvdG90eXBlLnNldFRpbGVUcmFuc2Zvcm1SYW5nZSA9IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcclxuICAgICAgICB2YXIgbWV0YSA9IHRoaXMuc291cmNlLm1ldGEubWV0YSxcclxuXHRcdFx0cmFuZ2VNaW4gPSBtZXRhLnJhbmdlTWluLFxyXG5cdFx0XHRyYW5nZU1heCA9IG1ldGEucmFuZ2VNYXgsXHJcblx0XHRcdG51bUJ1Y2tldHMgPSBtZXRhLmJ1Y2tldENvdW50LFxyXG4gICAgICAgICAgICBidWNrZXRTaXplID0gKCByYW5nZU1heCAtIHJhbmdlTWluICkgLyBudW1CdWNrZXRzO1xyXG4gICAgICAgIGlmICggc3RhcnQgPiByYW5nZU1heCAmJiBlbmQgPCByYW5nZU1pbiApIHtcclxuICAgICAgICAgICAgLy8gb3V0c2lkZSByYW5nZSBjb21wbGV0ZWx5LCBzZW5kIGVtcHR5IHJlcXVlc3RcclxuXHRcdFx0dGhpcy5zZXRUaWxlVHJhbnNmb3JtRGF0YSh7XHJcbiAgICBcdFx0XHRzdGFydEJ1Y2tldDogLTEsXHJcbiAgICBcdFx0XHRlbmRCdWNrZXQ6IC0xXHJcbiAgICAgICAgICAgIH0pO1xyXG5cdFx0fVxyXG4gICAgICAgIHRoaXMuc2V0VGlsZVRyYW5zZm9ybURhdGEoe1xyXG5cdFx0XHRzdGFydEJ1Y2tldDogTWF0aC5tYXgoIDAsIE1hdGguZmxvb3IoICggc3RhcnQgLSByYW5nZU1pbiApIC8gYnVja2V0U2l6ZSApICksXHJcblx0XHRcdGVuZEJ1Y2tldDogTWF0aC5taW4oIG51bUJ1Y2tldHMtMSwgTWF0aC5mbG9vciggKCBlbmQgLSByYW5nZU1pbiApIC8gYnVja2V0U2l6ZSApIClcclxuICAgICAgICB9KTtcclxuXHR9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB0aWxlIHRyYW5zZm9ybSBkYXRhIGF0dHJpYnV0ZVxyXG4gICAgICogQG1lbWJlcm9mIFNlcnZlckxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybURhdGEgLSBUaGUgdGlsZSB0cmFuc2Zvcm0gZGF0YSBhdHRyaWJ1dGUuXHJcbiAgICAgKi9cclxuICAgIFNlcnZlckxheWVyLnByb3RvdHlwZS5zZXRUaWxlVHJhbnNmb3JtRGF0YSA9IGZ1bmN0aW9uICggdHJhbnNmb3JtRGF0YSApIHtcclxuICAgICAgICBpZiAoICFfLmlzRXF1YWwoIHRoaXMudGlsZVRyYW5zZm9ybS5kYXRhLCB0cmFuc2Zvcm1EYXRhICkgKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlsZVRyYW5zZm9ybS5kYXRhID0gdHJhbnNmb3JtRGF0YTtcclxuICAgICAgICAgICAgdGhpcy5yZWRyYXcoKTtcclxuICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7ZmllbGQ6ICd0aWxlVHJhbnNmb3JtRGF0YScsIHZhbHVlOiB0cmFuc2Zvcm1EYXRhfSApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHRyYW5zZm9ybWVyIGRhdGEgYXR0cmlidXRlLlxyXG4gICAgICogQG1lbWJlcm9mIFNlcnZlckxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHRpbGUgdHJhbnNmb3JtIGRhdGEgYXR0cmlidXRlLlxyXG4gICAgICovXHJcbiAgICBTZXJ2ZXJMYXllci5wcm90b3R5cGUuZ2V0VGlsZVRyYW5zZm9ybURhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVRyYW5zZm9ybS5kYXRhIHx8IHt9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbGF5ZXJzIHBpeGVsIGNvYXJzZW5lc3MuXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VydmVyTGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29hcnNlbmVzcyB7aW50ZWdlcn0gVGhlIHBpeGVsIGJ5IHBpeGVsIGNvYXJzZW5lc3Mgb2YgdGhlIGxheWVyXHJcbiAgICAgKi9cclxuICAgIFNlcnZlckxheWVyLnByb3RvdHlwZS5zZXRDb2Fyc2VuZXNzID0gZnVuY3Rpb24oIGNvYXJzZW5lc3MgKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLnJlbmRlcmVyLmNvYXJzZW5lc3MgIT09IGNvYXJzZW5lc3MgKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuY29hcnNlbmVzcyA9IGNvYXJzZW5lc3M7XHJcbiAgICAgICAgICAgIHNldExldmVsTWluTWF4KCB0aGlzICk7IC8vIGNvYXJzZW5lc3MgbW9kaWZpZXMgdGhlIG1pbi9tYXhcclxuICAgICAgICAgICAgdGhpcy5yZWRyYXcoKTtcclxuICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnY29hcnNlbmVzcycsIHZhbHVlOiBjb2Fyc2VuZXNzIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGxheWVycyBwaXhlbCBjb2Fyc2VuZXNzLlxyXG4gICAgICogQG1lbWJlcm9mIFNlcnZlckxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9IFRoZSBsYXllcnMgY29hcnNlbmVzcyBpbiBOIGJ5IE4gcGl4ZWxzLlxyXG4gICAgICovXHJcbiAgICBTZXJ2ZXJMYXllci5wcm90b3R5cGUuZ2V0Q29hcnNlbmVzcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmNvYXJzZW5lc3M7XHJcbiAgICB9O1xyXG5cclxuICAgIFNlcnZlckxheWVyLnByb3RvdHlwZS5zZXRGaWx0ZXJQYXJhbXMgPSBmdW5jdGlvbiggZmlsdGVyICkge1xyXG4gICAgXHR0aGlzLmZpbHRlclBhcmFtcyA9IGZpbHRlcjtcclxuICAgIFx0dGhpcy5yZWRyYXcoKTtcclxuICAgIH07XHJcblxyXG4gICAgU2VydmVyTGF5ZXIucHJvdG90eXBlLmdldEZpbHRlclBhcmFtcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICBcdHJldHVybiB0aGlzLmZpbHRlclBhcmFtcyA/IHRoaXMuZmlsdGVyUGFyYW1zIDogbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSBxdWVyeSBwYXJhbWV0ZXJzIGJhc2VkIG9uIHN0YXRlIG9mIGxheWVyXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VydmVyTGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcXVlcnkgcGFyYW1ldGVyIHN0cmluZyBiYXNlZCBvbiB0aGUgYXR0cmlidXRlcyBvZiB0aGlzIGxheWVyLlxyXG4gICAgICovXHJcbiAgICBTZXJ2ZXJMYXllci5wcm90b3R5cGUuZ2V0UXVlcnlQYXJhbVN0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBxdWVyeSA9IHtcclxuICAgICAgICAgICAgcmVuZGVyZXI6IHRoaXMucmVuZGVyZXIsXHJcbiAgICAgICAgICAgIHRpbGVUcmFuc2Zvcm06IHRoaXMudGlsZVRyYW5zZm9ybSxcclxuICAgICAgICAgICAgdmFsdWVUcmFuc2Zvcm06IHRoaXMudmFsdWVUcmFuc2Zvcm0sXHJcbiAgICAgICAgICAgIGZpbHRlcjogdGhpcy5nZXRGaWx0ZXJQYXJhbXMoKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFV0aWwuZW5jb2RlUXVlcnlQYXJhbXMoIHF1ZXJ5ICk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVkcmF3cyB0aGUgZW50aXJlIGxheWVyLlxyXG4gICAgICogQG1lbWJlcm9mIFNlcnZlckxheWVyXHJcbiAgICAgKi9cclxuICAgIFNlcnZlckxheWVyLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLm9sTGF5ZXIgKSB7XHJcbiAgICAgICAgICAgIHNldExldmVsTWluTWF4KCB0aGlzICk7XHJcbiAgICAgICAgICAgIHRoaXMub2xMYXllci5yZWRyYXcoKTtcclxuICAgICAgICAgICAgLy8gSWYgd2UncmUgdXNpbmcgdGhlIFRpbGVNYW5hZ2VyIHdlIG5lZWQgdG8gZm9yY2UgaXQgaW50byBhIHJlZnJlc2guIFRoZXJlIGlzIG5vIG5pY2Ugd2F5IHRvXHJcbiAgICAgICAgICAgIC8vIGRvIHRoaXMgYXMgb2YgMi4xMy4xLCBzbyB3ZSBmYWtlIHRoZSBleHBpcnkgb2YgdGhlIG1vdmUvem9vbSB0aW1lb3V0LlxyXG4gICAgICAgICAgICBpZiAoIHRoaXMub2xMYXllci5tYXAgJiYgdGhpcy5vbExheWVyLm1hcC50aWxlTWFuYWdlciApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2xMYXllci5tYXAudGlsZU1hbmFnZXIudXBkYXRlVGltZW91dChcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9sTGF5ZXIubWFwLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2xMYXllci5tYXAudGlsZU1hbmFnZXIuem9vbURlbGF5LFxyXG4gICAgICAgICAgICAgICAgICAgIHRydWUgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTZXJ2ZXJMYXllcjtcclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xyXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cclxuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBIdG1sVGlsZSA9IHJlcXVpcmUoJy4vSHRtbFRpbGUnKTtcclxuXHJcbiAgICBmdW5jdGlvbiBjbGFtcEJvdW5kcyggYm91bmRzLCBsYXllciApIHtcclxuICAgICAgICBib3VuZHMgPSBib3VuZHMuY2xvbmUoKTtcclxuICAgICAgICBpZiAoIGxheWVyLmRpbWVuc2lvbiA9PT0gXCJ4XCIgKSB7XHJcbiAgICAgICAgICAgIGJvdW5kcy5ib3R0b20gPSBsYXllci5tYXAuZ2V0TWF4RXh0ZW50KCkuYm90dG9tO1xyXG4gICAgICAgICAgICBib3VuZHMudG9wID0gbGF5ZXIubWFwLmdldE1heEV4dGVudCgpLmJvdHRvbSArIDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYm91bmRzLmxlZnQgPSBsYXllci5tYXAuZ2V0TWF4RXh0ZW50KCkubGVmdDtcclxuICAgICAgICAgICAgYm91bmRzLnJpZ2h0ID0gbGF5ZXIubWFwLmdldE1heEV4dGVudCgpLmxlZnQgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYm91bmRzO1xyXG4gICAgfVxyXG5cclxuICAgIE9wZW5MYXllcnMuVGlsZS5Vbml2YXJpYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgT3BlbkxheWVycy5UaWxlLkhUTUwuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xyXG4gICAgfTtcclxuXHJcbiAgICBPcGVuTGF5ZXJzLlRpbGUuVW5pdmFyaWF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIdG1sVGlsZS5wcm90b3R5cGUgKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNsYW1wIHRoZSAnbWFwRXh0ZW50JyB2YWx1ZSBmb3IgdGhlIG1hcFxyXG4gICAgICogb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBPcGVuTGF5ZXJzLlRpbGUuVW5pdmFyaWF0ZS5wcm90b3R5cGUuc2hvdWxkRHJhdyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB3aXRoaW5NYXhFeHRlbnQgPSBmYWxzZSxcclxuICAgICAgICAgICAgbWF4RXh0ZW50ID0gY2xhbXBCb3VuZHMoIHRoaXMubGF5ZXIubWF4RXh0ZW50LCB0aGlzLmxheWVyICk7XHJcbiAgICAgICAgaWYgKCBtYXhFeHRlbnQgKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLmxheWVyLm1hcCxcclxuICAgICAgICAgICAgICAgIGJvdW5kcyA9IG1hcC5nZXRNYXhFeHRlbnQoKTtcclxuICAgICAgICAgICAgdmFyIHdvcmxkQm91bmRzID0gbWFwLmJhc2VMYXllci53cmFwRGF0ZUxpbmUgJiYgY2xhbXBCb3VuZHMoIGJvdW5kcywgdGhpcy5sYXllciApO1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYm91bmRzLmludGVyc2VjdHNCb3VuZHMoIG1heEV4dGVudCwge2luY2x1c2l2ZTogZmFsc2UsIHdvcmxkQm91bmRzOiB3b3JsZEJvdW5kc30gKSApIHtcclxuICAgICAgICAgICAgICAgIHdpdGhpbk1heEV4dGVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdpdGhpbk1heEV4dGVudCB8fCB0aGlzLmxheWVyLmRpc3BsYXlPdXRzaWRlTWF4RXh0ZW50O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGluamVjdCB0aGUgJ29sVW5pdmFyaWF0ZVRpbGUnIGNsYXNzIGluc3RlYWRcclxuICAgICAqIG9mIHRoZSB1c3VhbCBvbEh0bWxUaWxlLlxyXG4gICAgICovXHJcbiAgICBPcGVuTGF5ZXJzLlRpbGUuVW5pdmFyaWF0ZS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoICF0aGlzLmltZ0RpdiApIHtcclxuICAgICAgICAgICAgdGhpcy5pbWdEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xyXG4gICAgICAgICAgICB0aGlzLmltZ0Rpdi5jbGFzc05hbWUgPSAnb2xUaWxlVW5pdmFyaWF0ZSc7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuaW1nRGl2LnN0eWxlO1xyXG4gICAgICAgICAgICBzdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcclxuICAgICAgICAgICAgc3R5bGUub3BhY2l0eSA9IDA7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5sYXllci5vcGFjaXR5IDwgMSApIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmZpbHRlciA9ICdhbHBoYShvcGFjaXR5PScgKyAodGhpcy5sYXllci5vcGFjaXR5ICogMTAwKSArICcpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1nRGl2O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGluamVjdCB0aGUgJ29sVW5pdmFyaWF0ZVRpbGUnIGNsYXNzIGluc3RlYWRcclxuICAgICAqIG9mIHRoZSB1c3VhbCBvbEh0bWxUaWxlLlxyXG4gICAgICovXHJcbiAgICBPcGVuTGF5ZXJzLlRpbGUuVW5pdmFyaWF0ZS5wcm90b3R5cGUucG9zaXRpb25UaWxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5nZXRUaWxlKCkuc3R5bGUsXHJcbiAgICAgICAgICAgIHNpemUgPSB0aGlzLmxheWVyLmdldEltYWdlU2l6ZSh0aGlzLmJvdW5kcyksXHJcbiAgICAgICAgICAgIHJhdGlvID0gMTtcclxuICAgICAgICBpZiAoIHRoaXMubGF5ZXIgaW5zdGFuY2VvZiBPcGVuTGF5ZXJzLkxheWVyLkdyaWQgKSB7XHJcbiAgICAgICAgICAgIHJhdGlvID0gdGhpcy5sYXllci5nZXRTZXJ2ZXJSZXNvbHV0aW9uKCkgLyB0aGlzLmxheWVyLm1hcC5nZXRSZXNvbHV0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0eWxlLmxlZnQgPSB0aGlzLnBvc2l0aW9uLnggKyBcInB4XCI7XHJcbiAgICAgICAgc3R5bGUudG9wID0gXCItMjU2cHhcIjtcclxuICAgICAgICBzdHlsZS53aWR0aCA9IE1hdGgucm91bmQocmF0aW8gKiBzaXplLncpICsgXCJweFwiO1xyXG4gICAgICAgIHN0eWxlLmhlaWdodCA9IE1hdGgucm91bmQocmF0aW8gKiBzaXplLmgpICsgXCJweFwiO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE9wZW5MYXllcnMuVGlsZS5Vbml2YXJpYXRlO1xyXG59KCkpO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIFVuaXZhcmlhdGVUaWxlID0gcmVxdWlyZSgnLi9Vbml2YXJpYXRlVGlsZScpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNsYW1wQm91bmRzKCBib3VuZHMsIGxheWVyICkge1xyXG4gICAgICAgIGJvdW5kcyA9IGJvdW5kcy5jbG9uZSgpO1xyXG4gICAgICAgIGlmICggbGF5ZXIuZGltZW5zaW9uID09PSBcInhcIiApIHtcclxuICAgICAgICAgICAgYm91bmRzLmJvdHRvbSA9IGxheWVyLm1hcC5nZXRNYXhFeHRlbnQoKS5ib3R0b207XHJcbiAgICAgICAgICAgIGJvdW5kcy50b3AgPSBsYXllci5tYXAuZ2V0TWF4RXh0ZW50KCkuYm90dG9tICsgMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBib3VuZHMubGVmdCA9IGxheWVyLm1hcC5nZXRNYXhFeHRlbnQoKS5sZWZ0O1xyXG4gICAgICAgICAgICBib3VuZHMucmlnaHQgPSBsYXllci5tYXAuZ2V0TWF4RXh0ZW50KCkubGVmdCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBib3VuZHM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVwb3NpdGlvbkxheWVyKCBtYXAsIGxheWVyICkge1xyXG4gICAgICAgIHZhciAkdmlld3BvcnQgPSAkKCBtYXAudmlld1BvcnREaXYgKSxcclxuICAgICAgICAgICAgJGRpdiA9ICQoIGxheWVyLmRpdiApLFxyXG4gICAgICAgICAgICBoZWlnaHQgPSAkdmlld3BvcnQuaGVpZ2h0KCk7XHJcbiAgICAgICAgaWYgKCBsYXllci5kaW1lbnNpb24gPT09IFwieFwiICkgIHtcclxuICAgICAgICAgICAgJGRpdi5jc3MoICd0b3AnLCBoZWlnaHQgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAkZGl2LmNzcyggJ2xlZnQnLCAwICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZVRpbGVQb3NpdGlvbnMobWFwLCBsYXllcik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb25NYXBNb3ZlKCBtYXAsIGxheWVyICkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdXBkYXRlVGlsZVBvc2l0aW9ucyhtYXAsIGxheWVyKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVRpbGVQb3NpdGlvbnMobWFwLCBsYXllcikge1xyXG4gICAgICAgIHZhciAkY29udGFpbmVyID0gJCggbGF5ZXIuZGl2ICkucGFyZW50KCksXHJcbiAgICAgICAgICAgICR2aWV3cG9ydCA9ICQoIG1hcC52aWV3UG9ydERpdiApLFxyXG4gICAgICAgICAgICAkZGl2ID0gJCggbGF5ZXIuZGl2ICksXHJcbiAgICAgICAgICAgIG9mZnNldCA9ICRjb250YWluZXIucG9zaXRpb24oKSxcclxuICAgICAgICAgICAgaGVpZ2h0ID0gJHZpZXdwb3J0LmhlaWdodCgpO1xyXG4gICAgICAgIGlmICggbGF5ZXIuZGltZW5zaW9uID09PSBcInhcIiApIHtcclxuICAgICAgICAgICAgLy8gcmVzZXQgdGlsZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGxheWVyIGRpdlxyXG4gICAgICAgICAgICAkZGl2LmNoaWxkcmVuKCkuZWFjaCggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAkKCB0aGlzICkuY3NzKCAndG9wJywgLTI1NiApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gdGhlbiBzZXQgZGl2IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICRkaXYuY3NzKCAndG9wJywgaGVpZ2h0IC0gb2Zmc2V0LnRvcCApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJlc2V0IHRpbGUgcG9zaXRpb24gd2l0aGluIHRoZSBsYXllciBkaXZcclxuICAgICAgICAgICAgJGRpdi5jaGlsZHJlbigpLmVhY2goIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgJCggdGhpcyApLmNzcyggJ2xlZnQnLCAwICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyB0aGVuIHNldCBkaXYgcG9zaXRpb25cclxuICAgICAgICAgICAgJGRpdi5jc3MoICdsZWZ0JywgLW9mZnNldC5sZWZ0ICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIE9wZW5MYXllcnMuTGF5ZXIuVW5pdmFyaWF0ZSA9IGZ1bmN0aW9uKCBuYW1lLCB1cmwsIG9wdGlvbnMgKSB7XHJcbiAgICAgICAgT3BlbkxheWVycy5MYXllci5HcmlkLmNhbGwoIHRoaXMsIG5hbWUsIHVybCwgb3B0aW9ucyApO1xyXG4gICAgICAgIHRoaXMuZ2V0VVJMID0gb3B0aW9ucy5nZXRVUkw7XHJcbiAgICAgICAgdGhpcy5sYXllcm5hbWUgPSBvcHRpb25zLmxheWVybmFtZTtcclxuICAgICAgICB0aGlzLmRpbWVuc2lvbiA9IG9wdGlvbnMuZGltZW5zaW9uIHx8ICd4JztcclxuICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XHJcbiAgICAgICAgdGhpcy50aWxlQ2xhc3MgPSBvcHRpb25zLnRpbGVDbGFzcyB8fCBVbml2YXJpYXRlVGlsZTtcclxuICAgICAgICB0aGlzLmh0bWwgPSBvcHRpb25zLmh0bWw7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG9wdGlvbnMucmVuZGVyZXI7XHJcbiAgICAgICAgdGhpcy5DTEFTU19OQU1FID0gJ09wZW5MYXllcnMuTGF5ZXIuVW5pdmFyaWF0ZSc7XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZW5MYXllcnMuTGF5ZXIuVW5pdmFyaWF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPcGVuTGF5ZXJzLkxheWVyLkdyaWQucHJvdG90eXBlICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZSB0byBzZXQgYWxsIGNoaWxkcmVuIHRoZSBvcGFjaXR5LlxyXG4gICAgICovXHJcbiAgICBPcGVuTGF5ZXJzLkxheWVyLlVuaXZhcmlhdGUucHJvdG90eXBlLnNldE9wYWNpdHkgPSBmdW5jdGlvbiggb3BhY2l0eSApIHtcclxuICAgICAgICBpZiAoIG9wYWNpdHkgIT09IHRoaXMub3BhY2l0eSApIHtcclxuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gTWF0aC5tYXgoIE1hdGgubWluKCBvcGFjaXR5LCAxICksIDAgKTtcclxuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzLmRpdi5jaGlsZE5vZGVzO1xyXG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMCwgbGVuID0gY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSApIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNbaV0uc3R5bGUub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMubWFwICE9PSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXAuZXZlbnRzLnRyaWdnZXJFdmVudCggXCJjaGFuZ2VsYXllclwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IFwib3BhY2l0eVwiXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgYSBwb3NpdGlvbmluZyBmdW5jdGlvbiB0byBjbGFtcFxyXG4gICAgICogdGhlIGxheWVycyB0aWxlcyB0byB0aGUgYXBwcm9wcmlhdGUgYXhpcy5cclxuICAgICAqL1xyXG4gICAgT3BlbkxheWVycy5MYXllci5Vbml2YXJpYXRlLnByb3RvdHlwZS5zZXRNYXAgPSBmdW5jdGlvbiggbWFwICkge1xyXG4gICAgICAgIE9wZW5MYXllcnMuTGF5ZXIuR3JpZC5wcm90b3R5cGUuc2V0TWFwLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcclxuICAgICAgICB0aGlzLm9uTWFwTW92ZSA9IG9uTWFwTW92ZSggbWFwLCB0aGlzICk7XHJcbiAgICAgICAgbWFwLmV2ZW50cy5yZWdpc3RlciggJ21vdmUnLCBtYXAsIHRoaXMub25NYXBNb3ZlICk7XHJcbiAgICAgICAgcmVwb3NpdGlvbkxheWVyKCBtYXAsIHRoaXMgKTsgLy8gc2V0IHBvc2l0aW9uXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmVtb3ZlIHRoZSBwb3NpdGlvbmluZyBmdW5jdGlvbiB0byBjbGFtcFxyXG4gICAgICogdGhlIGxheWVycyB0aWxlcyB0byB0aGUgYXBwcm9wcmlhdGUgYXhpcy5cclxuICAgICAqL1xyXG4gICAgT3BlbkxheWVycy5MYXllci5Vbml2YXJpYXRlLnByb3RvdHlwZS5yZW1vdmVNYXAgPSBmdW5jdGlvbiggbWFwICkge1xyXG4gICAgICAgIE9wZW5MYXllcnMuTGF5ZXIuR3JpZC5wcm90b3R5cGUucmVtb3ZlTWFwLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcclxuICAgICAgICBtYXAuZXZlbnRzLnVucmVnaXN0ZXIoICdtb3ZlJywgbWFwLCB0aGlzLm9uTWFwTW92ZSApO1xyXG4gICAgICAgIHRoaXMub25NYXBNb3ZlID0gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZS1wb3NpdGlvbiB0aGUgbGF5ZXIgYW5kIHByZXZlbnQgYSByZWRyYXcgd2hpY2hcclxuICAgICAqIHdpbGwgcmVwb3NpdGlvbiB0aGUgdGlsZXMuXHJcbiAgICAgKi9cclxuICAgIE9wZW5MYXllcnMuTGF5ZXIuVW5pdmFyaWF0ZS5wcm90b3R5cGUuc2V0VmlzaWJpbGl0eSA9IGZ1bmN0aW9uKCB2aXNpYmlsaXR5ICkge1xyXG4gICAgICAgIE9wZW5MYXllcnMuTGF5ZXIuR3JpZC5wcm90b3R5cGUuc2V0VmlzaWJpbGl0eS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XHJcbiAgICAgICAgaWYgKCB0aGlzLm9uTWFwTW92ZSAmJiB2aXNpYmlsaXR5ICkge1xyXG4gICAgICAgICAgICByZXBvc2l0aW9uTGF5ZXIoIHRoaXMubWFwLCB0aGlzICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBPcGVuTGF5ZXJzLkxheWVyLlVuaXZhcmlhdGUucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBjbGFtcEJvdW5kcyggdGhpcy5tYXAuY2FsY3VsYXRlQm91bmRzKCksIHRoaXMgKTtcclxuICAgIH07XHJcblxyXG4gICAgT3BlbkxheWVycy5MYXllci5Vbml2YXJpYXRlLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcmVkcmF3biA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLm1hcCkge1xyXG4gICAgICAgICAgICAvLyBtaW4vbWF4IFJhbmdlIG1heSBoYXZlIGNoYW5nZWRcclxuICAgICAgICAgICAgdGhpcy5pblJhbmdlID0gdGhpcy5jYWxjdWxhdGVJblJhbmdlKCk7XHJcbiAgICAgICAgICAgIC8vIG1hcCdzIGNlbnRlciBtaWdodCBub3QgeWV0IGJlIHNldFxyXG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcclxuICAgICAgICAgICAgaWYgKCBleHRlbnQgJiYgdGhpcy5pblJhbmdlICYmIHRoaXMudmlzaWJpbGl0eSApIHtcclxuICAgICAgICAgICAgICAgIHZhciB6b29tQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVUbyggZXh0ZW50LCB6b29tQ2hhbmdlZCwgZmFsc2UgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXJFdmVudChcIm1vdmVlbmRcIixcclxuICAgICAgICAgICAgICAgICAgICB7XCJ6b29tQ2hhbmdlZFwiOiB6b29tQ2hhbmdlZH0pO1xyXG4gICAgICAgICAgICAgICAgcmVkcmF3biA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXBvc2l0aW9uTGF5ZXIoIHRoaXMubWFwLCB0aGlzICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlZHJhd247XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY2xhbXAgdGhlICdtYXhFeHRlbnRzJyB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZVxyXG4gICAgICogbWFwIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgT3BlbkxheWVycy5MYXllci5Vbml2YXJpYXRlLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiggYm91bmRzLCB6b29tQ2hhbmdlZCwgZHJhZ2dpbmcgKSB7XHJcblxyXG4gICAgICAgIGlmICggIWJvdW5kcyApIHtcclxuICAgICAgICAgICAgYm91bmRzID0gdGhpcy5tYXAuZ2V0RXh0ZW50KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGJvdW5kcyAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIGJvdW5kcyA9IGNsYW1wQm91bmRzKCBib3VuZHMsIHRoaXMgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIGdyaWQgaXMgZW1wdHkgb3Igem9vbSBoYXMgY2hhbmdlZCwgd2UgKm11c3QqIHJlLXRpbGVcclxuICAgICAgICAgICAgdmFyIGZvcmNlUmVUaWxlID0gIXRoaXMuZ3JpZC5sZW5ndGggfHwgem9vbUNoYW5nZWQ7XHJcblxyXG4gICAgICAgICAgICAvLyB0b3RhbCBib3VuZHMgb2YgdGhlIHRpbGVzXHJcbiAgICAgICAgICAgIHZhciB0aWxlc0JvdW5kcyA9IHRoaXMuZ2V0VGlsZXNCb3VuZHMoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRoZSBuZXcgbWFwIHJlc29sdXRpb25cclxuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSB0aGlzLm1hcC5nZXRSZXNvbHV0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICAvLyB0aGUgc2VydmVyLXN1cHBvcnRlZCByZXNvbHV0aW9uIGZvciB0aGUgbmV3IG1hcCByZXNvbHV0aW9uXHJcbiAgICAgICAgICAgIHZhciBzZXJ2ZXJSZXNvbHV0aW9uID0gdGhpcy5nZXRTZXJ2ZXJSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLnNpbmdsZVRpbGUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byByZWRyYXcgd2hlbmV2ZXIgZXZlbiB0aGUgc2xpZ2h0ZXN0IHBhcnQgb2YgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyAgY3VycmVudCBib3VuZHMgaXMgbm90IGNvbnRhaW5lZCBieSBvdXIgdGlsZS5cclxuICAgICAgICAgICAgICAgIC8vICAodGh1cywgd2UgZG8gbm90IHNwZWNpZnkgcGFydGlhbCAtLSBpdHMgZGVmYXVsdCBpcyBmYWxzZSlcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGZvcmNlUmVUaWxlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICggIWRyYWdnaW5nICYmICF0aWxlc0JvdW5kcy5jb250YWluc0JvdW5kcyggYm91bmRzICkgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gc2luZ2xlIHRpbGUgbW9kZSB3aXRoIG5vIHRyYW5zaXRpb24gZWZmZWN0LCB3ZSBpbnNlcnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBhIG5vbi1zY2FsZWQgYmFja2J1ZmZlciB3aGVuIHRoZSBsYXllciBpcyBtb3ZlZC4gQnV0IGlmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYSB6b29tIG9jY3VycyByaWdodCBhZnRlciBhIG1vdmUsIGkuZS4gYmVmb3JlIHRoZSBuZXdcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbWFnZSBpcyByZWNlaXZlZCwgd2UgbmVlZCB0byByZW1vdmUgdGhlIGJhY2tidWZmZXIsIG9yXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gaWxsLXBvc2l0aW9uZWQgaW1hZ2Ugd2lsbCBiZSB2aXNpYmxlIGR1cmluZyB0aGUgem9vbVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zaXRpb24uXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggem9vbUNoYW5nZWQgJiYgdGhpcy50cmFuc2l0aW9uRWZmZWN0ICE9PSAncmVzaXplJyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVCYWNrQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICF6b29tQ2hhbmdlZCB8fCB0aGlzLnRyYW5zaXRpb25FZmZlY3QgPT09ICdyZXNpemUnICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5QmFja0J1ZmZlciggc2VydmVyUmVzb2x1dGlvbiApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0U2luZ2xlVGlsZSggYm91bmRzICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGJvdW5kcyBoYXZlIGNoYW5nZWQgc3VjaCB0aGF0IHRoZXkgYXJlIG5vdCBldmVuXHJcbiAgICAgICAgICAgICAgICAvLyAqcGFydGlhbGx5KiBjb250YWluZWQgYnkgb3VyIHRpbGVzIChlLmcuIHdoZW4gdXNlciBoYXNcclxuICAgICAgICAgICAgICAgIC8vIHByb2dyYW1tYXRpY2FsbHkgcGFubmVkIHRvIHRoZSBvdGhlciBzaWRlIG9mIHRoZSBlYXJ0aCBvblxyXG4gICAgICAgICAgICAgICAgLy8gem9vbSBsZXZlbCAxOCksIHRoZW4gbW92ZUdyaWRkZWRUaWxlcyBjb3VsZCBwb3RlbnRpYWxseSBoYXZlXHJcbiAgICAgICAgICAgICAgICAvLyB0byBydW4gdGhyb3VnaCB0aG91c2FuZHMgb2YgY3ljbGVzLCBzbyB3ZSB3YW50IHRvIHJlVGlsZVxyXG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCAodGh1cywgcGFydGlhbCB0cnVlKS5cclxuICAgICAgICAgICAgICAgIGZvcmNlUmVUaWxlID0gZm9yY2VSZVRpbGUgfHxcclxuICAgICAgICAgICAgICAgICAgICAhdGlsZXNCb3VuZHMuaW50ZXJzZWN0c0JvdW5kcyggYm91bmRzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkQm91bmRzOiB0aGlzLm1hcC5iYXNlTGF5ZXIud3JhcERhdGVMaW5lICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFtcEJvdW5kcyggdGhpcy5tYXAuZ2V0TWF4RXh0ZW50KCksIHRoaXMgKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcmVzb2x1dGlvbiAhPT0gc2VydmVyUmVzb2x1dGlvbiApIHtcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHMgPSB0aGlzLm1hcC5jYWxjdWxhdGVCb3VuZHMoIG51bGwsIHNlcnZlclJlc29sdXRpb24gKTtcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHMgPSBjbGFtcEJvdW5kcyggYm91bmRzLCB0aGlzICk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIGZvcmNlUmVUaWxlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJldGNoIHRoZSBsYXllciBkaXZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gc2VydmVyUmVzb2x1dGlvbiAvIHJlc29sdXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtRGl2KCBzY2FsZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGxheWVyIHdpZHRoLCBoZWlnaHQsIGxlZnQsIHRvcCwgdG8gZGVhbCB3aXRoXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNhc2Ugd2hlcmUgdGhlIGxheWVyIHdhcyBwcmV2aW91c2x5IHRyYW5zZm9ybWVkXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLmxlZnQgPSAnMCUnO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLnRvcCA9ICcwJSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBmb3JjZVJlVGlsZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHpvb21DaGFuZ2VkICYmIHRoaXMudHJhbnNpdGlvbkVmZmVjdCA9PT0gJ3Jlc2l6ZScgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlCYWNrQnVmZmVyKCBzZXJ2ZXJSZXNvbHV0aW9uICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdEdyaWRkZWRUaWxlcyggYm91bmRzICk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZUdyaWRkZWRUaWxlcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIG9ubHkgc2hpZnQgdGhlIGFwcHJvcHJpYXRlIHJvdyBvciBjb2x1bW5cclxuICAgICAqIG9mIHRoZSBncmlkIGRlcGVuZGluZyB0aGUgdGhlIGRpbWVuc2lvbiB0aGlzIGxheWVyIHJlcHJlc2VudHMuXHJcbiAgICAgKi9cclxuICAgIE9wZW5MYXllcnMuTGF5ZXIuVW5pdmFyaWF0ZS5wcm90b3R5cGUubW92ZUdyaWRkZWRUaWxlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlciArIDE7XHJcbiAgICAgICAgd2hpbGUodHJ1ZSkge1xyXG4gICAgICAgICAgICB2YXIgdGxUaWxlID0gdGhpcy5ncmlkWzBdWzBdO1xyXG4gICAgICAgICAgICB2YXIgdGxWaWV3UG9ydCA9IHtcclxuICAgICAgICAgICAgICAgIHg6IHRsVGlsZS5wb3NpdGlvbi54ICtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwLmxheWVyQ29udGFpbmVyT3JpZ2luUHgueCxcclxuICAgICAgICAgICAgICAgIHk6IHRsVGlsZS5wb3NpdGlvbi55ICtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwLmxheWVyQ29udGFpbmVyT3JpZ2luUHgueVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgcmF0aW8gPSB0aGlzLmdldFNlcnZlclJlc29sdXRpb24oKSAvIHRoaXMubWFwLmdldFJlc29sdXRpb24oKTtcclxuICAgICAgICAgICAgdmFyIHRpbGVTaXplID0ge1xyXG4gICAgICAgICAgICAgICAgdzogTWF0aC5yb3VuZCh0aGlzLnRpbGVTaXplLncgKiByYXRpbyksXHJcbiAgICAgICAgICAgICAgICBoOiBNYXRoLnJvdW5kKHRoaXMudGlsZVNpemUuaCAqIHJhdGlvKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kaW1lbnNpb24gPT09ICd4Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRsVmlld1BvcnQueCA+IC10aWxlU2l6ZS53ICogKGJ1ZmZlciAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGlmdENvbHVtbih0cnVlLCB0aWxlU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRsVmlld1BvcnQueCA8IC10aWxlU2l6ZS53ICogYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGlmdENvbHVtbihmYWxzZSwgdGlsZVNpemUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0bFZpZXdQb3J0LnkgPiAtdGlsZVNpemUuaCAqIChidWZmZXIgLSAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hpZnRSb3codHJ1ZSwgdGlsZVNpemUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bFZpZXdQb3J0LnkgPCAtdGlsZVNpemUuaCAqIGJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hpZnRSb3coZmFsc2UsIHRpbGVTaXplKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBPcGVuTGF5ZXJzLkxheWVyLlVuaXZhcmlhdGU7XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBMYXllciA9IHJlcXVpcmUoJy4vTGF5ZXInKSxcclxuICAgICAgICBQdWJTdWIgPSByZXF1aXJlKCcuLi91dGlsL1B1YlN1YicpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGUgYSBWZWN0b3JMYXllciBvYmplY3QuXHJcbiAgICAgKiBAY2xhc3MgVmVjdG9yTGF5ZXJcclxuICAgICAqIEBhdWdtZW50cyBMYXllclxyXG4gICAgICogQGNsYXNzZGVzYyBBIGNsaWVudCByZW5kZXJlZCBsYXllciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNwZWMgLSBUaGUgc3BlY2lmaWNhdGlvbiBvYmplY3QuXHJcbiAgICAgKiA8cHJlPlxyXG4gICAgICoge1xyXG4gICAgICogICAgIG9wYWNpdHkgIHtmbG9hdH0gICAgLSBUaGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIuIERlZmF1bHQgPSAxLjBcclxuICAgICAqICAgICBlbmFibGVkICB7Ym9vbGVhbn0gIC0gV2hldGhlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZSBvciBub3QuIERlZmF1bHQgPSB0cnVlXHJcbiAgICAgKiAgICAgekluZGV4ICAge2ludGVnZXJ9ICAtIFRoZSB6IGluZGV4IG9mIHRoZSBsYXllci4gRGVmYXVsdCA9IDEwMDBcclxuICAgICAqICAgICB2ZWN0b3JzIHtBcnJheX0gICAgIC0gQXJyYXkgb2YgT3BlbkxheWVycyBWZWN0b3Igb2JqZWN0cyB0byBhZGQgdG8gdGhlIG1hcFxyXG4gICAgICogfVxyXG4gICAgICogPC9wcmU+XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFZlY3RvckxheWVyKHNwZWMpIHtcclxuICAgICAgICAvLyBjYWxsIGJhc2UgY29uc3RydWN0b3JcclxuICAgICAgICBMYXllci5jYWxsKHRoaXMsIHNwZWMpO1xyXG4gICAgICAgIC8vIHNldCByZWFzb25hYmxlIGRlZmF1bHRzXHJcbiAgICAgICAgdGhpcy56SW5kZXggPSBzcGVjLnpJbmRleCB8fCA3NDk7XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSBzcGVjLmRvbWFpbiB8fCBcInZlY3RvclwiO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc3BlYy5zb3VyY2U7XHJcbiAgICAgICAgdGhpcy5zdHlsZU1hcCA9IHNwZWMuc3R5bGVNYXA7XHJcbiAgICAgICAgdGhpcy5zdHJhdGVnaWVzID0gc3BlYy5zdHJhdGVnaWVzO1xyXG4gICAgICAgIHRoaXMuZ2V0RGF0YSA9IHNwZWMuZ2V0RGF0YTtcclxuICAgICAgICB0aGlzLnRlYXJkb3duID0gc3BlYy50ZWFyZG93bjtcclxuICAgICAgICB0aGlzLm9sRmVhdHVyZXMgPSBzcGVjLm9sRmVhdHVyZXMgfHwgW107XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IHNwZWMuZ3JvdXAgfHwgXCJcIjtcclxuICAgIH1cclxuXHJcbiAgICBWZWN0b3JMYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExheWVyLnByb3RvdHlwZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIGxheWVyIG9iamVjdC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG4gICAgICogQG1lbWJlcm9mIFZlY3RvckxheWVyXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBWZWN0b3JMYXllci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbGF5ZXJTcGVjID0ge307XHJcbiAgICAgICAgaWYgKCB0aGlzLnN0cmF0ZWdpZXMgKSB7XHJcbiAgICAgICAgICAgIGxheWVyU3BlYy5zdHJhdGVnaWVzID0gdGhpcy5zdHJhdGVnaWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIHRoaXMuc3R5bGVNYXAgKSB7XHJcbiAgICAgICAgICAgIGxheWVyU3BlYy5zdHlsZU1hcCA9IHRoaXMuc3R5bGVNYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub2xMYXllciA9IG5ldyBPcGVuTGF5ZXJzLkxheWVyLlZlY3RvcihcIlZlY3RvciBMYXllclwiLCBsYXllclNwZWMpO1xyXG4gICAgICAgIHRoaXMuc2V0RW5hYmxlZCggdGhpcy5pc0VuYWJsZWQoKSApO1xyXG4gICAgICAgIHRoaXMuc2V0T3BhY2l0eSggdGhpcy5nZXRPcGFjaXR5KCkgKTtcclxuICAgICAgICB0aGlzLnNldEJyaWdodG5lc3MoIHRoaXMuZ2V0QnJpZ2h0bmVzcygpICk7XHJcbiAgICAgICAgdGhpcy5zZXRDb250cmFzdCggdGhpcy5nZXRDb250cmFzdCgpICk7XHJcbiAgICAgICAgdGhpcy5zZXRUaGVtZSggdGhpcy5tYXAuZ2V0VGhlbWUoKSApO1xyXG4gICAgICAgIC8vIHB1Ymxpc2ggYWN0aXZhdGUgZXZlbnQgYmVmb3JlIGFwcGVuZGluZyB0byBtYXBcclxuICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICdhY3RpdmF0ZScsIHZhbHVlOiB0cnVlIH0gKTtcclxuICAgICAgICB0aGlzLm1hcC5vbE1hcC5hZGRMYXllciggdGhpcy5vbExheWVyICk7XHJcbiAgICAgICAgaWYgKCB0aGlzLmdldERhdGEgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0RGF0YSggdGhpcyApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIHRoaXMub2xGZWF0dXJlcyApIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRGZWF0dXJlcyggdGhpcy5vbEZlYXR1cmVzICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0WkluZGV4KCB0aGlzLnpJbmRleCApO1xyXG4gICAgICAgIC8vIHB1Ymxpc2ggYWRkIGV2ZW50XHJcbiAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnYWRkJywgdmFsdWU6IHRydWUgfSApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY3RpdmF0ZXMgdGhlIGxheWVyIG9iamVjdC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG4gICAgICogQG1lbWJlcm9mIFZlY3RvckxheWVyXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBWZWN0b3JMYXllci5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRlYXJkb3duKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGVhcmRvd24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub2xMYXllcikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vbExheWVyLnN0cmF0ZWdpZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2xMYXllci5zdHJhdGVnaWVzLmZvckVhY2goZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJhdGVneS5kZWFjdGl2YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm9sTGF5ZXIuc3RyYXRlZ2llcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5vbE1hcC5yZW1vdmVMYXllcih0aGlzLm9sTGF5ZXIpO1xyXG4gICAgICAgICAgICBQdWJTdWIucHVibGlzaCggdGhpcy5nZXRDaGFubmVsKCksIHsgZmllbGQ6ICdyZW1vdmUnLCB2YWx1ZTogdHJ1ZSB9ICk7XHJcbiAgICAgICAgICAgIHRoaXMub2xMYXllci5kZXN0cm95RmVhdHVyZXMoKTtcclxuICAgICAgICAgICAgdGhpcy5vbExheWVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5vbExheWVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgUHViU3ViLnB1Ymxpc2goIHRoaXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnZGVhY3RpdmF0ZScsIHZhbHVlOiB0cnVlIH0gKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYWxsIGZlYXR1cmVzIGZyb20gdGhlIGxheWVyIGFuZCBhZGQgdGhlIG5ldyBmZWF0dXJlc1xyXG4gICAgICogcGFzc2VkIGluXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmVhdHVyZXNUb0FkZCAtIEFycmF5IG9mIE9wZW5MYXllcnMgRmVhdHVyZXNcclxuICAgICAqL1xyXG4gICAgVmVjdG9yTGF5ZXIucHJvdG90eXBlLnNldEZlYXR1cmVzID0gZnVuY3Rpb24oZmVhdHVyZXNUb0FkZCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9sTGF5ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5vbExheWVyLmRlc3Ryb3lGZWF0dXJlcygpO1xyXG4gICAgICAgICAgICB0aGlzLm9sRmVhdHVyZXMgPSBmZWF0dXJlc1RvQWRkO1xyXG4gICAgICAgICAgICB0aGlzLm9sTGF5ZXIuYWRkRmVhdHVyZXMoZmVhdHVyZXNUb0FkZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHRoZW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgVmVjdG9yTGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGhlbWUgLSBUaGUgdGhlbWUgaWRlbnRpZmllciBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIFZlY3RvckxheWVyLnByb3RvdHlwZS5zZXRUaGVtZSA9IGZ1bmN0aW9uKHRoZW1lKSB7XHJcbiAgICAgICAgdGhpcy50aGVtZSA9IHRoZW1lO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY3VycmVudCB0aGVtZSBmb3IgdGhlIGxheWVyLlxyXG4gICAgICogQG1lbWJlcm9mIFZlY3RvckxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHRoZW1lIGlkZW50aWZpZXIgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBWZWN0b3JMYXllci5wcm90b3R5cGUuZ2V0VGhlbWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aGVtZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHogaW5kZXggb2YgdGhlIGxheWVyLlxyXG4gICAgICogQG1lbWJlcm9mIFZlY3RvckxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSB6SW5kZXggLSBUaGUgbmV3IHotb3JkZXIgdmFsdWUgb2YgdGhlIGxheWVyLCB3aGVyZSAwIGlzIGZyb250LlxyXG4gICAgICovXHJcbiAgICBWZWN0b3JMYXllci5wcm90b3R5cGUuc2V0WkluZGV4ID0gZnVuY3Rpb24oekluZGV4KSB7XHJcbiAgICAgICAgLy8gd2UgYnktcGFzcyB0aGUgT3BlbkxheWVycy5NYXAuc2V0TGF5ZXJJbmRleCgpIG1ldGhvZCBhbmQgbWFudWFsbHlcclxuICAgICAgICAvLyBzZXQgdGhlIHotaW5kZXggb2YgdGhlIGxheWVyIGRldi4gc2V0TGF5ZXJJbmRleCBzZXRzIGEgcmVsYXRpdmVcclxuICAgICAgICAvLyBpbmRleCBiYXNlZCBvbiBjdXJyZW50IG1hcCBsYXllcnMsIHdoaWNoIHRoZW4gc2V0cyBhIHotaW5kZXguIFRoaXNcclxuICAgICAgICAvLyBjYXVzZWQgaXNzdWVzIHdpdGggYXN5bmMgbGF5ZXIgbG9hZGluZy5cclxuICAgICAgICB0aGlzLnpJbmRleCA9IHpJbmRleDtcclxuICAgICAgICBpZiAodGhpcy5vbExheWVyKSB7XHJcbiAgICAgICAgICAgICQodGhpcy5vbExheWVyLmRpdikuY3NzKCd6LWluZGV4JywgekluZGV4KTtcclxuICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2godGhpcy5nZXRDaGFubmVsKCksIHtcclxuICAgICAgICAgICAgICAgIGZpZWxkOiAnekluZGV4JyxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB6SW5kZXhcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbGF5ZXJzIHpJbmRleC5cclxuICAgICAqIEBtZW1iZXJvZiBWZWN0b3JMYXllclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgekluZGV4IGZvciB0aGUgbGF5ZXIuXHJcbiAgICAgKi9cclxuICAgIFZlY3RvckxheWVyLnByb3RvdHlwZS5nZXRaSW5kZXggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy56SW5kZXg7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gVmVjdG9yTGF5ZXI7XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMyBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgUmVuZGVyZXIgPSByZXF1aXJlKCcuL1JlbmRlcmVyJyksXHJcbiAgICAgICAgUmVuZGVyZXJVdGlsID0gcmVxdWlyZSgnLi9SZW5kZXJlclV0aWwnKSxcclxuICAgICAgICBpbmplY3RDc3MsXHJcbiAgICAgICAgZ2V0TGFiZWxXaWR0aCxcclxuICAgICAgICBjYXBpdGFsaXplO1xyXG5cclxuICAgIGluamVjdENzcyA9IGZ1bmN0aW9uKCBzcGVjICkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmICggc3BlYy50ZXh0LnRoZW1lcyApIHtcclxuICAgICAgICAgICAgZm9yICggaT0wOyBpPHNwZWMudGV4dC50aGVtZXMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICBzcGVjLnRleHQudGhlbWVzW2ldLmluamVjdFRoZW1lKHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogXCIubm9kZS1sYWJlbFwiXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwaXhlbCB3aWR0aCBvZiB0aGUgbGFiZWxcclxuICAgICAqL1xyXG4gICAgIGdldExhYmVsV2lkdGggPSBmdW5jdGlvbiggc3RyLCBmb250U2l6ZSApIHtcclxuICAgICAgICB2YXIgJHRlbXAsXHJcbiAgICAgICAgICAgIHdpZHRoO1xyXG4gICAgICAgICR0ZW1wID0gJCgnPGRpdiBjbGFzcz1cIm5vZGUtbGFiZWxcIiBzdHlsZT1cImZvbnQtc2l6ZTonK2ZvbnRTaXplKydweDsgcGFkZGluZy1sZWZ0OjVweDsgcGFkZGluZy1yaWdodDo1cHg7XCI+JytzdHIrJzwvZGl2PicpO1xyXG4gICAgICAgICQoJ2JvZHknKS5hcHBlbmQoICR0ZW1wICk7XHJcbiAgICAgICAgd2lkdGggPSAkdGVtcC5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgJHRlbXAucmVtb3ZlKCk7XHJcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhcGl0YWxpemVzIHRoZSBnaXZlbiB3b3JkLlxyXG4gICAgICovXHJcbiAgICBjYXBpdGFsaXplID0gZnVuY3Rpb24oIHN0ciApIHtcclxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyg/Ol58LHxcXHMpXFxTL2csIGZ1bmN0aW9uKCBhICkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbnRpYXRlIGEgR3JhcGhMYWJlbFJlbmRlcmVyIG9iamVjdC5cclxuICAgICAqIEBjbGFzcyBHcmFwaExhYmVsUmVuZGVyZXJcclxuICAgICAqIEBhdWdtZW50cyBSZW5kZXJlclxyXG4gICAgICogQGNsYXNzRGVzYyBBIFJlbmRlcmVyIGltcGxlbWVudGF0aW9uIHRoYXQgcmVuZGVycyBhIHNldCBvZiBncmFwaCBsYWJlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNwZWMge09iamVjdH0gVGhlIHNwZWNpZmljYXRpb24gb2JqZWN0LlxyXG4gICAgICogPHByZT5cclxuICAgICAqIHtcclxuICAgICAqICAgICB0ZXh0OiB7XHJcbiAgICAgKiAgICAgICAgIHhLZXkgICB7U3RyaW5nfEZ1bmN0aW9ufSAtIFRoZSBhdHRyaWJ1dGUgZm9yIHRoZSB4IGNvb3JkaW5hdGUuXHJcbiAgICAgKiAgICAgICAgIHlLZXkgICB7U3RyaW5nfEZ1bmN0aW9ufSAtIFRoZSBhdHRyaWJ1dGUgZm9yIHRoZSB5IGNvb3JkaW5hdGUuXHJcbiAgICAgKiAgICAgICAgIHRoZW1lcyB7QXJyYXl9ICAtIFRoZSBhcnJheSBvZiBSZW5kZXJUaGVtZXMgdG8gYmUgYXR0YWNoZWQgdG8gdGhpcyBjb21wb25lbnQuXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfVxyXG4gICAgICogPC9wcmU+XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEdyYXBoTGFiZWxSZW5kZXJlciggc3BlYyApIHtcclxuICAgICAgICBzcGVjLnJvb3RLZXkgPSBzcGVjLnJvb3RLZXkgfHwgXCJ0aWxlLnZhbHVlc1swXS52YWx1ZVswXS5jb21tdW5pdGllc1wiO1xyXG4gICAgICAgIFJlbmRlcmVyLmNhbGwoIHRoaXMsIHNwZWMgKTtcclxuICAgICAgICBpbmplY3RDc3MoIHRoaXMuc3BlYyApO1xyXG4gICAgfVxyXG5cclxuICAgIEdyYXBoTGFiZWxSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSZW5kZXJlci5wcm90b3R5cGUgKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEltcGxlbWVudGF0aW9uIHNwZWNpZmljIHJlbmRlcmluZyBmdW5jdGlvbi5cclxuICAgICAqIEBtZW1iZXJvZiBHcmFwaExhYmVsUmVuZGVyZXJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgcmF3IGRhdGEgZm9yIGEgdGlsZSB0byBiZSByZW5kZXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7e2h0bWw6IHN0cmluZywgZW50cmllczogQXJyYXl9fSBUaGUgaHRtbCB0byByZW5kZXIgYW5kIGFuIGFycmF5IG9mIGFsbCByZW5kZXJlZCBkYXRhIGVudHJpZXMuXHJcbiAgICAgKi9cclxuICAgIEdyYXBoTGFiZWxSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oIGRhdGEgKSB7XHJcblxyXG4gICAgICAgIHZhciBHUkFQSF9DT09SRF9SQU5HRSA9IDI1NixcclxuICAgICAgICAgICAgdGV4dCA9IHRoaXMuc3BlYy50ZXh0LFxyXG4gICAgICAgICAgICBsZXZlbE1pbk1heCA9IHRoaXMucGFyZW50LmdldExldmVsTWluTWF4KCksXHJcbiAgICAgICAgICAgIGNvbW11bml0aWVzID0gUmVuZGVyZXJVdGlsLmdldEF0dHJpYnV0ZVZhbHVlKCBkYXRhLCB0aGlzLnNwZWMucm9vdEtleSApLFxyXG4gICAgICAgICAgICBzY2FsZSA9IE1hdGgucG93KCAyLCB0aGlzLnBhcmVudC5tYXAuZ2V0Wm9vbSgpICksXHJcbiAgICAgICAgICAgIHJhbmdlID0gIEdSQVBIX0NPT1JEX1JBTkdFIC8gc2NhbGUsXHJcbiAgICAgICAgICAgIGxhYmVsSW5kZXggPSAoIHRleHQubGFiZWxJbmRleCAhPT0gdW5kZWZpbmVkICkgPyB0ZXh0LmxhYmVsSW5kZXggOiAwLFxyXG4gICAgICAgICAgICBjb21tdW5pdHksXHJcbiAgICAgICAgICAgIGh0bWwgPSBcIlwiLFxyXG4gICAgICAgICAgICBjb3VudCxcclxuICAgICAgICAgICAgZm9udFNpemUsXHJcbiAgICAgICAgICAgIHNwbGl0LFxyXG4gICAgICAgICAgICBsYWJlbCxcclxuICAgICAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgICAgIG1pbmltdW1Db3VudCxcclxuICAgICAgICAgICAgbWF4aW11bUNvdW50LFxyXG4gICAgICAgICAgICBwZXJjZW50LFxyXG4gICAgICAgICAgICBwZXJjZW50TGFiZWwsXHJcbiAgICAgICAgICAgIGhpZXJMZXZlbCxcclxuICAgICAgICAgICAgcGFyZW50SURhcnJheSA9IFtdLFxyXG4gICAgICAgICAgICBlbnRyaWVzID0gW10sXHJcbiAgICAgICAgICAgIHgsIHksIGk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgLy8gZ2V0IGdyYXBoIGhpZXJhcmNoeSBsZXZlbCBmb3IgdGhpcyB6b29tIGxldmVsXHJcbiAgICAgICAgLy8gYXNzdW1lcyBzYW1lIGhpZXJhcmNoeSBsZXZlbCBmb3IgYWxsIHRpbGVzIGF0IGEgZ2l2ZW4gem9vbSBsZXZlbFxyXG4gICAgICAgIGhpZXJMZXZlbCA9IGxldmVsTWluTWF4Lm1heGltdW0uY29tbXVuaXRpZXNbMF0uaGllckxldmVsO1xyXG5cclxuICAgICAgICAvLyBpZiBoaWVyTGV2ZWwgPSAwLCBub3JtYWxpemUgbGFiZWwgYXR0cmlidXRlcyBieSBjb21tdW5pdHkgZGVncmVlXHJcbiAgICAgICAgLy8gZWxzZSBub3JtYWxpemUgbGFiZWwgYXR0cmlidXRlcyBieSBudW0gaW50ZXJuYWwgbm9kZXNcclxuICAgICAgICBpZiAoIGhpZXJMZXZlbCA9PT0gMCApIHtcclxuICAgICAgICAgICAgbWluaW11bUNvdW50ID0gIGxldmVsTWluTWF4Lm1pbmltdW0uY29tbXVuaXRpZXNbMF0uZGVncmVlO1xyXG4gICAgICAgICAgICBtYXhpbXVtQ291bnQgPSAgbGV2ZWxNaW5NYXgubWF4aW11bS5jb21tdW5pdGllc1swXS5kZWdyZWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWluaW11bUNvdW50ID0gIGxldmVsTWluTWF4Lm1pbmltdW0uY29tbXVuaXRpZXNbMF0ubnVtTm9kZXM7XHJcbiAgICAgICAgICAgIG1heGltdW1Db3VudCA9ICBsZXZlbE1pbk1heC5tYXhpbXVtLmNvbW11bml0aWVzWzBdLm51bU5vZGVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggaT0wOyBpPGNvbW11bml0aWVzLmxlbmd0aDsgaSsrICkge1xyXG5cclxuICAgICAgICAgICAgY29tbXVuaXR5ID0gY29tbXVuaXRpZXNbaV07XHJcblxyXG4gICAgICAgICAgICAvLyBjYXBpdGFsaXplIGxhYmVsIGFycmF5LCBzcGxpdCBieSBjb21tYVxyXG4gICAgICAgICAgICBzcGxpdCA9IGNvbW11bml0eS5tZXRhZGF0YS5zcGxpdChcIixcIik7XHJcbiAgICAgICAgICAgIC8vIGRvbid0IGRyYXcgbGFiZWxzIGZvciBpc29sYXRlZCBjb21tdW5pdGllc1xyXG4gICAgICAgICAgICAvLyBhbmQgZG9uJ3QgcmVuZGVyIGlmIGxhYmVsIHN0cmluZyBpcyBlbXB0eVxyXG4gICAgICAgICAgICAvLyBvbmx5IGRyYXcgb25lIGxhYmVsIHBlciBwYXJlbnQgY29tbXVuaXR5IHBlciB0aWxlXHJcbiAgICAgICAgICAgIC8vIG9ubHkgZHJhdyB1cCB0byA1IGxhYmVscyBwZXIgdGlsZVxyXG4gICAgICAgICAgICBpZiAoIGNvbW11bml0eS5kZWdyZWUgPT09IDAgfHxcclxuICAgICAgICAgICAgICAgICBzcGxpdFsgbGFiZWxJbmRleCBdID09PSBcIlwiIHx8XHJcbiAgICAgICAgICAgICAgICAgcGFyZW50SURhcnJheS5sZW5ndGggPj0gNSB8fFxyXG4gICAgICAgICAgICAgICAgIHBhcmVudElEYXJyYXkuaW5kZXhPZiggY29tbXVuaXR5LnBhcmVudElEICkgIT09IC0xICkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2tpcCB0aGlzIGxhYmVsIGVudHJ5XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGFkZCB0aGlzIHBhcmVudCBJRCB0byB0aGUgbGlzdCwgYW5kIGRyYXcgdGhlIGxhYmVsIChiZWxvd1xyXG4gICAgICAgICAgICAgICAgcGFyZW50SURhcnJheS5wdXNoKCBjb21tdW5pdHkucGFyZW50SUQgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gYWRkIHRvIGVudHJpZXMgb25seSBpZiB0aGVyZSBpcyBhIGxlZ2libGUgbGFiZWxcclxuICAgICAgICAgICAgZW50cmllcy5wdXNoKCBjb21tdW5pdHkgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGdldCBsYWJlbCBwb3NpdGlvblxyXG4gICAgICAgICAgICB4ID0gKCBjb21tdW5pdHlbIHRleHQueEtleSBdICUgcmFuZ2UgKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICB5ID0gKCBjb21tdW5pdHlbIHRleHQueUtleSBdICUgcmFuZ2UgKSAqIHNjYWxlO1xyXG5cclxuICAgICAgICAgICAgLy8gY2FwaXRhbGl6ZSBsYWJlbFxyXG4gICAgICAgICAgICBsYWJlbCA9IGNhcGl0YWxpemUoIHNwbGl0WyBsYWJlbEluZGV4IF0udG9Mb3dlckNhc2UoKSApO1xyXG5cclxuICAgICAgICAgICAgLy8gZ2V0IGZvbnQgc2NhbGUgYmFzZWQgb24gaGllcmFyY2h5IGxldmVsXHJcbiAgICAgICAgICAgIGNvdW50ID0gKCBoaWVyTGV2ZWwgPT09IDAgKSA/IGNvbW11bml0eS5kZWdyZWUgOiBjb21tdW5pdHkubnVtTm9kZXM7XHJcbiAgICAgICAgICAgIGZvbnRTaXplID0gUmVuZGVyZXJVdGlsLmdldEZvbnRTaXplKFxyXG4gICAgICAgICAgICAgICAgY291bnQsIG1pbmltdW1Db3VudCwgbWF4aW11bUNvdW50LCB7IHR5cGU6J2xvZycgfSApO1xyXG5cclxuICAgICAgICAgICAgLy8gY2FsYyBwZXJjZW50IGxhYmVsXHJcbiAgICAgICAgICAgIHBlcmNlbnQgPSBSZW5kZXJlclV0aWwudHJhbnNmb3JtVmFsdWUoIGNvdW50LCBtaW5pbXVtQ291bnQsIG1heGltdW1Db3VudCwgJ2xvZycgKTtcclxuICAgICAgICAgICAgcGVyY2VudExhYmVsID0gTWF0aC5yb3VuZCggKCBwZXJjZW50KjEwMCApIC8gMTAgKSAqIDEwO1xyXG5cclxuICAgICAgICAgICAgLy8gY2FsYyB3aWR0aCBmb3IgY2VudGVyaW5nXHJcbiAgICAgICAgICAgIHdpZHRoID0gZ2V0TGFiZWxXaWR0aCggbGFiZWwsIGZvbnRTaXplICk7XHJcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5taW4oIHdpZHRoLCAyMDAgKTtcclxuXHJcbiAgICAgICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJub2RlLWxhYmVsIG5vZGUtbGFiZWwtJytwZXJjZW50TGFiZWwrJ1wiIHN0eWxlPVwiJ1xyXG4gICAgICAgICAgICAgICAgKyAnbGVmdDonK3grJ3B4OydcclxuICAgICAgICAgICAgICAgICsgJ2JvdHRvbTonK3krJ3B4OydcclxuICAgICAgICAgICAgICAgICsgJ2ZvbnQtc2l6ZTonICsgZm9udFNpemUgKyAncHg7J1xyXG4gICAgICAgICAgICAgICAgKyAnbGluZS1oZWlnaHQ6JyArIGZvbnRTaXplICsgJ3B4OydcclxuICAgICAgICAgICAgICAgICsgJ3dpZHRoOicgKyB3aWR0aCArICdweDsnXHJcbiAgICAgICAgICAgICAgICArICdtYXJnaW4tbGVmdDonICsgKC13aWR0aC8yKSArICdweDsnXHJcbiAgICAgICAgICAgICAgICArICdtYXJnaW4tdG9wOicgKyAoLWZvbnRTaXplLzIpICsgJ3B4OydcclxuICAgICAgICAgICAgICAgICsgJ2hlaWdodDonICsgZm9udFNpemUgKyAncHg7J1xyXG4gICAgICAgICAgICAgICAgKyAnei1pbmRleDonICsgTWF0aC5mbG9vciggZm9udFNpemUgKSArICc7J1xyXG4gICAgICAgICAgICAgICAgKyAnXCI+JytsYWJlbCsnPC9kaXY+JztcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGh0bWw6IGh0bWwsXHJcbiAgICAgICAgICAgIGVudHJpZXM6IGVudHJpZXNcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdyYXBoTGFiZWxSZW5kZXJlcjtcclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDEzIE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xyXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cclxuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBSZW5kZXJlciA9IHJlcXVpcmUoJy4vUmVuZGVyZXInKSxcclxuICAgICAgICBSZW5kZXJlclV0aWwgPSByZXF1aXJlKCcuL1JlbmRlcmVyVXRpbCcpLFxyXG4gICAgICAgIGluamVjdENzcztcclxuXHJcbiAgICBpbmplY3RDc3MgPSBmdW5jdGlvbiggc3BlYyApIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoIHNwZWMubm9kZS50aGVtZXMgKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGVjLm5vZGUudGhlbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzcGVjLm5vZGUudGhlbWVzW2ldLmluamVjdFRoZW1lKHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogXCIuY29tbXVuaXR5LW5vZGVcIlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCBzcGVjLmNyaXRpY2FsTm9kZS50aGVtZXMgKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGVjLmNyaXRpY2FsTm9kZS50aGVtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHNwZWMuY3JpdGljYWxOb2RlLnRoZW1lc1tpXS5pbmplY3RUaGVtZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IFwiLmNvbW11bml0eS1ub2RlLmNvbW11bml0eS1jcml0aWNhbC1ub2RlXCJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggc3BlYy5wYXJlbnROb2RlLnRoZW1lcyApIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwZWMucGFyZW50Tm9kZS50aGVtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHNwZWMucGFyZW50Tm9kZS50aGVtZXNbaV0uaW5qZWN0VGhlbWUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBcIi5jb21tdW5pdHktcGFyZW50LW5vZGVcIlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGUgYSBHcmFwaE5vZGVSZW5kZXJlciBvYmplY3QuXHJcbiAgICAgKiBAY2xhc3MgR3JhcGhOb2RlUmVuZGVyZXJcclxuICAgICAqIEBhdWdtZW50cyBSZW5kZXJlclxyXG4gICAgICogQGNsYXNzRGVzYyBBIFJlbmRlcmVyIGltcGxlbWVudGF0aW9uIHRoYXQgcmVuZGVycyBhIHNldCBvZiBncmFwaCBub2Rlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3BlYyB7T2JqZWN0fSBUaGUgc3BlY2lmaWNhdGlvbiBvYmplY3QuXHJcbiAgICAgKiA8cHJlPlxyXG4gICAgICoge1xyXG4gICAgICogICAgIG5vZGU6IHtcclxuICAgICAqICAgICAgICAgeEtleSAgICAgIHtTdHJpbmd8RnVuY3Rpb259IC0gVGhlIGF0dHJpYnV0ZSBmb3IgdGhlIHggY29vcmRpbmF0ZS5cclxuICAgICAqICAgICAgICAgeUtleSAgICAgIHtTdHJpbmd8RnVuY3Rpb259IC0gVGhlIGF0dHJpYnV0ZSBmb3IgdGhlIHkgY29vcmRpbmF0ZS5cclxuICAgICAqICAgICAgICAgcmFkaXVzS2V5IHtTdHJpbmd8RnVuY3Rpb259IC0gVGhlIGF0dHJpYnV0ZSBmb3IgdGhlIG5vZGUgcmFkaXVzLlxyXG4gICAgICogICAgICAgICB0aGVtZXMgICAge0FycmF5fSAgIFRoZSBhcnJheSBvZiBSZW5kZXJUaGVtZXMgdG8gYmUgYXR0YWNoZWQgdG8gdGhpcyBjb21wb25lbnQuXHJcbiAgICAgKiAgICAgfSxcclxuICAgICAqICAgICBjcml0aWNhbE5vZGU6IHtcclxuICAgICAqICAgICAgICAgZmxhZyAgICAge1N0cmluZ3xGdW5jdGlvbn0gLSBUaGUgYm9vbGVhbiBhdHRyaWJ1dGUgdG8gZGVzaWduYXRlIGNyaXRpY2FsIG5vZGVzLlxyXG4gICAgICogICAgICAgICB0aGVtZXMgICB7QXJyYXl9ICAtIFRoZSBhcnJheSBvZiBSZW5kZXJUaGVtZXMgdG8gYmUgYXR0YWNoZWQgdG8gdGhpcyBjb21wb25lbnQuXHJcbiAgICAgKiAgICAgfSxcclxuICAgICAqICAgICBwYXJlbnROb2RlOiB7XHJcbiAgICAgKiAgICAgICAgIHhLZXkgICAgICB7U3RyaW5nfEZ1bmN0aW9ufSAtIFRoZSBhdHRyaWJ1dGUgZm9yIHRoZSBwYXJlbnQgbm9kZSB4IGNvb3JkaW5hdGUuXHJcbiAgICAgKiAgICAgICAgIHlLZXkgICAgICB7U3RyaW5nfEZ1bmN0aW9ufSAtIFRoZSBhdHRyaWJ1dGUgZm9yIHRoZSBwYXJlbnQgbm9kZSB5IGNvb3JkaW5hdGUuXHJcbiAgICAgKiAgICAgICAgIHJhZGl1c0tleSB7U3RyaW5nfEZ1bmN0aW9ufSAtIFRoZSBhdHRyaWJ1dGUgZm9yIHRoZSBub2RlIHJhZGl1cy5cclxuICAgICAqICAgICAgICAgdGhlbWVzICAgIHtBcnJheX0gIC0gVGhlIGFycmF5IG9mIFJlbmRlclRoZW1lcyB0byBiZSBhdHRhY2hlZCB0byB0aGlzIGNvbXBvbmVudC5cclxuICAgICAqICAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gR3JhcGhOb2RlUmVuZGVyZXIoIHNwZWMgKSB7XHJcbiAgICAgICAgc3BlYy5yb290S2V5ID0gc3BlYy5yb290S2V5IHx8IFwidGlsZS52YWx1ZXNbMF0udmFsdWVbMF0uY29tbXVuaXRpZXNcIjtcclxuICAgICAgICBzcGVjLm5vZGUgPSBzcGVjLm5vZGUgfHwge307XHJcbiAgICAgICAgc3BlYy5ub2RlLnhLZXkgPSBzcGVjLm5vZGUueEtleSB8fCAneCc7XHJcbiAgICAgICAgc3BlYy5ub2RlLnlLZXkgPSBzcGVjLm5vZGUueUtleSB8fCAneSc7XHJcbiAgICAgICAgc3BlYy5ub2RlLnJhZGl1c0tleSA9IHNwZWMubm9kZS5yYWRpdXNLZXkgfHwgJ3InO1xyXG4gICAgICAgIHNwZWMucGFyZW50Tm9kZSA9IHNwZWMucGFyZW50Tm9kZSB8fCB7fTtcclxuICAgICAgICBzcGVjLnBhcmVudE5vZGUueEtleSA9IHNwZWMucGFyZW50Tm9kZS54S2V5IHx8ICdwYXJlbnRYJztcclxuICAgICAgICBzcGVjLnBhcmVudE5vZGUueUtleSA9IHNwZWMucGFyZW50Tm9kZS55S2V5IHx8ICdwYXJlbnRZJztcclxuICAgICAgICBzcGVjLnBhcmVudE5vZGUucmFkaXVzS2V5ID0gc3BlYy5wYXJlbnROb2RlLnJhZGl1c0tleSB8fCAncGFyZW50Uic7XHJcbiAgICAgICAgc3BlYy5jcml0aWNhbE5vZGUgPSBzcGVjLmNyaXRpY2FsTm9kZSB8fCB7fTtcclxuICAgICAgICBzcGVjLmNyaXRpY2FsTm9kZS5mbGFnID0gc3BlYy5jcml0aWNhbE5vZGUuZmxhZyB8fCAnaXNQcmltYXJ5Tm9kZSc7XHJcbiAgICAgICAgUmVuZGVyZXIuY2FsbCggdGhpcywgc3BlYyApO1xyXG4gICAgICAgIGluamVjdENzcyggdGhpcy5zcGVjICk7XHJcbiAgICB9XHJcblxyXG4gICAgR3JhcGhOb2RlUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUmVuZGVyZXIucHJvdG90eXBlICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyByZW5kZXJpbmcgZnVuY3Rpb24uXHJcbiAgICAgKiBAbWVtYmVyb2YgR3JhcGhOb2RlUmVuZGVyZXJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgcmF3IGRhdGEgZm9yIGEgdGlsZSB0byBiZSByZW5kZXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7e2h0bWw6IHN0cmluZywgZW50cmllczogQXJyYXl9fSBUaGUgaHRtbCB0byByZW5kZXIgYW5kIGFuIGFycmF5IG9mIGFsbCByZW5kZXJlZCBkYXRhIGVudHJpZXMuXHJcbiAgICAgKi9cclxuICAgIEdyYXBoTm9kZVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiggZGF0YSApIHtcclxuXHJcbiAgICAgICAgdmFyIEdSQVBIX0NPT1JEX1JBTkdFID0gMjU2LFxyXG4gICAgICAgICAgICBCT1JERVJfV0lEVEggPSAyLFxyXG4gICAgICAgICAgICBzcGVjID0gdGhpcy5zcGVjLFxyXG4gICAgICAgICAgICBjb21tdW5pdGllcyA9IFJlbmRlcmVyVXRpbC5nZXRBdHRyaWJ1dGVWYWx1ZSggZGF0YSwgc3BlYy5yb290S2V5ICksXHJcbiAgICAgICAgICAgIHNjYWxlID0gTWF0aC5wb3coIDIsIHRoaXMucGFyZW50Lm1hcC5nZXRab29tKCkgKSxcclxuICAgICAgICAgICAgcmFuZ2UgPSAgR1JBUEhfQ09PUkRfUkFOR0UgLyBzY2FsZSxcclxuICAgICAgICAgICAgY2xhc3NOYW1lLFxyXG4gICAgICAgICAgICBjb21tdW5pdHksXHJcbiAgICAgICAgICAgIHJhZGl1cyxcclxuICAgICAgICAgICAgZGlhbWV0ZXIsXHJcbiAgICAgICAgICAgIHBhcmVudFJhZGl1cyxcclxuICAgICAgICAgICAgcGFyZW50RGlhbWV0ZXIsXHJcbiAgICAgICAgICAgIGh0bWwgPSAnJyxcclxuICAgICAgICAgICAgZW50cmllcyA9IFtdLFxyXG4gICAgICAgICAgICBpLCB4LCB5LCBweCwgcHk7XHJcblxyXG4gICAgICAgIGZvciAoIGk9MDsgaTxjb21tdW5pdGllcy5sZW5ndGg7IGkrKyApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbW11bml0eSA9IGNvbW11bml0aWVzW2ldO1xyXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goIGNvbW11bml0eSApO1xyXG5cclxuICAgICAgICAgICAgLy8gZ2V0IG5vZGUgcG9zaXRpb24sIHJhZGl1cywgYW5kIGRpYW1ldGVyXHJcbiAgICAgICAgICAgIHggPSAoIGNvbW11bml0eVsgc3BlYy5ub2RlLnhLZXkgXSAlIHJhbmdlICkgKiBzY2FsZTtcclxuICAgICAgICAgICAgeSA9ICggY29tbXVuaXR5WyBzcGVjLm5vZGUueUtleSBdICUgcmFuZ2UgKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICByYWRpdXMgPSBjb21tdW5pdHlbIHNwZWMubm9kZS5yYWRpdXNLZXkgXSAqIHNjYWxlO1xyXG4gICAgICAgICAgICBkaWFtZXRlciA9IHJhZGl1cyoyO1xyXG5cclxuICAgICAgICAgICAgLy8gZG9uJ3QgZHJhdyBub2RlIGlmIHJhZGl1cyA8IDFcclxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgaXMgYW4gaXNvbGF0ZWQgY29tbXVuaXR5XHJcbiAgICAgICAgICAgIGlmICggcmFkaXVzIDwgMSB8fCBjb21tdW5pdHkuZGVncmVlID09PSAwICkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggY29tbXVuaXR5WyBzcGVjLmNyaXRpY2FsTm9kZS5mbGFnIF0gKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSAnY29tbXVuaXR5LW5vZGUgY29tbXVuaXR5LWNyaXRpY2FsLW5vZGUnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gJ2NvbW11bml0eS1ub2RlJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gZHJhdyBub2RlXHJcbiAgICAgICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCInK2NsYXNzTmFtZSsnXCIgc3R5bGU9XCInXHJcbiAgICAgICAgICAgICAgICAgICsgJ2hlaWdodDonK2RpYW1ldGVyKydweDsnXHJcbiAgICAgICAgICAgICAgICAgICsgJ3dpZHRoOicrZGlhbWV0ZXIrJ3B4OydcclxuICAgICAgICAgICAgICAgICAgKyAnYm9yZGVyLXJhZGl1czonK2RpYW1ldGVyKydweDsnXHJcbiAgICAgICAgICAgICAgICAgICsgJ2xlZnQ6JysoeCAtIHJhZGl1cyAtIEJPUkRFUl9XSURUSCkrJ3B4OydcclxuICAgICAgICAgICAgICAgICAgKyAnYm90dG9tOicrKHkgLSByYWRpdXMgLSBCT1JERVJfV0lEVEgpKydweDsnXHJcbiAgICAgICAgICAgICAgICAgICsgJ2JvcmRlci13aWR0aDonICsgQk9SREVSX1dJRFRIICsgJ3B4OydcclxuICAgICAgICAgICAgICAgICAgKyAnXCI+PC9kaXY+JztcclxuXHJcbiAgICAgICAgICAgIC8vIG9ubHkgaGF2ZSB0aGUgY3JpdGljYWwgbm9kZSBkcmF3IHRoZSBwYXJlbnRcclxuICAgICAgICAgICAgLy8gYXNzdW1lcyB0aGVyZSBpcyBhIGNyaXRpY2FsIG5vZGUgcHJlc2VudCBpbiBhbGwgY29tbXVuaXRpZXNcclxuICAgICAgICAgICAgaWYgKCBjb21tdW5pdHlbIHNwZWMuY3JpdGljYWxOb2RlLmZsYWcgXSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBnZXQgcGFyZW50IG5vZGUgcG9zaXRpb24sIHJhZGl1cywgYW5kIGRpYW1ldGVyXHJcbiAgICAgICAgICAgICAgICBweCA9ICggY29tbXVuaXR5WyBzcGVjLnBhcmVudE5vZGUueEtleSBdICUgcmFuZ2UgKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgcHkgPSAoIGNvbW11bml0eVsgc3BlYy5wYXJlbnROb2RlLnlLZXkgXSAlIHJhbmdlICkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgIHBhcmVudFJhZGl1cyA9IGNvbW11bml0eVsgc3BlYy5wYXJlbnROb2RlLnJhZGl1c0tleSBdICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnREaWFtZXRlciA9IHBhcmVudFJhZGl1cyAqIDI7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZHJhdyBwYXJlbnQgbm9kZVxyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cImNvbW11bml0eS1wYXJlbnQtbm9kZVwiIHN0eWxlPVwiJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgKyAnaGVpZ2h0OicrcGFyZW50RGlhbWV0ZXIrJ3B4OydcclxuICAgICAgICAgICAgICAgICAgICAgICsgJ3dpZHRoOicrcGFyZW50RGlhbWV0ZXIrJ3B4OydcclxuICAgICAgICAgICAgICAgICAgICAgICsgJ2JvcmRlci1yYWRpdXM6JytwYXJlbnREaWFtZXRlcisncHg7J1xyXG4gICAgICAgICAgICAgICAgICAgICAgKyAnbGVmdDonKyhweCAtIHBhcmVudFJhZGl1cyAtIEJPUkRFUl9XSURUSCkrJ3B4OydcclxuICAgICAgICAgICAgICAgICAgICAgICsgJ2JvdHRvbTonKyhweSAtIHBhcmVudFJhZGl1cyAtIEJPUkRFUl9XSURUSCkrJ3B4OydcclxuICAgICAgICAgICAgICAgICAgICAgICsgJ2JvcmRlci13aWR0aDonICsgQk9SREVSX1dJRFRIICsgJ3B4OydcclxuICAgICAgICAgICAgICAgICAgICAgICsgJ1wiPjwvZGl2Pic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaHRtbDogaHRtbCxcclxuICAgICAgICAgICAgZW50cmllczogZW50cmllc1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JhcGhOb2RlUmVuZGVyZXI7XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMyBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgUmVuZGVyZXIgPSByZXF1aXJlKCcuL1JlbmRlcmVyJyksXHJcbiAgICAgICAgUmVuZGVyZXJVdGlsID0gcmVxdWlyZSgnLi9SZW5kZXJlclV0aWwnKSxcclxuICAgICAgICBNYXBVdGlsID0gcmVxdWlyZSgnLi4vLi4vbWFwL01hcFV0aWwnKSxcclxuICAgICAgICBpbmplY3RDc3M7XHJcblxyXG4gICAgaW5qZWN0Q3NzID0gZnVuY3Rpb24oIHNwZWMgKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKCBzcGVjLnBvaW50LnRoZW1lcyApIHtcclxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBzcGVjLnBvaW50LnRoZW1lcy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIHNwZWMucG9pbnQudGhlbWVzW2ldLmluamVjdFRoZW1lKHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogXCIucG9pbnQtYW5ub3RhdGlvbi1maWxsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50U2VsZWN0b3I6IFwiLnBvaW50LWFubm90YXRpb24tYWdncmVnYXRlXCJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggc3BlYy5hZ2dyZWdhdGUudGhlbWVzICkge1xyXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHNwZWMuYWdncmVnYXRlLnRoZW1lcy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIHNwZWMuYWdncmVnYXRlLnRoZW1lc1tpXS5pbmplY3RUaGVtZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IFwiLnBvaW50LWFubm90YXRpb24tYm9yZGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50U2VsZWN0b3I6IFwiLnBvaW50LWFubm90YXRpb24tYWdncmVnYXRlXCJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbnRpYXRlIGEgUG9pbnRBZ2dyZWdhdGVSZW5kZXJlciBvYmplY3QuXHJcbiAgICAgKiBAY2xhc3MgUG9pbnRBZ2dyZWdhdGVSZW5kZXJlclxyXG4gICAgICogQGF1Z21lbnRzIFJlbmRlcmVyXHJcbiAgICAgKiBAY2xhc3NEZXNjIEEgUmVuZGVyZXIgaW1wbGVtZW50YXRpb24gdGhhdCByZW5kZXJzIGNsdXN0ZXJzIG9mIGNpcmN1bGFyIHBvaW50cyBmb3IgZWFjaFxyXG4gICAgICogZGF0YSB2YWx1ZSBncm91cC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3BlYyB7T2JqZWN0fSBUaGUgc3BlY2lmaWNhdGlvbiBvYmplY3QuXHJcbiAgICAgKiA8cHJlPlxyXG4gICAgICoge1xyXG4gICAgICogICAgIHBvaW50OiB7XHJcbiAgICAgKiAgICAgICAgIHhLZXkgICB7U3RyaW5nfEZ1bmN0aW9ufSAtIFRoZSBhdHRyaWJ1dGUgZm9yIHRoZSB4IGNvb3JkaW5hdGUuXHJcbiAgICAgKiAgICAgICAgIHlLZXkgICB7U3RyaW5nfEZ1bmN0aW9ufSAtIFRoZSBhdHRyaWJ1dGUgZm9yIHRoZSB5IGNvb3JkaW5hdGUuXHJcbiAgICAgKiAgICAgICAgIHRoZW1lcyB7QXJyYXl9ICAtIFRoZSBhcnJheSBvZiBSZW5kZXJUaGVtZXMgdG8gYmUgYXR0YWNoZWQgdG8gdGhpcyBjb21wb25lbnQuXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICAgIGFnZ3JlZ2F0ZToge1xyXG4gICAgICogICAgICAgICB0aGVtZXMge0FycmF5fSAgLSBUaGUgYXJyYXkgb2YgUmVuZGVyVGhlbWVzIHRvIGJlIGF0dGFjaGVkIHRvIHRoaXMgY29tcG9uZW50LlxyXG4gICAgICogICAgIH1cclxuICAgICAqIH1cclxuICAgICAqIDwvcHJlPlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBQb2ludEFnZ3JlZ2F0ZVJlbmRlcmVyKCBzcGVjICkge1xyXG4gICAgICAgIHNwZWMucm9vdEtleSA9IHNwZWMucm9vdEtleSB8fCBcInRpbGUudmFsdWVzXCI7XHJcbiAgICAgICAgc3BlYy5wb2ludCA9IHNwZWMucG9pbnQgfHwge307XHJcbiAgICAgICAgc3BlYy5wb2ludC54S2V5ID0gc3BlYy5wb2ludC54S2V5IHx8ICd4JztcclxuICAgICAgICBzcGVjLnBvaW50LnlLZXkgPSBzcGVjLnBvaW50LnlLZXkgfHwgJ3knO1xyXG5cdFx0c3BlYy5wb2ludC5tYWduaXR1ZGUubWluID0gc3BlYy5wb2ludC5tYWduaXR1ZGUubWluIHx8IC0xO1xyXG5cdFx0c3BlYy5wb2ludC5tYWduaXR1ZGUubWF4ID0gc3BlYy5wb2ludC5tYWduaXR1ZGUubWF4IHx8IC0xO1xyXG4gICAgICAgIFJlbmRlcmVyLmNhbGwoIHRoaXMsIHNwZWMgKTtcclxuICAgICAgICBpbmplY3RDc3MoIHRoaXMuc3BlYyApO1xyXG4gICAgfVxyXG5cclxuICAgIFBvaW50QWdncmVnYXRlUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUmVuZGVyZXIucHJvdG90eXBlICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyByZW5kZXJpbmcgZnVuY3Rpb24uXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9pbnRBZ2dyZWdhdGVSZW5kZXJlclxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSByYXcgZGF0YSBmb3IgYSB0aWxlIHRvIGJlIHJlbmRlcmVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt7aHRtbDogc3RyaW5nLCBlbnRyaWVzOiBBcnJheX19IFRoZSBodG1sIHRvIHJlbmRlciBhbmQgYW4gYXJyYXkgb2YgYWxsIHJlbmRlcmVkIGRhdGEgZW50cmllcy5cclxuICAgICAqL1xyXG4gICAgUG9pbnRBZ2dyZWdhdGVSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oIGRhdGEgKSB7XHJcblxyXG4gICAgICAgIHZhciBzcGVjID0gdGhpcy5zcGVjLFxyXG4gICAgICAgICAgICBtYXAgPSB0aGlzLnBhcmVudC5tYXAsXHJcbiAgICAgICAgICAgIHZhbHVlcyA9IFJlbmRlcmVyVXRpbC5nZXRBdHRyaWJ1dGVWYWx1ZSggZGF0YSwgc3BlYy5yb290S2V5ICksXHJcbiAgICAgICAgICAgIHBvaW50ID0gc3BlYy5wb2ludCxcclxuICAgICAgICAgICAgZW50cmllcyA9IFtdLFxyXG4gICAgICAgICAgICBwb3NpdGlvbk1hcCA9IHt9LFxyXG4gICAgICAgICAgICBwb3NpdGlvbktleSxcclxuICAgICAgICAgICAgdGlsZWtleSxcclxuICAgICAgICAgICAgdGlsZVBvcyxcclxuICAgICAgICAgICAgaHRtbCA9ICcnLFxyXG4gICAgICAgICAgICBwb3NpdGlvbixcclxuICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgaSwgajtcclxuXHJcbiAgICAgICAgLy8gZ2V0IHRpbGVrZXlcclxuICAgICAgICB0aWxla2V5ID0gZGF0YS5pbmRleC5sZXZlbCArIFwiLFwiICsgZGF0YS5pbmRleC54SW5kZXggKyBcIixcIiArIGRhdGEuaW5kZXgueUluZGV4O1xyXG4gICAgICAgIC8vIGdldCB0aWxlIHBvc1xyXG4gICAgICAgIHRpbGVQb3MgPSBNYXBVdGlsLmdldFRvcExlZnRWaWV3cG9ydFBpeGVsRm9yVGlsZSggbWFwLCB0aWxla2V5ICk7XHJcblxyXG4gICAgICAgIC8vIGZvciBlYWNoIGJpblxyXG4gICAgICAgIGZvciAoIGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyBpKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1tpXS52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdmFsdWUubGVuZ3RoID09PSAwICkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW50cmllcy5wdXNoKCB2YWx1ZSApO1xyXG5cclxuICAgICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInBvaW50LWFubm90YXRpb24tYWdncmVnYXRlXCI+JztcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGo9MDsgajx2YWx1ZS5sZW5ndGg7IGorKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBnZXQgcG9zaXRpb24gaW4gdmlld3BvcnQgc3BhY2VcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gTWFwVXRpbC5nZXRWaWV3cG9ydFBpeGVsRnJvbUNvb3JkKCBtYXAsIHZhbHVlW2pdW3BvaW50LnhLZXldLCB2YWx1ZVtqXVtwb2ludC55S2V5XSApO1xyXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHJlbGF0aXZlIHBvc2l0aW9uIGZyb20gdGlsZSB0b3AgbGVmdFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IHBvc2l0aW9uLnggLSB0aWxlUG9zLngsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogcG9zaXRpb24ueSAtIHRpbGVQb3MueVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgY3JlYXRpbmcgdHdvIGFubm90YXRpb25zIG9uIHRoZSBleGFjdCBzYW1lIHBpeGVsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbktleSA9IE1hdGguZmxvb3IoIG9mZnNldC54ICkgKyBcIixcIiArIE1hdGguZmxvb3IoIG9mZnNldC55ICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoICFwb3NpdGlvbk1hcFsgcG9zaXRpb25LZXkgXSApIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbk1hcFsgcG9zaXRpb25LZXkgXSA9IHRydWU7XHJcblx0XHRcdFx0XHQvLyBjYWxjdWxhdGUgcHJvcGVyIGNvbG91ciBiYXNlZCBvbiBtYWduaXR1ZGUsIGlmIHByZXNlbnRcclxuXHRcdFx0XHRcdHZhciBwZXJjZW50ID0gXCJcIjtcclxuXHRcdFx0XHRcdGlmICggc3BlYy5wb2ludC5tYWduaXR1ZGUubWluID4gMCAmJiBzcGVjLnBvaW50Lm1hZ25pdHVkZS5tYXggPiAwICYmIHZhbHVlW2pdLmRhdGEubWFnbml0dWRlICkge1xyXG5cdFx0XHRcdFx0XHQvLyBnZXQgcGVyY2VudCBhbmQgcm91bmQgdXAgdG8gbmVhcmVzdCAxMFxyXG5cdFx0XHRcdFx0XHR2YXIgcGVyY2VudF92YWx1ZSA9ICgodmFsdWVbal0uZGF0YS5tYWduaXR1ZGUgLSBzcGVjLnBvaW50Lm1hZ25pdHVkZS5taW4pLyhzcGVjLnBvaW50Lm1hZ25pdHVkZS5tYXggLSBzcGVjLnBvaW50Lm1hZ25pdHVkZS5taW4pKSoxMDA7XHJcblx0XHRcdFx0XHRcdHBlcmNlbnQgPSBcIi1cIiArIE1hdGguY2VpbChwZXJjZW50X3ZhbHVlLzEwKSoxMDtcclxuXHRcdFx0XHRcdH1cclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwicG9pbnQtYW5ub3RhdGlvbiBwb2ludC1hbm5vdGF0aW9uLWZpbGwnICsgcGVyY2VudCArICdcIiBzdHlsZT1cIidcclxuICAgICAgICAgICAgICAgICAgICAgICAgICArICdsZWZ0OicgKyBvZmZzZXQueCArICdweDsnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyAndG9wOicgKyBvZmZzZXQueSArICdweDsnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnYm9yZGVyLXdpZHRoOiAycHg7XCInO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtqXS5kYXRhLmxhYmVscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9ICcgdGl0bGU9XCInICsgdmFsdWVbal0uZGF0YS5sYWJlbHMgKyAnXCInO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc+PC9kaXY+J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgJzxkaXYgY2xhc3M9XCJwb2ludC1hbm5vdGF0aW9uIHBvaW50LWFubm90YXRpb24tYm9yZGVyXCIgc3R5bGU9XCInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnbGVmdDonICsgb2Zmc2V0LnggKyAncHg7J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgJ3RvcDonICsgb2Zmc2V0LnkgKyAncHg7J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgJ2JvcmRlci13aWR0aDogMnB4XCI+PC9kaXY+JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaHRtbCArPSAnPC9kaXY+JztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaHRtbDogaHRtbCxcclxuICAgICAgICAgICAgZW50cmllczogZW50cmllc1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUG9pbnRBZ2dyZWdhdGVSZW5kZXJlcjtcclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDEzIE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xyXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cclxuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBSZW5kZXJlciA9IHJlcXVpcmUoJy4vUmVuZGVyZXInKSxcclxuICAgICAgICBSZW5kZXJlclV0aWwgPSByZXF1aXJlKCcuL1JlbmRlcmVyVXRpbCcpLFxyXG4gICAgICAgIE1hcFV0aWwgPSByZXF1aXJlKCcuLi8uLi9tYXAvTWFwVXRpbCcpLFxyXG4gICAgICAgIGluamVjdENzcztcclxuXHJcbiAgICBpbmplY3RDc3MgPSBmdW5jdGlvbiggc3BlYyApIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoIHNwZWMucG9pbnQudGhlbWVzICkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BlYy5wb2ludC50aGVtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHNwZWMucG9pbnQudGhlbWVzW2ldLmluamVjdFRoZW1lKHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogXCIucG9pbnQtYW5ub3RhdGlvblwiXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW50aWF0ZSBhIFBvaW50UmVuZGVyZXIgb2JqZWN0LlxyXG4gICAgICogQGNsYXNzIFBvaW50UmVuZGVyZXJcclxuICAgICAqIEBhdWdtZW50cyBSZW5kZXJlclxyXG4gICAgICogQGNsYXNzRGVzYyBBIFJlbmRlcmVyIGltcGxlbWVudGF0aW9uIHRoYXQgcmVuZGVycyBhIGNpcmN1bGFyIHBvaW50IGZvciBlYWNoIGRhdGFcclxuICAgICAqIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzcGVjIHtPYmplY3R9IFRoZSBzcGVjaWZpY2F0aW9uIG9iamVjdC5cclxuICAgICAqIDxwcmU+XHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgcG9pbnQ6IHtcclxuICAgICAqICAgICAgICAgeEtleSAgIHtTdHJpbmd8RnVuY3Rpb259IC0gVGhlIGF0dHJpYnV0ZSBmb3IgdGhlIHggY29vcmRpbmF0ZS5cclxuICAgICAqICAgICAgICAgeUtleSAgIHtTdHJpbmd8RnVuY3Rpb259IC0gVGhlIGF0dHJpYnV0ZSBmb3IgdGhlIHkgY29vcmRpbmF0ZS5cclxuICAgICAqICAgICAgICAgdGhlbWVzIHtBcnJheX0gIC0gVGhlIGFycmF5IG9mIFJlbmRlclRoZW1lcyB0byBiZSBhdHRhY2hlZCB0byB0aGlzIGNvbXBvbmVudC5cclxuICAgICAqICAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUG9pbnRSZW5kZXJlciggc3BlYyApIHtcclxuICAgICAgICBzcGVjLnJvb3RLZXkgPSBzcGVjLnJvb3RLZXkgfHwgXCJ0aWxlLnZhbHVlc1wiO1xyXG4gICAgICAgIHNwZWMucG9pbnQgPSBzcGVjLnBvaW50IHx8IHt9O1xyXG4gICAgICAgIHNwZWMucG9pbnQueEtleSA9IHNwZWMucG9pbnQueEtleSB8fCAneCc7XHJcbiAgICAgICAgc3BlYy5wb2ludC55S2V5ID0gc3BlYy5wb2ludC55S2V5IHx8ICd5JztcclxuICAgICAgICBSZW5kZXJlci5jYWxsKCB0aGlzLCBzcGVjICk7XHJcbiAgICAgICAgaW5qZWN0Q3NzKCB0aGlzLnNwZWMgKTtcclxuICAgIH1cclxuXHJcbiAgICBQb2ludFJlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJlbmRlcmVyLnByb3RvdHlwZSApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcmVuZGVyaW5nIGZ1bmN0aW9uLlxyXG4gICAgICogQG1lbWJlcm9mIFBvaW50UmVuZGVyZXJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgcmF3IGRhdGEgZm9yIGEgdGlsZSB0byBiZSByZW5kZXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7e2h0bWw6IHN0cmluZywgZW50cmllczogQXJyYXl9fSBUaGUgaHRtbCB0byByZW5kZXIgYW5kIGFuIGFycmF5IG9mIGFsbCByZW5kZXJlZCBkYXRhIGVudHJpZXMuXHJcbiAgICAgKi9cclxuICAgIFBvaW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCBkYXRhICkge1xyXG5cclxuICAgICAgICB2YXIgc3BlYyA9IHRoaXMuc3BlYyxcclxuICAgICAgICAgICAgbWFwID0gdGhpcy5wYXJlbnQubWFwLFxyXG4gICAgICAgICAgICB2YWx1ZXMgPSBSZW5kZXJlclV0aWwuZ2V0QXR0cmlidXRlVmFsdWUoIGRhdGEsIHNwZWMucm9vdEtleSApLFxyXG4gICAgICAgICAgICBwb2ludCA9IHNwZWMucG9pbnQsXHJcbiAgICAgICAgICAgIGVudHJpZXMgPSBbXSxcclxuICAgICAgICAgICAgcG9zaXRpb25NYXAgPSB7fSxcclxuICAgICAgICAgICAgcG9zaXRpb25LZXksXHJcbiAgICAgICAgICAgIHRpbGVrZXksXHJcbiAgICAgICAgICAgIHRpbGVQb3MsXHJcbiAgICAgICAgICAgIGh0bWwgPSAnJyxcclxuICAgICAgICAgICAgcG9zaXRpb24sXHJcbiAgICAgICAgICAgIG9mZnNldCxcclxuICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgIGksIGo7XHJcblxyXG4gICAgICAgIC8vIGdldCB0aWxla2V5XHJcbiAgICAgICAgdGlsZWtleSA9IGRhdGEuaW5kZXgubGV2ZWwgKyBcIixcIiArIGRhdGEuaW5kZXgueEluZGV4ICsgXCIsXCIgKyBkYXRhLmluZGV4LnlJbmRleDtcclxuICAgICAgICAvLyBnZXQgdGlsZSBwb3NcclxuICAgICAgICB0aWxlUG9zID0gTWFwVXRpbC5nZXRUb3BMZWZ0Vmlld3BvcnRQaXhlbEZvclRpbGUoIG1hcCwgdGlsZWtleSApO1xyXG5cclxuICAgICAgICAvLyBmb3IgZWFjaCBiaW5cclxuICAgICAgICBmb3IgKCBpPTA7IGk8dmFsdWVzLmxlbmd0aDsgaSsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaV0udmFsdWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHZhbHVlLmxlbmd0aCA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBqPTA7IGo8dmFsdWUubGVuZ3RoOyBqKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKCB2YWx1ZVtqXSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGdldCBwb3NpdGlvbiBpbiB2aWV3cG9ydCBzcGFjZVxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBNYXBVdGlsLmdldFZpZXdwb3J0UGl4ZWxGcm9tQ29vcmQoIG1hcCwgdmFsdWVbal1bcG9pbnQueEtleV0sIHZhbHVlW2pdW3BvaW50LnlLZXldICk7XHJcbiAgICAgICAgICAgICAgICAvLyBnZXQgcmVsYXRpdmUgcG9zaXRpb24gZnJvbSB0aWxlIHRvcCBsZWZ0XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogcG9zaXRpb24ueCAtIHRpbGVQb3MueCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBwb3NpdGlvbi55IC0gdGlsZVBvcy55XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBjcmVhdGluZyB0d28gYW5ub3RhdGlvbnMgb24gdGhlIGV4YWN0IHNhbWUgcGl4ZWxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uS2V5ID0gTWF0aC5mbG9vciggb2Zmc2V0LnggKSArIFwiLFwiICsgTWF0aC5mbG9vciggb2Zmc2V0LnkgKTtcclxuICAgICAgICAgICAgICAgIGlmICggIXBvc2l0aW9uTWFwWyBwb3NpdGlvbktleSBdICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uTWFwWyBwb3NpdGlvbktleSBdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwicG9pbnQtYW5ub3RhdGlvbiBwb2ludC1hbm5vdGF0aW9uLXNpbmdsZVwiIHN0eWxlPVwiJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgJ2xlZnQ6JyArIG9mZnNldC54ICsgJ3B4OydcclxuICAgICAgICAgICAgICAgICAgICAgICAgICArICd0b3A6JyArIG9mZnNldC55ICsgJ3B4OydcclxuICAgICAgICAgICAgICAgICAgICAgICAgICArICdib3JkZXItd2lkdGg6IDJweFwiJztcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbal0uZGF0YS5sYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnIHRpdGxlPVwiJyArIHZhbHVlW2pdLmRhdGEubGFiZWxzICsgJ1wiJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPjwvZGl2Pic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaHRtbDogaHRtbCxcclxuICAgICAgICAgICAgZW50cmllczogZW50cmllc1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUG9pbnRSZW5kZXJlcjtcclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDEzIE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xyXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cclxuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBSZW5kZXJlclV0aWwgPSByZXF1aXJlKCcuL1JlbmRlcmVyVXRpbCcpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzQ29sb3IoIHZhbCApIHtcclxuICAgICAgICB2YXIgc3BsaXQgPSB2YWwucmVwbGFjZSgvXFxzKy9nLCAnJykuc3BsaXQoL1tcXChcXCldLyk7XHJcbiAgICAgICAgaWYgKCBzcGxpdFswXSA9PT0gXCJyZ2JcIiB8fCBzcGxpdFswXSA9PT0gXCJyZ2JhXCIgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWxbMF0gPT09IFwiI1wiICYmICggdmFsLmxlbmd0aCA9PT0gNCB8fCB2YWwubGVuZ3RoID09PSA3ICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5qZWN0U2luZ2xlVGhlbWUoIHJlbmRlclRoZW1lLCBzcGVjLCBvcHRpb25zLCBwZXJjZW50ICkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHJlbmRlclRoZW1lLnNlbGVjdG9yLFxyXG4gICAgICAgICAgICBzZWxlY3RvciA9ICggcGVyY2VudCAhPT0gdW5kZWZpbmVkICkgPyBvcHRpb25zLnNlbGVjdG9yICsgXCItXCIgKyBwZXJjZW50IDogb3B0aW9ucy5zZWxlY3RvcixcclxuICAgICAgICAgICAgcGFyZW50U2VsZWN0b3IgPSBvcHRpb25zLnBhcmVudFNlbGVjdG9yLFxyXG4gICAgICAgICAgICBjc3MgPSAnJztcclxuXHJcbiAgICAgICAgLy8gc2V0IGNvbG9yXHJcbiAgICAgICAgaWYgKCBzcGVjWydiYWNrZ3JvdW5kLWNvbG9yJ10gKSB7XHJcbiAgICAgICAgICAgIGNzcyArPSB0aGVtZSArICcgJyArIHNlbGVjdG9yICsgJ3tiYWNrZ3JvdW5kLWNvbG9yOicrc3BlY1snYmFja2dyb3VuZC1jb2xvciddKyc7fSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggc3BlYy5jb2xvciApIHtcclxuICAgICAgICAgICAgY3NzICs9IHRoZW1lICsgJyAnICsgc2VsZWN0b3IgKyAne2NvbG9yOicgKyBzcGVjLmNvbG9yICsgJzt9JztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCBzcGVjLm9wYWNpdHkgKSB7XHJcbiAgICAgICAgICAgIGNzcyArPSB0aGVtZSArICcgJyArIHNlbGVjdG9yICsgJ3tvcGFjaXR5OicgKyBzcGVjLm9wYWNpdHkgKyAnO30nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc2V0IDpob3ZlciBjb2xvclxyXG4gICAgICAgIGlmICggcGFyZW50U2VsZWN0b3IgKSB7XHJcbiAgICAgICAgICAgIGlmICggc3BlY1snYmFja2dyb3VuZC1jb2xvcjpob3ZlciddICkge1xyXG4gICAgICAgICAgICAgICAgY3NzICs9IHRoZW1lICsgJyAnK3BhcmVudFNlbGVjdG9yKyc6aG92ZXIgJytzZWxlY3RvcisnIHtiYWNrZ3JvdW5kLWNvbG9yOicrc3BlY1snYmFja2dyb3VuZC1jb2xvcjpob3ZlciddKyc7fSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCBzcGVjWydjb2xvcjpob3ZlciddICkge1xyXG4gICAgICAgICAgICAgICAgY3NzICs9IHRoZW1lICsgJyAnK3BhcmVudFNlbGVjdG9yKyc6aG92ZXIgJytzZWxlY3RvcisnIHtjb2xvcjonK3NwZWNbJ2NvbG9yOmhvdmVyJ10rJzt9JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHNwZWNbJ29wYWNpdHk6aG92ZXInXSApIHtcclxuICAgICAgICAgICAgICAgIGNzcyArPSB0aGVtZSArICcgJytwYXJlbnRTZWxlY3RvcisnOmhvdmVyICcrc2VsZWN0b3IrJyB7b3BhY2l0eTonK3NwZWNbJ29wYWNpdHk6aG92ZXInXSsnO30nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCBzcGVjWydiYWNrZ3JvdW5kLWNvbG9yOmhvdmVyJ10gKSB7XHJcbiAgICAgICAgICAgICAgICBjc3MgKz0gdGhlbWUgKyAnICcrc2VsZWN0b3IrJzpob3ZlciB7YmFja2dyb3VuZC1jb2xvcjonK3NwZWNbJ2JhY2tncm91bmQtY29sb3I6aG92ZXInXSsnO30nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggc3BlY1snY29sb3I6aG92ZXInXSApIHtcclxuICAgICAgICAgICAgICAgIGNzcyArPSB0aGVtZSArICcgJytzZWxlY3RvcisnOmhvdmVyIHtjb2xvcjonK3NwZWNbJ2NvbG9yOmhvdmVyJ10rJzt9JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHNwZWNbJ29wYWNpdHk6aG92ZXInXSApIHtcclxuICAgICAgICAgICAgICAgIGNzcyArPSB0aGVtZSArICcgJytzZWxlY3RvcisnOmhvdmVyIHtvcGFjaXR5Oicrc3BlY1snb3BhY2l0eTpob3ZlciddKyc7fSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNldCBib3JkZXJzXHJcbiAgICAgICAgaWYgKCBzcGVjWyd0ZXh0LXNoYWRvdyddICkge1xyXG4gICAgICAgICAgICBjc3MgKz0gdGhlbWUgKyAnICcgKyBzZWxlY3RvciArICd7JyArIGdldE91dGxpbmVDc3MoICd0ZXh0LXNoYWRvdycsIHNwZWNbJ3RleHQtc2hhZG93J10gKSArICc7fSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHNwZWMuYm9yZGVyICkge1xyXG4gICAgICAgICAgICBjc3MgKz0gdGhlbWUgKyAnICcgKyBzZWxlY3RvciArICd7JyArIGdldE91dGxpbmVDc3MoICdib3JkZXInLCBzcGVjLmJvcmRlciApICsgJzt9JztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjc3M7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0T3V0bGluZUNzcyggdHlwZSwgdmFsdWUgKSB7XHJcblxyXG5cclxuICAgICAgICBpZiAoICF2YWx1ZSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHR5cGUgPT09IFwidGV4dC1zaGFkb3dcIiApIHtcclxuICAgICAgICAgICAgaWYgKCBpc0NvbG9yKCB2YWx1ZSApICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidGV4dC1zaGFkb3c6XCJcclxuICAgICAgICAgICAgICAgICAgICArIFwiLTFweCAtMXB4IDAgXCIgKyB2YWx1ZSArIFwiLFwiXHJcbiAgICAgICAgICAgICAgICAgICAgKyBcIiAxcHggLTFweCAwIFwiICsgdmFsdWUgKyBcIixcIlxyXG4gICAgICAgICAgICAgICAgICAgICsgXCItMXB4ICAxcHggMCBcIiArIHZhbHVlICsgXCIsXCJcclxuICAgICAgICAgICAgICAgICAgICArIFwiIDFweCAgMXB4IDAgXCIgKyB2YWx1ZSArIFwiLFwiXHJcbiAgICAgICAgICAgICAgICAgICAgKyBcIiAxcHggIDAgICAwIFwiICsgdmFsdWUgKyBcIixcIlxyXG4gICAgICAgICAgICAgICAgICAgICsgXCItMXB4ICAwICAgMCBcIiArIHZhbHVlICsgXCIsXCJcclxuICAgICAgICAgICAgICAgICAgICArIFwiIDAgICAgMXB4IDAgXCIgKyB2YWx1ZSArIFwiLFwiXHJcbiAgICAgICAgICAgICAgICAgICAgKyBcIiAwICAgLTFweCAwIFwiICsgdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFwidGV4dC1zaGFkb3c6XCIgKyB2YWx1ZSArIFwiO1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIHR5cGUgPT09IFwiYm9yZGVyXCIgKSB7XHJcbiAgICAgICAgICAgIGlmICggaXNDb2xvciggdmFsdWUgKSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImJvcmRlcjogMXB4IHNvbGlkIFwiICsgdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFwiYm9yZGVyOlwiICsgdmFsdWUgKyBcIjtcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW50aWF0ZSBhIFJlbmRlclRoZW1lIG9iamVjdC5cclxuICAgICAqIEBjbGFzcyBSZW5kZXJUaGVtZVxyXG4gICAgICogQGNsYXNzZGVzYyBUaGUgUmVuZGVyVGhlbWUgY2xhc3MgcHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gc3R5bGUgc2VwYXJhdGUgY29tcG9uZW50c1xyXG4gICAgICogZ2VuZXJhdGVkIGZyb20gYSBSZW5kZXJlciBvYmplY3QuIFRoZSB0aGVtZSdzIENTUyBpcyBpbmplY3RlZCBpbnRvIHRoZSBET00gdW5kZXIgdGhlXHJcbiAgICAgKiBzdXBwbGllZCBzZWxlY3RvcnMuIFRoaXMgYWxsb3dzIHN3aXRjaGluZyBiZXR3ZWVuIHRoZW1lcyBvbiBjbGllbnQgcmVuZGVyZWQgdGlsZXMgYnlcclxuICAgICAqIHNpbXBseSBhcHBlbmRpbmcgdGhlIHJlc3BlY3RpdmUgc2VsZWN0b3IgdG8gYSBwYXJlbnQgRE9NIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogSXQgaXMgdGhlIFJlbmRlcmVyIGltcGxlbWVudGF0aW9ucyByZXNwb25zaWJpbGl0eSB0byBlbnN1cmUgdGhhdCB0aGUgUmVuZGVyVGhlbWVcclxuICAgICAqIG9iamVjdCBpcyB1dGlsaXplZCBjb3JyZWN0bHksIGFzIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvbnMgbWF5IHJlcXVpcmUgdW5pcXVlXHJcbiAgICAgKiBzdHlsaW5nLlxyXG4gICAgICpcclxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIHVzaW5nIFJlbmRlclRoZW1lcyB3b3VsZCBiZSBlaXRoZXIgYnlwYXNzaW5nIFJlbmRlcmVycyBhbGwgdG9nZXRoZXJcclxuICAgICAqIGFuZCB1c2luZyB0aGUgbG93ZXIgbGV2ZWwgaHRtbCBwcm92aWRlciBmdW5jdGlvbiBhY2NlcHRlZCBieSBjbGllbnQgcmVuZGVyZWQgbGF5ZXJzLCBvclxyXG4gICAgICogdXNpbmcgdGhlIGhvb2sgZnVuY3Rpb24gdG8gaW5zZXJ0IGFwcGxpY2F0aW9uIG9yIHRoZW1lIHNwZWNpZmljIGNsYXNzZXMgaW50byB0aGVcclxuICAgICAqIGdlbmVyYXRlZCBodG1sIGVudHJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRoZW1lIHtTdHJpbmd9IFRoZSB0aGVtZSBpZGVudGlmaWNhdGlvbiBzdHJpbmcuIEN1cnJlbnRseSByZXN0cmljdGVkIHRvIFwiZGFya1wiIGFuZCBcImxpZ2h0XCIuXHJcbiAgICAgKiBAcGFyYW0gc3BlYyAge09iamVjdH0gVGhlIHNwZWNpZmljYXRpb24gb2JqZWN0LlxyXG4gICAgICogPHByZT5cclxuICAgICAqIHtcclxuICAgICAqICAgICBjb2xvciAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IC0gVGhlIGNzcyBjb2xvciBhdHRyaWJ1dGUgZm9yIHRoZSBjb21wb25lbnQuXHJcbiAgICAgKiAgICAgY29sb3I6aG92ZXIgICAgICAgICAgICB7U3RyaW5nfSAtIFRoZSBjc3MgY29sb3IgYXR0cmlidXRlIGZvciB0aGUgY29tcG9uZW50LCB1bmRlciBob3Zlci5cclxuICAgICAqICAgICBiYWNrZ3JvdW5kLWNvbG9yICAgICAgIHtTdHJpbmd9IC0gVGhlIGNzcyBiYWNrZ3JvdW5kLWNvbG9yIGF0dHJpYnV0ZSBmb3IgdGhlIGNvbXBvbmVudC5cclxuICAgICAqICAgICBiYWNrZ3JvdW5kLWNvbG9yOmhvdmVyIHtTdHJpbmd9IC0gVGhlIGNzcyBiYWNrZ3JvdW5kLWNvbG9yIGF0dHJpYnV0ZSBmb3IgdGhlIGNvbXBvbmVudCwgdW5kZXIgaG92ZXIuXHJcbiAgICAgKiAgICAgdGV4dC1zaGFkb3cgICAgICAgICAgICB7U3RyaW5nfSAtIFRoZSBjc3MgdGV4dC1zaGFkb3cgYXR0cmlidXRlIGZvciB0aGUgY29tcG9uZW50LlxyXG4gICAgICogICAgIGJvcmRlciAgICAgICAgICAgICAgICAge1N0cmluZ30gLSBUaGUgY3NzIGJvcmRlciBhdHRyaWJ1dGUgZm9yIHRoZSBjb21wb25lbnQuXHJcbiAgICAgKiB9XHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVuZGVyVGhlbWUoIHRoZW1lLCBzcGVjICkge1xyXG4gICAgICAgIHNwZWMgPSBzcGVjIHx8IHt9O1xyXG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSAoIHRoZW1lID09PSAnbGlnaHQnICkgPyBcIi5saWdodC10aGVtZVwiIDogXCIuZGFyay10aGVtZVwiO1xyXG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmplY3RzIHRoZSB0aGVtZXMgQ1NTIHVuZGVyIHRoZSBwcm92aWRlZCBzZWxlY3RvciBhbmQgcGFyZW50IHNlbGVjdG9yLiBUaGlzIHNob3VsZFxyXG4gICAgICogb25seSBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYSBSZW5kZXJlciBjbGFzcyBpbXBsZW1lbnRhdGlvbiwgYW5kIGl0IGlzIHRoZSByZXNwb25zaWJpbGl0eVxyXG4gICAgICogb2YgdGhlIFJlbmRlcmVyIGltcGxlbWVudGF0aW9uIHRvIGVuc3VyZSBpdCBpcyB1c2VkIGNvcnJlY3RseS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyB0aGUgc2VsZWN0b3IgYW5kIHBhcmVudFNlbGVjdG9yLlxyXG4gICAgICovXHJcbiAgICBSZW5kZXJUaGVtZS5wcm90b3R5cGUuaW5qZWN0VGhlbWUgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcclxuICAgICAgICB2YXIgY3NzLFxyXG4gICAgICAgICAgICBibGVuZFNwZWMsXHJcbiAgICAgICAgICAgIGZyb20sXHJcbiAgICAgICAgICAgIHRvLFxyXG4gICAgICAgICAgICBpO1xyXG4gICAgICAgIGNzcyA9ICc8c3R5bGUgY2xhc3M9XCJyZW5kZXItdGhlbWVcIiB0eXBlPVwidGV4dC9jc3NcIj4nO1xyXG4gICAgICAgIGlmICggdGhpcy5zcGVjLmZyb20gJiYgdGhpcy5zcGVjLnRvICkge1xyXG4gICAgICAgICAgICBmcm9tID0gdGhpcy5zcGVjLmZyb207XHJcbiAgICAgICAgICAgIHRvID0gdGhpcy5zcGVjLnRvO1xyXG4gICAgICAgICAgICBmb3IgKCBpPTEwOyBpPj0wOyBpLS0gKSB7XHJcbiAgICAgICAgICAgICAgICBibGVuZFNwZWMgPSB7fTtcclxuICAgICAgICAgICAgICAgIGlmICggZnJvbVsnYmFja2dyb3VuZC1jb2xvciddICYmIHRvWydiYWNrZ3JvdW5kLWNvbG9yJ10gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGJsZW5kU3BlY1snYmFja2dyb3VuZC1jb2xvciddID0gUmVuZGVyZXJVdGlsLmhleEJsZW5kKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgdG9bJ2JhY2tncm91bmQtY29sb3InXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21bJ2JhY2tncm91bmQtY29sb3InXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGkvMTAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICggZnJvbS5jb2xvciAmJiB0by5jb2xvciApIHtcclxuICAgICAgICAgICAgICAgICAgICAgYmxlbmRTcGVjLmNvbG9yID0gUmVuZGVyZXJVdGlsLmhleEJsZW5kKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgdG8uY29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaS8xMCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCBmcm9tLm9wYWNpdHkgJiYgdG8ub3BhY2l0eSApIHtcclxuICAgICAgICAgICAgICAgICAgICBibGVuZFNwZWMub3BhY2l0eSA9IGZyb20ub3BhY2l0eSArICgoKCB0by5vcGFjaXR5IC0gZnJvbS5vcGFjaXR5ICkgLyAxMCkqaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIGZyb21bJ2JhY2tncm91bmQtY29sb3I6aG92ZXInXSAmJiB0b1snYmFja2dyb3VuZC1jb2xvcjpob3ZlciddICkge1xyXG4gICAgICAgICAgICAgICAgICAgICBibGVuZFNwZWNbJ2JhY2tncm91bmQtY29sb3I6aG92ZXInXSA9IFJlbmRlcmVyVXRpbC5oZXhCbGVuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvWydiYWNrZ3JvdW5kLWNvbG9yOmhvdmVyJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tWydiYWNrZ3JvdW5kLWNvbG9yOmhvdmVyJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBpLzEwICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIGZyb21bJ2NvbG9yOmhvdmVyJ10gJiYgdG9bJ2NvbG9yOmhvdmVyJ10gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGJsZW5kU3BlY1snY29sb3I6aG92ZXInXSA9IFJlbmRlcmVyVXRpbC5oZXhCbGVuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvWydjb2xvcjpob3ZlciddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVsnY29sb3I6aG92ZXInXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGkvMTAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICggZnJvbVsnb3BhY2l0eTpob3ZlciddICYmIHRvWydvcGFjaXR5OmhvdmVyJ10gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmxlbmRTcGVjWydvcGFjaXR5OmhvdmVyJ10gPSBmcm9tWydvcGFjaXR5OmhvdmVyJ10gKyAoKCggdG9bJ29wYWNpdHk6aG92ZXInXSAtIGZyb21bJ29wYWNpdHk6aG92ZXInXSApIC8gMTApKmkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCBmcm9tWyd0ZXh0LXNoYWRvdyddICYmIHRvWyd0ZXh0LXNoYWRvdyddICkge1xyXG4gICAgICAgICAgICAgICAgICAgICBibGVuZFNwZWNbJ3RleHQtc2hhZG93J10gPSBSZW5kZXJlclV0aWwuaGV4QmxlbmQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB0b1sndGV4dC1zaGFkb3cnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21bJ3RleHQtc2hhZG93J10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBpLzEwICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIGZyb20uYm9yZGVyICYmIHRvLmJvcmRlciApIHtcclxuICAgICAgICAgICAgICAgICAgICAgYmxlbmRTcGVjLmJvcmRlciA9IFJlbmRlcmVyVXRpbC5oZXhCbGVuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvLmJvcmRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20uYm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaS8xMCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaW5qZWN0IHBlcmNlbnRhZ2UgdGhlbWVcclxuICAgICAgICAgICAgICAgIGNzcyArPSBpbmplY3RTaW5nbGVUaGVtZSggdGhpcywgYmxlbmRTcGVjLCBvcHRpb25zLCBpKjEwICk7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHRoZW1lIGZvciAnMTAwJyB3aXRob3V0IHRoZSAnMTAwJyB0YWcgYXMgd2VsbFxyXG4gICAgICAgICAgICAgICAgaWYgKCBpID09PSAxMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBjc3MgKz0gaW5qZWN0U2luZ2xlVGhlbWUoIHRoaXMsIGJsZW5kU3BlYywgb3B0aW9ucyApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY3NzICs9IGluamVjdFNpbmdsZVRoZW1lKCB0aGlzLCB0aGlzLnNwZWMsIG9wdGlvbnMgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNzcyArPSAnPC9zdHlsZT4nO1xyXG4gICAgICAgICQoIGRvY3VtZW50LmhlYWQgKS5wcmVwZW5kKCBjc3MgKTtcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJUaGVtZTtcclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDEzIE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xyXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cclxuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9VdGlsJyApLFxyXG4gICAgICAgIFJlbmRlcmVyVXRpbCA9IHJlcXVpcmUoJy4vUmVuZGVyZXJVdGlsJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW50aWF0ZSBhIFJlbmRlcmVyIG9iamVjdC5cclxuICAgICAqIEBjbGFzcyBSZW5kZXJlclxyXG4gICAgICogQGNsYXNzZGVzYyBUaGUgUmVuZGVyZXIgY2xhc3MgaXMgZGVzaWduZWQgdG8gcHJvdmlkZSBnZW5lcmljIHJlbmRlcmluZyBjYXBhYmlsaXRpZXNcclxuICAgICAqIHRoYXQgY2FuIGJlIHJldXNlZCBhY3Jvc3MgYXBwbGljYXRpb25zLiBUaGlzIGJhc2UgY2xhc3Mgc3RvcmVzIGZ1bmN0aW9uYWxpdHkgdGhhdCBpc1xyXG4gICAgICogY29tbW9uIGFjcm9zcyBhbGwgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zLCBtYWlubHkgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgJ2hvb2snXHJcbiAgICAgKiBmdW5jdGlvbiB0byBnaXZlIGFjY2VzcyB0byB0aGUgZ2VuZXJhdGVkIERPTSBlbGVtZW50cyB0byBwcm92aWRlIGFwcGxpY2F0aW9uXHJcbiAgICAgKiBzcGVjaWZpYyBiZWhhdmlvci5cclxuICAgICAqIDxicj5cclxuICAgICAqIFR5cGljYWxseSBlYWNoIHVuaXF1ZSBjb21wb25lbnQgZ2VuZXJhdGVkIGZyb20gYSByZW5kZXJlciB3aWxsIGJlIHVuZGVyIGEgc2VwYXJhdGVcclxuICAgICAqIHNwZWNpZmljYXRpb24gYXR0cmlidXRlLiBGb3IgZXhhbXBsZSB0aGUgdGV4dCBlbGVtZW50cyBvZiB0aGUgVGV4dEJ5RnJlcXVlbmN5UmVuZGVyZXJcclxuICAgICAqIGlzIHVuZGVyICd0ZXh0JyBhbmQgdGhlIGZyZXF1ZW5jeSBkaXN0cmlidXRpb24gZWxlbWVudHMgYXJlIHVuZGVyICdmcmVxdWVuY3knLlxyXG4gICAgICogPGJyPlxyXG4gICAgICogRWFjaCBvZiB0aGUgc2VwYXJhdGUgY29tcG9uZW50cyBTSE9VTEQgYWNjZXB0ICpLZXkgYXR0cmlidXRlcyB0byBpbnN0cnVjdCBpdCBhcyB0b1xyXG4gICAgICogd2hlcmUgdGhlIHJlbGV2YW50IGRhdGEgc2hvdWxkIGJlIGZvdW5kIGluIHRoZSB0aWxlIGRhdGEgb2JqZWN0LiBFYWNoIG9mIHRoZXNlXHJcbiAgICAgKiBzZXBhcmF0ZSBjb21wb25lbnRzIFNIT1VMRCBhY2NlcHQgaXNvbGF0ZWQgUmVuZGVyVGhlbWVzIChpbiB0aGUgY2FzZSB0aGF0IFJlbmRlclRoZW1lc1xyXG4gICAgICogYXJlIHVzZWQpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzcGVjIHtPYmplY3R9IFRoZSBzcGVjaWZpY2F0aW9uIG9iamVjdC5cclxuICAgICAqIDxwcmU+XHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgaG9vayB7RnVuY3Rpb259IC0gVGhlIGhvb2sgZnVuY3Rpb24gdGhhdCBpcyBleGVjdXRlZCBvbiBldmVyeSByZW5kZXJlZCBlbnRyeSBwcm92aWRpbmcgdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XHJcbiAgICAgKiAgICAgICAgIGVsZW0gICAge0hUTUxFbGVtZW50fSAtIFRoZSBodG1sIGVsZW1lbnQgZm9yIHRoZSBlbnRyeS5cclxuICAgICAqICAgICAgICAgZW50cnkgICB7T2JqZWN0fSAgICAgIC0gVGhlIGRhdGEgZW50cnkuXHJcbiAgICAgKiAgICAgICAgIGVudHJpZXMge0FycmF5fSAgICAgICAtIEFsbCBlbnRyaWVzIGZvciB0aGUgdGlsZS5cclxuICAgICAqICAgICAgICAgZGF0YSAgICB7T2JqZWN0fSAgICAgIC0gVGhlIHJhdyBkYXRhIG9iamVjdCBmb3IgdGhlIHRpbGUuXHJcbiAgICAgKiB9XHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVuZGVyZXIoIHNwZWMgKSB7XHJcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCB7fTtcclxuICAgICAgICB0aGlzLnV1aWQgPSBVdGlsLmdlbmVyYXRlVXVpZCgpO1xyXG4gICAgICAgIGlmICggc3BlYy5hZ2dyZWdhdG9yICkge1xyXG4gICAgICAgICAgICB0aGlzLmFnZ3JlZ2F0b3IgPSBzcGVjLmFnZ3JlZ2F0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgaG9vayBmdW5jdGlvbiB0byB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVuZGVyZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rIC0gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuYWRkSG9vayA9IGZ1bmN0aW9uKCBob29rICkge1xyXG4gICAgICAgIGlmICggdGhpcy5zcGVjLmhvb2sgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlYy5ob29rcyA9IFsgdGhpcy5zcGVjLmhvb2sgXTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3BlYy5ob29rO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNwZWMuaG9va3MgPSB0aGlzLnNwZWMuaG9va3MgfHwgW107XHJcbiAgICAgICAgaWYgKCBob29rICYmIHR5cGVvZiBob29rID09PSBcImZ1bmN0aW9uXCIgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlYy5ob29rcy5wdXNoKCBob29rICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhIGhvb2sgZnVuY3Rpb24gZnJvbSB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVuZGVyZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rIC0gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlSG9vayA9IGZ1bmN0aW9uKCBob29rICkge1xyXG4gICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICBpZiAoIHRoaXMuc3BlYy5ob29rICYmIHRoaXMuc3BlYy5ob29rID09PSBob29rICkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zcGVjLmhvb2s7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlYy5ob29rcyA9IFsgdGhpcy5zcGVjLmhvb2sgXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCB0aGlzLnNwZWMuaG9va3MgKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zcGVjLmhvb2tzLmluZGV4T2YoIGhvb2sgKTtcclxuICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gLTEgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWMuaG9va3Muc3BsaWNlKCBpbmRleCwgMSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gcmVuZGVyaW5nIGEgdGlsZSwgdGhlIHJlbmRlcmVyIHdpbGwgYnkgZGVmYXVsdCBhc3N1bWUgZWFjaCBpbW1lZGlhdGUgc2libGluZ1xyXG4gICAgICogY29ycmVzcG9uZHMgdG8gYSBkYXRhIGVudHJ5LiBUaGlzIGZ1bmN0aW9uIGFsbG93cyBhIHJlbmRlcmVyIGltcGxlbWVudGF0aW9uIHRvXHJcbiAgICAgKiBwcm92aWRlIGEgc2VsZWN0b3IgaW4gc2l0dWF0aW9ucyB3aGVyZSB0aGlzIGlzIG5vdCB0aGUgY2FzZS4gVGhpcyBpcyBvbmx5IHJlbGV2YW50XHJcbiAgICAgKiBpZiB0aGUgaG9vayBjYWxsYmFjayBpcyBzZXQuXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVuZGVyZXJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58c3RyaW5nfSBUaGUgRE9NIGVsZW1lbnQgc2VsZWN0b3IgZm9yIGVhY2ggcmVuZGVyZWQgZW50cnkuXHJcbiAgICAgKi9cclxuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFbnRyeVNlbGVjdG9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdCBhbGwgZW50cmllcyBpbiB0aGUgcmVuZGVyZWQgbGF5ZXIgdGhhdCBhbHNvIHNoYXJlIHRoZSBzYW1lIHNlbGVjdGVkIHZhbHVlLiBUaGVcclxuICAgICAqICdzZWxlY3RLZXknIG9mIHRoZSAnc2VsZWN0JyBvcHRpb24gbXVzdCBiZSBzZXQuXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVuZGVyZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0ZWRFbnRyeSAtIFRoZSBzZWxlY3RlZCBkYXRhIGVudHJ5LlxyXG4gICAgICovXHJcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdGVkRW50cnkgKSB7XHJcbiAgICAgICAgdmFyICR0aWxlcyA9ICQoIHRoaXMucGFyZW50Lm9sTGF5ZXIuZGl2ICkuZmluZCggJy5vbFRpbGVIdG1sLC5vbFRpbGVVbml2YXJpYXRlJyApLFxyXG4gICAgICAgICAgICBzZWxlY3RLZXkgPSB0aGlzLnNwZWMuc2VsZWN0LnNlbGVjdEtleSxcclxuICAgICAgICAgICAgc2VsZWN0b3IgPSB0aGlzLmdldEVudHJ5U2VsZWN0b3IoKSxcclxuICAgICAgICAgICAgdXVpZCA9IHRoaXMudXVpZCxcclxuICAgICAgICAgICAgc2VsZWN0VmFsdWUsXHJcbiAgICAgICAgICAgICRlbnRyaWVzO1xyXG4gICAgICAgIC8vIGlmIG5vIGtleSBzcGVjaWZpZWQsIGV4aXRcclxuICAgICAgICBpZiAoICFzZWxlY3RLZXkgKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZ2V0IHRoZSBzZWxlY3QgdmFsdWUgYmFzZWQgb24ga2V5XHJcbiAgICAgICAgdGhpcy5zZWxlY3RWYWx1ZSA9IHNlbGVjdFZhbHVlID0gUmVuZGVyZXJVdGlsLmdldEF0dHJpYnV0ZVZhbHVlKCBzZWxlY3RlZEVudHJ5LCBzZWxlY3RLZXkgKTtcclxuICAgICAgICAvLyBpZiBlbnRyeSBzZWxlY3RvciBpcyBzZXQsIHVzZSBpdCB0byBzZWxlY3QgZW50cmllc1xyXG4gICAgICAgICRlbnRyaWVzID0gc2VsZWN0b3IgPyAkdGlsZXMuZmluZCggc2VsZWN0b3IgKSA6ICR0aWxlcy5jaGlsZHJlbigpO1xyXG4gICAgICAgIC8vIGZvciBlYWNoIGVudHJ5LCBjaGVjayBpZiB0aGV5IGhhdmUgdGhlIG1hdGNoaW5nIHZhbHVlIHRvIHRoZSBzZWxlY3RcclxuICAgICAgICAkZW50cmllcy5lYWNoKCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyICRlbGVtID0gJCggdGhpcyApLFxyXG4gICAgICAgICAgICAgICAgZW50cnksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTtcclxuICAgICAgICAgICAgLy8gaWYgdGhpcyByZW5kZXJlciBkaWQgbm90IGNyZWF0ZSB0aGUgZWxlbWVudHMsIGFib3J0XHJcbiAgICAgICAgICAgIGlmICggdXVpZCAhPT0gJGVsZW0uZGF0YSggJ3V1aWQnICkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBlbnRyeSBhbmQgdmFsdWVcclxuICAgICAgICAgICAgZW50cnkgPSAkZWxlbS5kYXRhKCAnZW50cnknICk7XHJcbiAgICAgICAgICAgIHZhbHVlID0gUmVuZGVyZXJVdGlsLmdldEF0dHJpYnV0ZVZhbHVlKCBlbnRyeSwgc2VsZWN0S2V5ICk7XHJcbiAgICAgICAgICAgIGlmICggdmFsdWUgPT09IHNlbGVjdFZhbHVlICkge1xyXG4gICAgICAgICAgICAgICAgICRlbGVtLnJlbW92ZUNsYXNzKCAnZGUtZW1waGFzaXplZCcgKS5hZGRDbGFzcyggJ2VtcGhhc2l6ZWQnICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAkZWxlbS5yZW1vdmVDbGFzcyggJ2VtcGhhc2l6ZWQnICkuYWRkQ2xhc3MoICdkZS1lbXBoYXNpemVkJyApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5zZWxlY3QgYWxsIGVudHJpZXMgaW4gdGhlIHJlbmRlcmVkIGxheWVyLlxyXG4gICAgICogQG1lbWJlcm9mIFJlbmRlcmVyXHJcbiAgICAgKi9cclxuICAgIFJlbmRlcmVyLnByb3RvdHlwZS51bnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciAkdGlsZXMgPSAkKCB0aGlzLnBhcmVudC5vbExheWVyLmRpdiApLmZpbmQoICcub2xUaWxlSHRtbCwub2xUaWxlVW5pdmFyaWF0ZScgKSxcclxuICAgICAgICAgICAgc2VsZWN0b3IgPSB0aGlzLmdldEVudHJ5U2VsZWN0b3IoKSxcclxuICAgICAgICAgICAgJGVudHJpZXM7XHJcbiAgICAgICAgLy8gaWYgZW50cnkgc2VsZWN0b3IgaXMgc2V0LCB1c2UgaXQgdG8gc2VsZWN0IGVudHJpZXNcclxuICAgICAgICAkZW50cmllcyA9IHNlbGVjdG9yID8gJHRpbGVzLmZpbmQoIHNlbGVjdG9yICkgOiAkdGlsZXMuY2hpbGRyZW4oKTtcclxuICAgICAgICAvLyBmb3IgZWFjaCBlbnRyeSwgcmVtb3ZlIHJlbGV2YW50IGNsYXNzZXNcclxuICAgICAgICAkZW50cmllcy5lYWNoKCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgJCggdGhpcyApLnJlbW92ZUNsYXNzKCAnZGUtZW1waGFzaXplZCcgKS5yZW1vdmVDbGFzcyggJ2VtcGhhc2l6ZWQnICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY2xlYXIgdGhlIHNlbGVjdCB2YWx1ZVxyXG4gICAgICAgIHRoaXMuc2VsZWN0VmFsdWUgPSBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjZW50cmFsIHJlbmRlcmluZyBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGV2ZXJ5IHRpbGUgY29udGFpbmluZyBkYXRhLlxyXG4gICAgICogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgdGlsZXMgaHRtbCwgYWxvbmcgd2l0aCBhbiBhcnJheSBvZiBlYWNoIGRhdGEgZW50cnkuIFRoZVxyXG4gICAgICogaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBpcyB1bmlxdWUgdG8gZWFjaCByZW5kZXJlci5cclxuICAgICAqIEBtZW1iZXJvZiBSZW5kZXJlclxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7e2h0bWw6IHN0cmluZywgZW50cmllczogQXJyYXl9fSBUaGUgaHRtbCB0byByZW5kZXIgYW5kIGFuIGFycmF5IG9mIGFsbCByZW5kZXJlZCBkYXRhIGVudHJpZXMuXHJcbiAgICAgKi9cclxuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBodG1sOiBcIlwiLFxyXG4gICAgICAgICAgICBlbnRyaWVzOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNoZXMgdGhlIHJlbmRlcmVyIHRvIGl0cyByZXNwZWN0aXZlIGxheWVyLiBUaGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIGNhbGxlZFxyXG4gICAgICogbWFudWFsbHkuXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVuZGVyZXJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gYXR0YWNoIHRvIHRoZSByZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKCBsYXllciApIHtcclxuICAgICAgICBpZiAoIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50ICE9PSBsYXllciApIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coIFwiVGhpcyByZW5kZXJlciBoYXMgYWxyZWFkeSBiZWVuIGF0dGFjaGVkIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIFwidG8gYSBkaWZmZXJlbnQgbGF5ZXIsIHBsZWFzZSB1c2UgYW5vdGhlciBpbnN0YW5jZS5cIiApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbGF5ZXI7XHJcbiAgICAgICAgaWYgKCB0aGlzLmFnZ3JlZ2F0b3IgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWdncmVnYXRvci5hdHRhY2goIGxheWVyICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXRlcmF0ZXMgb3ZlciBldmVyeSBkYXRhIGVudHJ5J3MgRE9NIGVsZW1lbnQgYW5kIGlmIHRoZXJlIGlzIGEgY3VycmVudCBzZWxlY3RlZFxyXG4gICAgICogdmFsdWUgaW4gdGhlIHJlbmRlcmVyLCBpdCB3aWxsIGluamVjdCB0aGUgY29ycmVjdCBlbXBoYXNpemUgYW5kIGRlLWVtcGhhc2l6ZSBmbGFncy5cclxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG4gICAgICogQG1lbWJlcm9mIFJlbmRlcmVyXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SFRNTENvbGxlY3Rpb259IGVsZW1lbnRzIC0gQSBjb2xsZWN0aW9uIG9mIGh0bWwgZWxlbWVudHMuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbnRyaWVzIC0gVGhlIGFycmF5IG9mIGFsbCBkYXRhIGVudHJpZXMuXHJcbiAgICAgKi9cclxuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5pbmplY3RFbnRyaWVzID0gZnVuY3Rpb24oIGVsZW1lbnRzLCBlbnRyaWVzICkge1xyXG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRoaXMuZ2V0RW50cnlTZWxlY3RvcigpLFxyXG4gICAgICAgICAgICAkZWxlbWVudHMgPSAkKCBlbGVtZW50cyApLFxyXG4gICAgICAgICAgICBzZWxlY3RWYWx1ZSA9IHRoaXMuc2VsZWN0VmFsdWUsXHJcbiAgICAgICAgICAgIHNlbGVjdCA9IHRoaXMuc3BlYy5zZWxlY3QsXHJcbiAgICAgICAgICAgIHV1aWQgPSB0aGlzLnV1aWQsXHJcbiAgICAgICAgICAgIHNlbGVjdEtleTtcclxuICAgICAgICBpZiAoICFzZWxlY3QgfHwgIXNlbGVjdC5zZWxlY3RLZXkgKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZ2V0IHNlbGVjdCBrZXlcclxuICAgICAgICBzZWxlY3RLZXkgPSBzZWxlY3Quc2VsZWN0S2V5O1xyXG4gICAgICAgIC8vIGlmIGVudHJ5IHNlbGVjdG9yIGlzIHNldCwgdXNlIGl0IHRvIHNlbGVjdCBlbnRyaWVzXHJcbiAgICAgICAgaWYgKCBzZWxlY3RvciApIHtcclxuICAgICAgICAgICAgJGVsZW1lbnRzID0gJGVsZW1lbnRzLmZpbmQoIHNlbGVjdG9yICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbGwgZW50cnkgZnVuY3Rpb24gb24gZWFjaCBlbnRyeVxyXG4gICAgICAgICRlbGVtZW50cy5lYWNoKCBmdW5jdGlvbiggaW5kZXgsIGVsZW0gKSB7XHJcbiAgICAgICAgICAgIHZhciAkZWxlbSA9ICQoIGVsZW0gKSxcclxuICAgICAgICAgICAgICAgIGVudHJ5ID0gZW50cmllc1tpbmRleF0sXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFJlbmRlcmVyVXRpbC5nZXRBdHRyaWJ1dGVWYWx1ZSggZW50cnksIHNlbGVjdEtleSApO1xyXG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgZW50cnkgZGF0YSBpbiB0aGUgZW50cnkgZWxlbWVudFxyXG4gICAgICAgICAgICAkZWxlbS5kYXRhKCAnZW50cnknLCBlbnRyeSApO1xyXG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgcmVuZGVyZXIgdXVpZFxyXG4gICAgICAgICAgICAkZWxlbS5kYXRhKCAndXVpZCcsIHV1aWQgKTtcclxuICAgICAgICAgICAgaWYgKCBzZWxlY3RWYWx1ZSAmJiBzZWxlY3RLZXkgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSBzZWxlY3RWYWx1ZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAkZWxlbS5yZW1vdmVDbGFzcyggJ2RlLWVtcGhhc2l6ZWQnICkuYWRkQ2xhc3MoICdlbXBoYXNpemVkJyApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAkZWxlbS5yZW1vdmVDbGFzcyggJ2VtcGhhc2l6ZWQnICkuYWRkQ2xhc3MoICdkZS1lbXBoYXNpemVkJyApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhvb2sgY2FsbGJhY2sgZXhlY3V0b3IgZnVuY3Rpb24uIElmIGEgaG9vayBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byB0aGUgcmVuZGVyZXIsIHRoaXNcclxuICAgICAqIHdpbGwgZXhlY3V0ZSBpdCBwYXNzaW5nIHRoZSByZXNwZWN0aXZlIGVsZW1lbnQgYW5kIGRhdGEgZW50cnkgYWxvbmcgd2l0aCBhbGwgZW50cmllcyBhbmRcclxuICAgICAqIHRoZSByYXcgdGlsZSBkYXRhLiBUaGlzIGlzIGNhbGxlZCBieSB0aGUgSHRtbFRpbGUgb2JqZWN0LCBzaG91bGQgbm90IGJlIGNhbGxlZCBtYW51YWxseS5cclxuICAgICAqIEBtZW1iZXJvZiBSZW5kZXJlclxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxDb2xsZWN0aW9ufSBlbGVtZW50cyAtIEEgY29sbGVjdGlvbiBvZiBodG1sIGVsZW1lbnRzLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZW50cmllcyAtIFRoZSBhcnJheSBvZiBhbGwgZGF0YSBlbnRyaWVzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgcmF3IHRpbGUgZGF0YSBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5leGVjdXRlSG9va3MgPSBmdW5jdGlvbiggZWxlbWVudHMsIGVudHJpZXMsIGRhdGEgKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGV4ZWNIb29rKCBpbmRleCwgZWxlbSApIHtcclxuICAgICAgICAgICAgaG9vayggZWxlbSwgZW50cmllc1tpbmRleF0sIGVudHJpZXMsIGRhdGEgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBob29rcyA9IHRoaXMuc3BlYy5ob29rID8gWyB0aGlzLnNwZWMuaG9vayBdIDogdGhpcy5zcGVjLmhvb2tzLFxyXG4gICAgICAgICAgICBzZWxlY3RvciA9IHRoaXMuZ2V0RW50cnlTZWxlY3RvcigpLFxyXG4gICAgICAgICAgICBob29rLFxyXG4gICAgICAgICAgICAkZWxlbWVudHMsXHJcbiAgICAgICAgICAgIGk7XHJcbiAgICAgICAgaWYgKCBob29rcyApIHtcclxuICAgICAgICAgICAgZm9yICggaT0wOyBpPGhvb2tzLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgaG9vayA9IGhvb2tzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgaG9vayA9PT0gXCJmdW5jdGlvblwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgZW50cmllc1xyXG4gICAgICAgICAgICAgICAgICAgICRlbGVtZW50cyA9ICQoIGVsZW1lbnRzICk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZW50cnkgc2VsZWN0b3IgaXMgc2V0LCB1c2UgaXQgdG8gc2VsZWN0IGVudHJpZXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlbGVjdG9yICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudHMuZmluZCggc2VsZWN0b3IgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBlbnRyeSBmdW5jdGlvbiBvbiBlYWNoIGVudHJ5XHJcbiAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnRzLmVhY2goIGV4ZWNIb29rICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMyBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgUmVuZGVyVXRpbFxyXG4gKiBAY2xhc3NkZXNjIEEgdXRpbGl0eSBuYW1lc3BhY2UgY29udGFpbmluZyByZW5kZXJlciByZWxhdGVkIGZ1bmN0aW9uYWxpdHkuXHJcbiAqL1xyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIGZ1bmN0aW9uIGxvZzEwKHZhbCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjEwO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgeSBvZmZzZXQgcmVxdWlyZWQgdG8gdmVydGljYWwgY2VudHJlIGEgbnVtYmVyIG9mIGVudHJpZXMgYmFzZWRcclxuICAgICAgICAgKiBvbiBzcGFjaW5nIGFuZCBvZmZzZXRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVuZGVyVXRpbFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBudW1FbnRyaWVzIC0gVGhlIG51bWJlciBvZiBlbnRyaWVzIHRvIHJlbmRlci5cclxuICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHNwYWNpbmcgLSBUaGUgc3BhY2luZyBiZXR3ZWVuIGVudHJpZXMgaW4gcGl4ZWxzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBmcm9tIHRoZSB0b3Agb2YgdGhlIHRpbGUgdG8gY2VudHJlIG9uIGluIHBpeGVscy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgeSBwaXhlbCBvZmZzZXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0WU9mZnNldDogZnVuY3Rpb24oIG51bUVudHJpZXMsIHNwYWNpbmcsIG9mZnNldCApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9mZnNldCAtICggKCAoIG51bUVudHJpZXMgLSAxKSAvIDIgKSApICogc3BhY2luZztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmFuc2Zvcm1zIGEgdmFsdWUgaW50byB0aGUgcmFuZ2UgWzA6MV0gYmFzZWQgb24gYSBtaW4gYW5kIG1heCB2YWx1ZVxyXG4gICAgICAgICAqIGFjY29yZGluZyB0byBhIGxpbmVhciBvciBsb2cgdHJhbnNmb3JtLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRyYW5zZm9ybS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluIC1UaGUgdmFsdWUgdG8gdHJhbnNmb3JtLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgdmFsdWUgdG8gdHJhbnNmb3JtLlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgdHJhbnNmb3JtYXRpb24gKCdsb2cnIG9yICdsaW5lYXInKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdHJhbnNmb3JtVmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSwgbWluLCBtYXgsIHR5cGUgKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGFtcGVkID0gTWF0aC5tYXgoIE1hdGgubWluKCB2YWx1ZSwgbWF4ICksIG1pbiApO1xyXG4gICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwibG9nXCIgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9nTWluID0gbG9nMTAoIG1pbiB8fCAxICk7XHJcbiAgICAgICAgXHRcdHZhciBsb2dNYXggPSBsb2cxMCggbWF4IHx8IDEgKTtcclxuICAgICAgICBcdFx0dmFyIG9uZU92ZXJMb2dSYW5nZSA9IDEgLyAoIChsb2dNYXggLSBsb2dNaW4pIHx8IDEgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoIGxvZzEwKCBjbGFtcGVkIHx8IDEgKSAtIGxvZ01pbiApICogb25lT3ZlckxvZ1JhbmdlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gbWF4IC0gbWluO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICggY2xhbXBlZCAtIG1pbiApIC8gcmFuZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgZm9udCBzaXplIGJhc2VkIG9uIHRoZSBwZXJjZW50YWdlIG9mIHR3ZWV0cyByZWxhdGl2ZSB0byB0aGUgdG90YWwgY291bnRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVuZGVyVXRpbFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBjb3VudCAtIFRoZSBsb2NhbCBjb3VudC5cclxuICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHRvdGFsQ291bnQgLSBUaGUgZ2xvYmFsIGNvdW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IHRvIHNldCBtaW4gYW5kIG1heCBmb250IHNpemUgYW5kIHR5cGUgKG9wdGlvbmFsKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgaW50ZXJwb2xhdGVkIGZvbnQgc2l6ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRGb250U2l6ZTogZnVuY3Rpb24oIHZhbHVlLCBtaW4sIG1heCwgb3B0aW9ucyApIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgIHZhciBNQVhfRk9OVF9TSVpFID0gb3B0aW9ucy5tYXhGb250U2l6ZSB8fCAyMixcclxuICAgICAgICAgICAgICAgIE1JTl9GT05UX1NJWkUgPSBvcHRpb25zLm1pbkZvbnRTaXplIHx8IDEyLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWQgPSB0aGlzLnRyYW5zZm9ybVZhbHVlKCB2YWx1ZSwgbWluLCBtYXgsIG9wdGlvbnMudHlwZSApO1xyXG4gICAgICAgICAgICByZXR1cm4gTUlOX0ZPTlRfU0laRSArIHRyYW5zZm9ybWVkKiggTUFYX0ZPTlRfU0laRSAtIE1JTl9GT05UX1NJWkUgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmF2ZXJzZXMgYW4gb2JqZWN0IHRvIHJldHVybiBhIG5lc3RlZCBhdHRyaWJ1dGVcclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVuZGVyVXRpbFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdG8gdHJhdmVyc2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGF0dHJpYlBhdGggLSBQZXJpb2QgZGVsaW1pdGVkIGF0dHJpYnV0ZSBwYXRoIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG9uZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSBUaGUgbmVzdGVkIHZhbHVlIHdpdGhpbiB0aGUgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEF0dHJpYnV0ZVZhbHVlOiBmdW5jdGlvbiggb2JqLCBhdHRyaWJQYXRoICkge1xyXG4gICAgICAgICAgICB2YXIgYXR0cmlicyxcclxuICAgICAgICAgICAgICAgIGFycmF5U3BsaXQsXHJcbiAgICAgICAgICAgICAgICBhdHRyaWIsXHJcbiAgICAgICAgICAgICAgICBpO1xyXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBhdHRyaWJQYXRoID09PSBcImZ1bmN0aW9uXCIgKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJQYXRoID0gYXR0cmliUGF0aCggb2JqICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXR0cmlicyA9IGF0dHJpYlBhdGguc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgYXR0cmliID0gb2JqO1xyXG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxhdHRyaWJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheVNwbGl0ID0gYXR0cmlic1tpXS5yZXBsYWNlKC8gL2csICcnICkuc3BsaXQoL1tcXFtcXF1dLyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGFycmF5U3BsaXQubGVuZ3RoID09PSAxICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vcm1hbCBhdHRyaWJ1dGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGF0dHJpYnNbaV0ubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmliID0gYXR0cmliWyBhdHRyaWJzW2ldIF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYXJyYXlTcGxpdC5sZW5ndGggPT09IDMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgaW5kZXggZXhwcmVzc2VkLCB1c2UgaXRcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWIgPSBhdHRyaWJbIGFycmF5U3BsaXRbMF0gXVsgYXJyYXlTcGxpdFsxXSBdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB1bnJlY29nbml6ZWQgaW5wdXQsIGRlZmF1bHQgdG8gYXNzdW1wdGlvbiBvZlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vcm1hbCBhdHRyaWJ1dGVcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWIgPSBhdHRyaWJbIGFycmF5U3BsaXRbMF0gXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXR0cmliO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgaGV4IGNvZGUgY29sb3IgdG8gaXRzIFJHQiBjb3VudGVyIHBhcnQuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFJlbmRlclV0aWxcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoZXggLSBUaGUgaGV4IGNvZGUgY29sb3IuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgUkdCIGNvbG9yIHZhbHVlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBoZXhUb1JnYjogZnVuY3Rpb24oaGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBiaWdpbnQ7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSAjXHJcbiAgICAgICAgICAgIGhleCA9IGhleC5yZXBsYWNlKC8jLywgJycpO1xyXG4gICAgICAgICAgICAvLyBpZiBvbmx5IDMgaGV4IHZhbHVlcyBhcmUgcHJvdmlkZWQsIGV4cGFuZCBpbnRvIDYgZGlnaXQgaGV4IGNvZGVcclxuICAgICAgICAgICAgaWYgKCBoZXgubGVuZ3RoID09PSAzICkge1xyXG4gICAgICAgICAgICAgICAgaGV4ID0gaGV4WzBdICsgaGV4WzBdICsgaGV4WzFdICsgaGV4WzFdICsgaGV4WzJdICsgaGV4WzJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJpZ2ludCA9IHBhcnNlSW50KGhleCwgMTYpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcjogKGJpZ2ludCA+PiAxNikgJiAyNTUsXHJcbiAgICAgICAgICAgICAgICBnOiAoYmlnaW50ID4+IDgpICYgMjU1LFxyXG4gICAgICAgICAgICAgICAgYjogYmlnaW50ICYgMjU1XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYW4gUkdCIGNvbG9yIHRvIGl0cyBoZXggY29kZSBjb3VudGVyIHBhcnQuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFJlbmRlclV0aWxcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZ2IgLSBUaGUgUkdCIGNvbG9yLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGhleCBjb2RlIGNvbG9yIHZhbHVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJnYlRvSGV4OiBmdW5jdGlvbiggcmdiICkge1xyXG4gICAgICAgICAgICB2YXIgciA9IHJnYi5yLFxyXG4gICAgICAgICAgICAgICAgZyA9IHJnYi5nLFxyXG4gICAgICAgICAgICAgICAgYiA9IHJnYi5iO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21wb25lbnRUb0hleChjKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGV4ID0gYy50b1N0cmluZygxNik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGhleC5sZW5ndGggPT09IDEpID8gXCIwXCIgKyBoZXggOiBoZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFwiI1wiICsgY29tcG9uZW50VG9IZXgoIE1hdGguZmxvb3IocikpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFRvSGV4KCBNYXRoLmZsb29yKGcpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRUb0hleCggTWF0aC5mbG9vcihiKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5jcmVhc2VzIHRoZSBicmlnaHRuZXNzIG9mIGEgaGV4IGNvZGUgY29sb3IgYnkgYSBwZXJjZW50YWdlIGZhY3RvclxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBSZW5kZXJVdGlsXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGV4IC0gVGhlIGhleCBjb2RlIGNvbG9yLlxyXG4gICAgICAgICAqIEBwYXJhbSB7ZmxvYXR9IGZhY3RvciAtIFRoZSBwZXJjZW50YWdlIGZhY3RvciBvZiBpbmNyZWFzZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBhZGp1c3RlZCBoZXggY29kZSBjb2xvciB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBoZXhCcmlnaHRuZXNzOiBmdW5jdGlvbiggaGV4LCBmYWN0b3IgKSB7XHJcbiAgICAgICAgICAgIHZhciByZ2IgPSB0aGlzLmhleFRvUmdiKCBoZXggKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmdiVG9IZXgoIHsgcjogTWF0aC5taW4oIE1hdGgubWF4KCAwLCByZ2IuciAqIGZhY3RvciApLCAyNTUgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZzogTWF0aC5taW4oIE1hdGgubWF4KCAwLCByZ2IuZyAqIGZhY3RvciApLCAyNTUgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYjogTWF0aC5taW4oIE1hdGgubWF4KCAwLCByZ2IuYiAqIGZhY3RvciApLCAyNTUgKSB9ICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSBoZXggY29kZSBjb2xvciB0byBncmV5c2NhbGUgdXNpbmcgYSBsdW1pbm9zaXR5IGJhc2VkIG1vZGVsXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFJlbmRlclV0aWxcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoZXggLSBUaGUgIGhleCBjb2RlIGNvbG9yLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGdyZXlzY2FsZSBoZXggY29kZSBjb2xvciB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBoZXhHcmV5c2NhbGU6IGZ1bmN0aW9uKCBoZXggKSB7XHJcbiAgICAgICAgICAgIHZhciByZ2IgPSB0aGlzLmhleFRvUmdiKCBoZXggKSxcclxuICAgICAgICAgICAgICAgIGF2ZyA9ICggcmdiLnIgKiAwLjIxICsgcmdiLmcgKiAwLjcyICsgcmdiLmIgKiAwLjA3ICk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJnYlRvSGV4KHtcclxuICAgICAgICAgICAgICAgIHI6IGF2ZyxcclxuICAgICAgICAgICAgICAgIGc6IGF2ZyxcclxuICAgICAgICAgICAgICAgIGI6IGF2Z1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCbGVuZHMgdHdvIGhleCBjb2RlIGNvbG9ycyB0b2dldGhlciwgZGVmYXVsdHMgdG8gNTAvNTAgYmxlbmRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVuZGVyVXRpbFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGhleEEgLSBUaGUgaGV4IGNvZGUgY29sb3IgQS5cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGV4QiAtIFRoZSBoZXggY29kZSBjb2xvciBCLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhSW50b0JQZXJjZW50YWdlIC0gVGhlIHBlcmNlbnRhZ2UgdG8gYmxlbmQgaGV4QSBpbnRvIGhleEIgKG9wdGlvbmFsKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBibGVuZGVkIGhleCBjb2RlIGNvbG9yIHZhbHVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGhleEJsZW5kOiBmdW5jdGlvbiggaGV4QSwgaGV4QiwgYUludG9CUGVyY2VudGFnZSApIHtcclxuICAgICAgICAgICAgdmFyIGFQZXJjID0gKCBhSW50b0JQZXJjZW50YWdlICE9PSB1bmRlZmluZWQgKSA/IE1hdGgubWluKCAxLCBhSW50b0JQZXJjZW50YWdlICkgOiAwLjUsXHJcbiAgICAgICAgICAgICAgICBiUGVyYyA9IDEgLSBhUGVyYyxcclxuICAgICAgICAgICAgICAgIHJnYjEgPSB0aGlzLmhleFRvUmdiKCBoZXhBICksXHJcbiAgICAgICAgICAgICAgICByZ2IyID0gdGhpcy5oZXhUb1JnYiggaGV4QiApO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZ2JUb0hleCh7XHJcbiAgICAgICAgICAgICAgICByIDogKCByZ2IxLnIqYVBlcmMgKyByZ2IyLnIqYlBlcmMgKSxcclxuICAgICAgICAgICAgICAgIGcgOiAoIHJnYjEuZyphUGVyYyArIHJnYjIuZypiUGVyYyApLFxyXG4gICAgICAgICAgICAgICAgYiA6ICggcmdiMS5iKmFQZXJjICsgcmdiMi5iKmJQZXJjIClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG59KCkpO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi9SZW5kZXJlcicpLFxyXG4gICAgICAgIFJlbmRlcmVyVXRpbCA9IHJlcXVpcmUoJy4vUmVuZGVyZXJVdGlsJyksXHJcbiAgICAgICAgTUFYX1dPUkRTX0RJU1BMQVlFRCA9IDgsXHJcbiAgICAgICAgZ2V0WU9mZnNldCxcclxuICAgICAgICBnZXRIaWdoZXN0Q291bnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBwb3NpdGlvbmluZyB0aGUgbGFiZWxzXHJcbiAgICAgKi9cclxuICAgIGdldFlPZmZzZXQgPSBmdW5jdGlvbiggaW5kZXgsIG51bUVudHJpZXMsIHNwYWNpbmcgKSB7XHJcbiAgICAgICAgcmV0dXJuIDExOCAtICggKCggbnVtRW50cmllcyAtIDEpIC8gMiApIC0gaW5kZXggKSAqIHNwYWNpbmc7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBnZXQgdGhlIGhpZ2hlc3QgY291bnQgZm9yIGEgdG9waWMgaW4gdGhlIHRpbGVcclxuICAgICAqL1xyXG4gICAgZ2V0SGlnaGVzdENvdW50ID0gZnVuY3Rpb24oIHZhbHVlcywgY291bnRLZXkgKSB7XHJcbiAgICAgICAgLy8gZ2V0IHRoZSBoaWdoZXN0IHNpbmdsZSBjb3VudFxyXG4gICAgICAgIHZhciBoaWdoZXN0Q291bnQgPSAwLFxyXG4gICAgICAgICAgICBjb3VudHMgPSBSZW5kZXJlclV0aWwuZ2V0QXR0cmlidXRlVmFsdWUoIHZhbHVlcywgY291bnRLZXkgKSxcclxuICAgICAgICAgICAgajtcclxuICAgICAgICBmb3IgKCBqPTA7IGo8Y291bnRzLmxlbmd0aDsgaisrICkge1xyXG4gICAgICAgICAgICAvLyBnZXQgaGlnaGVzdCBjb3VudFxyXG4gICAgICAgICAgICBoaWdoZXN0Q291bnQgPSBNYXRoLm1heCggaGlnaGVzdENvdW50LCBjb3VudHNbal0gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhpZ2hlc3RDb3VudDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW50aWF0ZSBhIFRleHRCeUZyZXF1ZW5jeVJlbmRlcmVyIG9iamVjdC5cclxuICAgICAqIEBjbGFzcyBUZXh0QnlGcmVxdWVuY3lSZW5kZXJlclxyXG4gICAgICogQGF1Z21lbnRzIFJlbmRlcmVyXHJcbiAgICAgKiBAY2xhc3NEZXNjIEEgUmVuZGVyZXIgaW1wbGVtZW50YXRpb24gdGhhdCByZW5kZXJzIGEgaGlzdG9ncmFtIG9mIHRoZSBmcmVxdWVuY3kgb2ZcclxuICAgICAqIGEgcGFydGljdWxhciB0b3BpYyBvdmVyIHRpbWUsIHdpdGggdGhlIHRvcGljIHRleHQgbmV4dCB0byBpdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3BlYyB7T2JqZWN0fSBUaGUgc3BlY2lmaWNhdGlvbiBvYmplY3QuXHJcbiAgICAgKiA8cHJlPlxyXG4gICAgICoge1xyXG4gICAgICogICAgIHRleHQ6IHtcclxuICAgICAqICAgICAgICAgdGV4dEtleSAge1N0cmluZ3xGdW5jdGlvbn0gLSBUaGUgYXR0cmlidXRlIGZvciB0aGUgdGV4dCBpbiB0aGUgZGF0YSBlbnRyeS5cclxuICAgICAqICAgICAgICAgdGhlbWVzICAge0FycmF5fSAgLSBUaGUgYXJyYXkgb2YgUmVuZGVyVGhlbWVzIHRvIGJlIGF0dGFjaGVkIHRvIHRoaXMgY29tcG9uZW50LlxyXG4gICAgICogICAgIH0sXHJcbiAgICAgKiAgICAgZnJlcXVlbmN5OiB7XHJcbiAgICAgKiAgICAgICAgIGNvdW50S2V5IHtTdHJpbmd8RnVuY3Rpb259IC0gVGhlIGF0dHJpYnV0ZSBmb3IgdGhlIGNvdW50IGluIHRoZSBkYXRhIGVudHJ5LlxyXG4gICAgICogICAgICAgICB0aGVtZXMgICB7QXJyYXl9ICAtIFRoZSBhcnJheSBvZiBSZW5kZXJUaGVtZXMgdG8gYmUgYXR0YWNoZWQgdG8gdGhpcyBjb21wb25lbnQuXHJcbiAgICAgKiAgICAgICAgIGludmVydE9yZGVyIHtCb29sZWFufSAtIFRoZSBib29sZWFuIHRvIGRldGVybWluZSBvcmRlciBvZiBjaGFydCB2YWx1ZXMuICBEZWZhdWx0cyB0byBmYWxzZSBpZiBub3QgcHJlc2VudFxyXG4gICAgICogICAgIH1cclxuICAgICAqIH1cclxuICAgICAqIDwvcHJlPlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBUZXh0QnlGcmVxdWVuY3lSZW5kZXJlciggc3BlYyApIHtcclxuICAgICAgICBzcGVjLnJvb3RLZXkgPSBzcGVjLnJvb3RLZXkgfHwgXCJ0aWxlLm1ldGEuYWdncmVnYXRlZFwiO1xyXG4gICAgICAgIHNwZWMuZnJlcXVlbmN5LmludmVydE9yZGVyID0gc3BlYy5mcmVxdWVuY3kuaW52ZXJ0T3JkZXIgfHwgZmFsc2U7XHJcbiAgICAgICAgUmVuZGVyZXIuY2FsbCggdGhpcywgc3BlYyApO1xyXG4gICAgICAgIHRoaXMuaW5qZWN0Q3NzKCB0aGlzLnNwZWMgKTtcclxuICAgIH1cclxuXHJcbiAgICBUZXh0QnlGcmVxdWVuY3lSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSZW5kZXJlci5wcm90b3R5cGUgKTtcclxuXHJcbiAgICBUZXh0QnlGcmVxdWVuY3lSZW5kZXJlci5wcm90b3R5cGUuZ2V0RW50cnlTZWxlY3RvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBcIi50ZXh0LWJ5LWZyZXF1ZW5jeS1sYWJlbFwiO1xyXG4gICAgfTtcclxuXHJcbiAgICBUZXh0QnlGcmVxdWVuY3lSZW5kZXJlci5wcm90b3R5cGUuaW5qZWN0Q3NzID0gZnVuY3Rpb24oIHNwZWMgKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKCBzcGVjLnRleHQudGhlbWVzICkge1xyXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwZWMudGV4dC50aGVtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBzcGVjLnRleHQudGhlbWVzW2ldLmluamVjdFRoZW1lKHtcclxuICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IFwiLnRleHQtYnktZnJlcXVlbmN5LWxhYmVsXCIsXHJcbiAgICAgICAgICAgICAgICAgIHBhcmVudFNlbGVjdG9yOiBcIi50ZXh0LWJ5LWZyZXF1ZW5jeS1lbnRyeVwiXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggc3BlYy5mcmVxdWVuY3kudGhlbWVzICkge1xyXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwZWMuZnJlcXVlbmN5LnRoZW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIHNwZWMuZnJlcXVlbmN5LnRoZW1lc1tpXS5pbmplY3RUaGVtZSh7XHJcbiAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBcIi50ZXh0LWJ5LWZyZXF1ZW5jeS1iYXJcIixcclxuICAgICAgICAgICAgICAgICAgcGFyZW50U2VsZWN0b3I6IFwiLnRleHQtYnktZnJlcXVlbmN5LWVudHJ5XCJcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFRleHRCeUZyZXF1ZW5jeVJlbmRlcmVyLnByb3RvdHlwZS5nZXRCYXJTdHlsZUNsYXNzID0gZnVuY3Rpb24gKHZhbHVlLCBjb3VudEluZGV4LCByZWxhdGl2ZVBlcmNlbnQpIHtcclxuICAgICAgICAvLyBjbGFzcyBwZXJjZW50IGluIGluY3JlbWVudHMgb2YgMTBcclxuICAgICAgICB2YXIgcGVyY2VudExhYmVsID0gTWF0aC5yb3VuZCggcmVsYXRpdmVQZXJjZW50IC8gMTAgKSAqIDEwO1xyXG4gICAgICAgIHJldHVybiAndGV4dC1ieS1mcmVxdWVuY3ktYmFyIHRleHQtYnktZnJlcXVlbmN5LWJhci0nICsgcGVyY2VudExhYmVsO1xyXG4gICAgfTtcclxuXHJcbiAgICBUZXh0QnlGcmVxdWVuY3lSZW5kZXJlci5wcm90b3R5cGUuZ2V0VGV4dFN0eWxlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICd0ZXh0LWJ5LWZyZXF1ZW5jeS1sYWJlbCc7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcmVuZGVyaW5nIGZ1bmN0aW9uLlxyXG4gICAgICogQG1lbWJlcm9mIFRleHRCeUZyZXF1ZW5jeVJlbmRlcmVyXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIHJhdyBkYXRhIGZvciBhIHRpbGUgdG8gYmUgcmVuZGVyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3todG1sOiBzdHJpbmcsIGVudHJpZXM6IEFycmF5fX0gVGhlIGh0bWwgdG8gcmVuZGVyIGFuZCBhbiBhcnJheSBvZiBhbGwgcmVuZGVyZWQgZGF0YSBlbnRyaWVzLlxyXG4gICAgICovXHJcbiAgICBUZXh0QnlGcmVxdWVuY3lSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oIGRhdGEgKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICBtaW5Gb250U2l6ZSA9IDE0LFxyXG4gICAgICAgICAgICBtYXhGb250U2l6ZSA9IDI0LFxyXG4gICAgICAgICAgICBzcGFjaW5nID0gMjAsXHJcbiAgICAgICAgICAgIHRleHRLZXkgPSB0aGlzLnNwZWMudGV4dC50ZXh0S2V5LFxyXG4gICAgICAgICAgICBmcmVxdWVuY3kgPSB0aGlzLnNwZWMuZnJlcXVlbmN5LFxyXG4gICAgICAgICAgICBjb3VudEtleSA9IGZyZXF1ZW5jeS5jb3VudEtleSxcclxuICAgICAgICAgICAgaW52ZXJ0T3JkZXIgPSBmcmVxdWVuY3kuaW52ZXJ0T3JkZXIsXHJcbiAgICAgICAgICAgIHZhbHVlcyA9IFJlbmRlcmVyVXRpbC5nZXRBdHRyaWJ1dGVWYWx1ZSggZGF0YSwgdGhpcy5zcGVjLnJvb3RLZXkgKSxcclxuICAgICAgICAgICAgbnVtRW50cmllcyA9IE1hdGgubWluKCB2YWx1ZXMubGVuZ3RoLCBNQVhfV09SRFNfRElTUExBWUVEICksXHJcbiAgICAgICAgICAgIGxldmVsTWluTWF4ID0gdGhpcy5wYXJlbnQuZ2V0TGV2ZWxNaW5NYXgoKSxcclxuICAgICAgICAgICAgYmFyU3R5bGVDbGFzcyxcclxuICAgICAgICAgICAgJGh0bWwgPSAkKFwiPGRpdj48L2Rpdj5cIiksXHJcbiAgICAgICAgICAgIGVudHJpZXMgPSBbXSxcclxuICAgICAgICAgICAgbWluID0gMCxcclxuICAgICAgICAgICAgbWF4ID0gMCxcclxuICAgICAgICAgICAgdGV4dCxcclxuICAgICAgICAgICAgaGlnaGVzdENvdW50LFxyXG4gICAgICAgICAgICBjb3VudHMsXHJcbiAgICAgICAgICAgIHJlbGF0aXZlUGVyY2VudCxcclxuICAgICAgICAgICAgY2hhcnRTaXplLFxyXG4gICAgICAgICAgICB2aXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgaiA9IDA7XHJcblxyXG4gICAgICAgIHZhciAkbGFiZWwgPSAkKCc8ZGl2IGNsYXNzPVwiY291bnQtc3VtbWFyeVwiPjwvZGl2PicpO1xyXG4gICAgICAgICRodG1sID0gJGh0bWwuYXBwZW5kKCAkbGFiZWwgKTtcclxuXHJcbiAgICAgICAgLy8gaWYgem9vbSBsZXZlbCBtYXggaXMgaW4gbWV0YSwgdXNlIGl0LCBvdGhlcndpc2UgY2FsYyBpdCBmcm9tIHRpbGVcclxuICAgICAgICBpZiAoIGxldmVsTWluTWF4Lm1heGltdW0gKSB7XHJcbiAgICAgICAgICAgIG1heCA9IGdldEhpZ2hlc3RDb3VudCggbGV2ZWxNaW5NYXgubWF4aW11bSwgY291bnRLZXkgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCggZnVuY3Rpb24oIHZhbHVlICkge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgoIG1heCwgUmVuZGVyZXJVdGlsLmdldEF0dHJpYnV0ZVZhbHVlKCB2YWx1ZSwgY291bnRLZXkgKSApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG5cdCAgICAgIHZhbHVlcyA9IHZhbHVlcy5zbGljZSggMCwgbnVtRW50cmllcyApO1xyXG4gICAgICAgIHZhbHVlcy5mb3JFYWNoICggZnVuY3Rpb24oIHZhbHVlICkge1xyXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goIHZhbHVlICk7XHJcbiAgICAgICAgICAgIGNvdW50cyA9IFJlbmRlcmVyVXRpbC5nZXRBdHRyaWJ1dGVWYWx1ZSggdmFsdWUsIGNvdW50S2V5ICk7XHJcbiAgICAgICAgICAgIHRleHQgPSBSZW5kZXJlclV0aWwuZ2V0QXR0cmlidXRlVmFsdWUoIHZhbHVlLCB0ZXh0S2V5ICk7XHJcbiAgICAgICAgICAgIGNoYXJ0U2l6ZSA9IGNvdW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIC8vIGhpZ2hlc3QgY291bnQgZm9yIHRoZSB0b3BpY1xyXG4gICAgICAgICAgICBoaWdoZXN0Q291bnQgPSBnZXRIaWdoZXN0Q291bnQoIHZhbHVlLCBjb3VudEtleSApO1xyXG4gICAgICAgICAgICAvLyBzY2FsZSB0aGUgaGVpZ2h0IGJhc2VkIG9uIGxldmVsIG1pbiAvIG1heFxyXG4gICAgICAgICAgICBoZWlnaHQgPSBSZW5kZXJlclV0aWwuZ2V0Rm9udFNpemUoXHJcbiAgICAgICAgICAgICAgICBoaWdoZXN0Q291bnQsXHJcbiAgICAgICAgICAgICAgICBtaW4sXHJcbiAgICAgICAgICAgICAgICBtYXgsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluRm9udFNpemU6IG1pbkZvbnRTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heEZvbnRTaXplOiBtYXhGb250U2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImxvZ1wiXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0XHRcdCAgICAgIC8vIGNyZWF0ZSBjb250YWluZXIgJ2VudHJ5JyBmb3IgY2hhcnQgYW5kIGhhc2h0YWdcclxuICAgICAgICAgICAgdmFyIGh0bWxfc3RyaW5nID0gJyc7XHJcbiAgICAgICAgICAgICAgICBodG1sX3N0cmluZyArPSAnPGRpdiBjbGFzcz1cInRleHQtYnktZnJlcXVlbmN5LWVudHJ5XCIgJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgKyAnc3R5bGU9XCInXHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgY29uc3RhbnQgc3BhY2luZyBpbmRlcGVuZGVudCBvZiBoZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICsgJ3RvcDonICsgKCBnZXRZT2Zmc2V0KCBpLCBudW1FbnRyaWVzLCBzcGFjaW5nICkgKyAoIG1heEZvbnRTaXplIC0gaGVpZ2h0ICkgKSArICdweDsnXHJcbiAgICAgICAgICAgICAgICAgICAgICArICdoZWlnaHQ6JyArIGhlaWdodCArICdweFwiPjwvZGl2Pic7XHJcblx0XHRcdCAgICAgIHZhciAkZW50cnkgPSAkKGh0bWxfc3RyaW5nKTtcclxuXHJcbiAgICAgICAgICAgICRlbnRyeS5tb3VzZW92ZXIoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAkbGFiZWwuc2hvdygpOyAvLyBzaG93IGxhYmVsXHJcbiAgICAgICAgICAgICAgICAkbGFiZWwudGV4dCggdmFsdWUuY291bnQgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICRlbnRyeS5tb3VzZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICRsYWJlbC5oaWRlKCk7IC8vIGhpZGUgbGFiZWxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgY2hhcnRcclxuXHRcdFx0ICAgICAgdmFyICRjaGFydCA9ICQoJzxkaXYgY2xhc3M9XCJ0ZXh0LWJ5LWZyZXF1ZW5jeS1sZWZ0XCI+PC9kaXY+Jyk7XHJcblxyXG4gICAgICAgICAgICBjb3VudHMuZm9yRWFjaCAoIGZ1bmN0aW9uKCBjb3VudCwgY291bnRJbmRleCApIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIGludmVydE9yZGVyIGlzIHRydWUsIGludmVydCB0aGUgb3JkZXIgb2YgaXRlcmF0aW9uXHJcbiAgICAgICAgICAgICAgICBpbmRleCA9ICggaW52ZXJ0T3JkZXIgKSA/IGNoYXJ0U2l6ZSAtIGogLSAxIDogajtcclxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgcGVyY2VudCByZWxhdGl2ZSB0byB0aGUgaGlnaGVzdCBjb3VudCBpbiB0aGUgdGlsZVxyXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVQZXJjZW50ID0gKCBjb3VudCAvIGhpZ2hlc3RDb3VudCApICogMTAwO1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgcGVyY2VudCA9PT0gMCwgaGlkZSBiYXJcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHkgPSAoIHJlbGF0aXZlUGVyY2VudCA+IDAgKSA/ICcnIDogJ2hpZGRlbic7XHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHN0eWxlIGNsYXNzIG9mIHRoZSBiYXJcclxuICAgICAgICAgICAgICAgIGJhclN0eWxlQ2xhc3MgPSBzZWxmLmdldEJhclN0eWxlQ2xhc3ModmFsdWUsIGNvdW50SW5kZXgsIHJlbGF0aXZlUGVyY2VudCk7XHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgbWluaW11bSBiYXIgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVBlcmNlbnQgPSBNYXRoLm1heCggcmVsYXRpdmVQZXJjZW50LCAyMCApO1xyXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGJhclxyXG4gICAgICAgICAgICAgICAgdmFyIGJhcl9zdHJpbmcgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyX3N0cmluZyArPSAnPGRpdiAnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArICdjbGFzcz1cIicgKyBiYXJTdHlsZUNsYXNzICsgJ1wiICdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJ3N0eWxlPVwiJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAndmlzaWJpbGl0eTonK3Zpc2liaWxpdHkrJzsnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArICdoZWlnaHQ6JytyZWxhdGl2ZVBlcmNlbnQrJyU7J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnd2lkdGg6JysgTWF0aC5mbG9vciggKDEwNStjaGFydFNpemUpL2NoYXJ0U2l6ZSApICsncHg7J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAndG9wOicrKDEwMC1yZWxhdGl2ZVBlcmNlbnQpKyclO1wiPjwvZGl2Pic7XHJcbiAgICAgICAgICAgICAgICB2YXIgJGNoYXJ0QmFyID0gJChiYXJfc3RyaW5nKTtcclxuICAgICAgICAgICAgICAgICRjaGFydC5hcHBlbmQoJGNoYXJ0QmFyKTtcclxuICAgICAgICAgICAgICAgIGogKz0gMTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG5cdFx0XHQgICAgICAkZW50cnkuYXBwZW5kKCAkY2hhcnQgKTtcclxuICAgICAgICAgICAgLy8gY3JlYXRlIHRhZyBsYWJlbFxyXG5cdFx0XHQgICAgICB2YXIgJGxhYmVsVGFnID0gJCgnPGRpdiBjbGFzcz1cInRleHQtYnktZnJlcXVlbmN5LXJpZ2h0XCI+PC9kaXY+Jyk7XHJcblx0XHRcdCAgICAgIHZhciBsYWJlbF9zdHJpbmcgPSAnJztcclxuICAgICAgICAgICAgICAgIGxhYmVsX3N0cmluZyArPSAnPGRpdiBjbGFzcz1cIicgKyBzZWxmLmdldFRleHRTdHlsZUNsYXNzKHZhbHVlKSArICdcIiBzdHlsZT1cIicgK1xyXG4gICAgICAgICAgICAgICAgICAgICdmb250LXNpemU6JytoZWlnaHQrJ3B4OycgK1xyXG4gICAgICAgICAgICAgICAgICAgICdsaW5lLWhlaWdodDonK2hlaWdodCsncHg7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2hlaWdodDonK2hlaWdodCsncHhcIj4nK3RleHQrJzwvZGl2Pic7XHJcbiAgICAgICAgICAgIHZhciAkbGFiZWxUZXh0ID0gJChsYWJlbF9zdHJpbmcpO1xyXG4gICAgICAgICAgICAkbGFiZWxUYWcuYXBwZW5kKCAkbGFiZWxUZXh0ICk7XHJcbiAgICAgICAgICAgICRlbnRyeS5hcHBlbmQoICRsYWJlbFRhZyApO1xyXG5cclxuICAgICAgICAgICAgJGh0bWwuYXBwZW5kKCRlbnRyeSk7XHJcbiAgICAgICAgICAgIGkgKz0gMTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaHRtbDogJGh0bWwsXHJcbiAgICAgICAgICAgIGVudHJpZXM6IGVudHJpZXNcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRleHRCeUZyZXF1ZW5jeVJlbmRlcmVyO1xyXG59KCkpO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHdvcmQgY2xvdWQgcmVuZGVyZXIuIFVzZXMgYSBzZXQgb2Ygd29yZHMgYW5kIHRoZWlyIGNvdW50cyB0byBnZW5lcmF0ZSBhIHdvcmQgY2xvdWQuXHJcbiAqL1xyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBSZW5kZXJlciA9IHJlcXVpcmUoJy4vUmVuZGVyZXInKSxcclxuXHRcdGNyZWF0ZVRvcGljV29yZHNBcnJheXMsXHJcbiAgICAgICAgaW5qZWN0Q3NzO1xyXG5cclxuICAgIGluamVjdENzcyA9IGZ1bmN0aW9uKCBzcGVjICkge1xyXG4gICAgICAgIHZhciBpLCBqO1xyXG4gICAgICAgIGlmICggc3BlYy50ZXh0LnRoZW1lcyApIHtcclxuXHRcdFx0Ly8gZm9yIGVhY2ggcGFpciBvZiBsaWdodCBhbmQgZGFyayB0aGVtZXMsIGluamVjdCB0aGVtZVxyXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHNwZWMudGV4dC50aGVtZXMubGVuZ3RoOyBpKysgKSB7XHJcblx0XHRcdFx0dmFyIHRoZW1lUGFpciA9IHNwZWMudGV4dC50aGVtZXNbIGkgXTtcclxuXHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IHRoZW1lUGFpci5sZW5ndGg7IGorKyApIHtcclxuXHRcdFx0XHRcdHRoZW1lUGFpcltqXS5pbmplY3RUaGVtZSh7XHJcblx0XHRcdFx0XHRcdHNlbGVjdG9yOiAnLnRleHQtdG9waWMtJyArIGkgKyAnLWxhYmVsJ1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblx0LyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gYXJyYXkgb2YgdGV4dCB3b3JkcyBmb3IgZWFjaCB0b3BpYyBiYXNlZCBvbiB0aGUgZW50cnkncyB0b3BpYyBudW1iZXJcclxuICAgICAqL1xyXG5cdGNyZWF0ZVRvcGljV29yZHNBcnJheXMgPSBmdW5jdGlvbiggZW50cmllcywgbnVtVG9waWNzICkge1xyXG5cdFx0dmFyIHRvcGljV29yZHNBcnJheSA9IFtdO1xyXG5cdFx0XHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBudW1Ub3BpY3M7IGkrKyApIHtcclxuXHRcdFx0dG9waWNXb3Jkc0FycmF5W2ldID0gW107XHJcblx0XHR9XHJcblxyXG5cdFx0ZW50cmllcy5mb3JFYWNoKCBmdW5jdGlvbiggZW50cnkgKSB7XHJcblx0XHRcdHRvcGljV29yZHNBcnJheVsgZW50cnkudG9waWNOdW1iZXIgXS5wdXNoKCBlbnRyeS50b3BpYyApO1xyXG5cdFx0fSk7XHRcclxuXHRcdFxyXG5cdFx0cmV0dXJuIHRvcGljV29yZHNBcnJheTtcclxuXHR9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGUgYSBUZXh0QnlUb3BpY1JlbmRlcmVyIG9iamVjdC5cclxuICAgICAqIEBjbGFzcyBUZXh0QnlUb3BpY1JlbmRlcmVyXHJcbiAgICAgKiBAYXVnbWVudHMgUmVuZGVyZXJcclxuICAgICAqIEBjbGFzc0Rlc2MgQSBSZW5kZXJlciBpbXBsZW1lbnRhdGlvbiB0aGF0IHJlbmRlcnMgYSB3b3JkIGNsb3VkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzcGVjIHtPYmplY3R9IFRoZSBzcGVjaWZpY2F0aW9uIG9iamVjdC5cclxuICAgICAqIDxwcmU+XHJcbiAgICAgKiAgICAgdGV4dDoge1xyXG4gICAgICogICAgICAgICB0ZXh0S2V5ICAge1N0cmluZ3xGdW5jdGlvbn0gLSBUaGUgYXR0cmlidXRlIGZvciB0aGUgdGV4dCBpbiB0aGUgZGF0YSBlbnRyeS5cclxuICAgICAqICAgICAgICAgdGhlbWVzICAgIHtBcnJheX0gIC0gVGhlIGFycmF5IG9mIFJlbmRlclRoZW1lcyB0byBiZSBhdHRhY2hlZCB0byB0aGlzIGNvbXBvbmVudC5cclxuXHQgKiAgICAgICAgIG51bVRvcGljcyB7aW50ZWdlcn0gLSBudW1iZXIgb2YgdG9waWNzIHRvIGJpbiB0aGUgdGV4dCB3b3JkcyB1bmRlclxyXG4gICAgICogICAgIH1cclxuICAgICAqIH1cclxuICAgICAqIDwvcHJlPlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBUZXh0QnlUb3BpY1JlbmRlcmVyKCBzcGVjICkge1xyXG4gICAgICAgIHNwZWMucm9vdEtleSA9IHNwZWMucm9vdEtleSB8fCBcInRpbGUubWV0YS5yYXdcIjtcclxuICAgICAgICBzcGVjLnRleHQgPSBzcGVjLnRleHQgfHwge307XHJcbiAgICAgICAgUmVuZGVyZXIuY2FsbCggdGhpcywgc3BlYyApO1xyXG4gICAgICAgIGluamVjdENzcyggdGhpcy5zcGVjICk7XHJcbiAgICB9XHJcblxyXG4gICAgVGV4dEJ5VG9waWNSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSZW5kZXJlci5wcm90b3R5cGUgKTtcclxuXHJcblx0VGV4dEJ5VG9waWNSZW5kZXJlci5wcm90b3R5cGUuZ2V0RW50cnlTZWxlY3RvciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIFwiLnRleHQtYnktdG9waWMtbGFiZWxcIjtcclxuXHR9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcmVuZGVyaW5nIGZ1bmN0aW9uLlxyXG4gICAgICogQG1lbWJlcm9mIFRleHRCeVRvcGljUmVuZGVyZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSByYXcgZGF0YSBmb3IgYSB0aWxlIHRvIGJlIHJlbmRlcmVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt7aHRtbDogc3RyaW5nLCBlbnRyaWVzOiBBcnJheX19IFRoZSBodG1sIHRvIHJlbmRlciBhbmQgYW4gYXJyYXkgb2YgYWxsIHJlbmRlcmVkIGRhdGEgZW50cmllcy5cclxuICAgICAqL1xyXG4gICAgVGV4dEJ5VG9waWNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oIGRhdGEgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5zcGVjLnRleHQsXHJcbiAgICAgICAgICAgIHRleHRLZXkgPSB0ZXh0LnRleHRLZXksXHJcblx0XHRcdG51bVRvcGljcyA9IHRleHQubnVtVG9waWNzID8gdGV4dC5udW1Ub3BpY3MgOiAzLFxyXG4gICAgICAgICAgICBlbnRyaWVzID0gZGF0YS50aWxlLm1ldGEucmF3WzBdLFxyXG5cdFx0XHQkaHRtbCA9ICQoJzxkaXYgY2xhc3M9XCJ0ZXh0LWJ5LXRvcGljLWJveFwiPjwvZGl2PicpLFxyXG5cdFx0XHR0b3BpY1dvcmRzID0gW10sXHJcblx0XHRcdGluZGV4ID0gMSxcclxuICAgICAgICAgICAgaSwgajtcclxuXHRcclxuXHRcdC8vIG5lZWQgdG8gZ2V0IHRoZSBmaXJzdCBub24tbnVsbCBhcnJheSBpbiB0aGUgcmF3IGRhdGFcclxuXHRcdHdoaWxlICggZW50cmllcyA9PT0gbnVsbCAmJiBpbmRleCA8IGRhdGEudGlsZS5tZXRhLnJhdy5sZW5ndGggKSB7XHJcblx0XHRcdGVudHJpZXMgPSBkYXRhLnRpbGUubWV0YS5yYXdbaW5kZXhdO1xyXG5cdFx0XHRpbmRleCsrO1xyXG5cdFx0fVxyXG4gICAgICAgIHRvcGljV29yZHMgPSBjcmVhdGVUb3BpY1dvcmRzQXJyYXlzKCBlbnRyaWVzLCBudW1Ub3BpY3MsIHRleHRLZXkgKTtcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IG51bVRvcGljczsgaSsrICkge1xyXG5cdFx0XHR2YXIgd29yZHMgPSB0b3BpY1dvcmRzW2ldLFxyXG5cdFx0XHRcdHdvcmRzU3RyaW5nID0gJyc7XHJcblx0XHRcdFx0XHJcblx0XHRcdGZvciAoIGogPSAwOyBqIDwgd29yZHMubGVuZ3RoOyBqKysgKSB7XHJcblx0XHRcdFx0d29yZHNTdHJpbmcgKz0gd29yZHNbal0gKyAnICc7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyICR3b3Jkc19odG1sID0gJCgnPGRpdiBjbGFzcz1cInRleHQtdG9waWMtJyArIGkgKyAnLWxhYmVsIHRleHQtdG9waWMtbGFiZWxcIj4nICsgd29yZHNTdHJpbmcgKyAnPC9kaXY+Jyk7XHJcblxyXG5cdFx0XHQvLyBhZGQgaXQgdG8gdGhlIGdyb3VwXHJcblx0XHRcdCRodG1sID0gJGh0bWwuYXBwZW5kKCAkd29yZHNfaHRtbCApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaHRtbDogJGh0bWwsXHJcbiAgICAgICAgICAgIGVudHJpZXM6IGVudHJpZXNcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRleHRCeVRvcGljUmVuZGVyZXI7XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMyBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgUmVuZGVyZXIgPSByZXF1aXJlKCcuL1JlbmRlcmVyJyksXHJcbiAgICAgICAgUmVuZGVyZXJVdGlsID0gcmVxdWlyZSgnLi9SZW5kZXJlclV0aWwnKSxcclxuICAgICAgICBNQVhfV09SRFNfRElTUExBWUVEID0gNSxcclxuICAgICAgICBNQVhfQkFSX1dJRFRIID0gMTEwLFxyXG4gICAgICAgIGluamVjdENzcztcclxuXHJcbiAgICBpbmplY3RDc3MgPSBmdW5jdGlvbiggc3BlYyApIHtcclxuICAgICAgICB2YXIgaSwgajtcclxuICAgICAgICBpZiAoIHNwZWMudGV4dC50aGVtZXMgKSB7XHJcbiAgICAgICAgICAgIGZvciAoIGk9MDsgaTxzcGVjLnRleHQudGhlbWVzLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgc3BlYy50ZXh0LnRoZW1lc1tpXS5pbmplY3RUaGVtZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IFwiLnRleHQtc2NvcmUtbGFiZWxcIixcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRTZWxlY3RvcjogXCIudGV4dC1zY29yZS1lbnRyeVwiXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHNwZWMudGV4dC50aGVtZXNbaV0uaW5qZWN0VGhlbWUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBcIi50ZXh0LXNjb3JlLWVudHJ5LWNvdW50XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50U2VsZWN0b3I6IFwiLnRleHQtc2NvcmUtZW50cnlcIlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICggaT0wOyBpPHNwZWMud2VpZ2h0cy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIGZvciAoIGo9MDsgajxzcGVjLndlaWdodHNbaV0udGhlbWVzLmxlbmd0aDsgaisrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwZWMud2VpZ2h0c1tpXS50aGVtZXNbal0uaW5qZWN0VGhlbWUoIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IFwiLnRleHQtc2NvcmUtd2VpZ2h0LVwiICsgaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50U2VsZWN0b3I6IFwiLnRleHQtc2NvcmUtZW50cnlcIlxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbnRpYXRlIGEgVGV4dFNjb3JlUmVuZGVyZXIgb2JqZWN0LlxyXG4gICAgICogQGNsYXNzIFRleHRTY29yZVJlbmRlcmVyXHJcbiAgICAgKiBAYXVnbWVudHMgUmVuZGVyZXJcclxuICAgICAqIEBjbGFzc0Rlc2MgQSBSZW5kZXJlciBpbXBsZW1lbnRhdGlvbiB0aGF0IHJlbmRlcnMgYSB0ZXh0IGxhYmVsIHNjYWxlZCBieSBpdHNcclxuICAgICAqIGZyZXF1ZW5jeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3BlYyB7T2JqZWN0fSBUaGUgc3BlY2lmaWNhdGlvbiBvYmplY3QuXHJcbiAgICAgKiA8cHJlPlxyXG4gICAgICoge1xyXG4gICAgICogICAgIHRleHQ6IHtcclxuICAgICAqICAgICAgICAgdGV4dEtleSAge1N0cmluZ3xGdW5jdGlvbn0gLSBUaGUgYXR0cmlidXRlIGZvciB0aGUgdGV4dCBpbiB0aGUgZGF0YSBlbnRyeS5cclxuICAgICAqICAgICAgICAgY291bnRLZXkge1N0cmluZ3xGdW5jdGlvbn0gLSBUaGUgYXR0cmlidXRlIGZvciB0aGUgY291bnQgaW4gdGhlIGRhdGEgZW50cnkuXHJcbiAgICAgKiAgICAgICAgIHRoZW1lcyAgIHtBcnJheX0gIC0gVGhlIGFycmF5IG9mIFJlbmRlclRoZW1lcyB0byBiZSBhdHRhY2hlZCB0byB0aGlzIGNvbXBvbmVudC5cclxuICAgICAqICAgICB9LFxyXG4gICAgICogICAgIHdlaWdodHM6IFt7XHJcbiAgICAgKiAgICAgICAgIHdlaWdodEtleSB7QXJyYXl8RnVuY3Rpb259IC0gVGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSB3ZWlnaHRzIGluIHRoZSBkYXRhIGVudHJ5XHJcbiAgICAgKiAgICAgICAgIHRoZW1lcyAgICB7QXJyYXl9ICAtIFRoZSBhcnJheSBvZiBSZW5kZXJUaGVtZXMgdG8gYmUgYXR0YWNoZWQgdG8gdGhpcyBjb21wb25lbnQuXHJcbiAgICAgKiAgICAgfV0sXHJcbiAgICAgKiAgICAgdGhyZXNob2xkOiB7bnVtYmVyfSAtIFRoZSBjb3VudCB0aHJlc2hvbGQgYXQgd2hpY2ggdG8gZGUtc2F0dXJhdGUgdGhlIGNvbG9ycy5cclxuICAgICAqIH1cclxuICAgICAqIDwvcHJlPlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBUZXh0U2NvcmVXZWlnaHRlZFJlbmRlcmVyKCBzcGVjICkge1xyXG4gICAgICAgIHNwZWMucm9vdEtleSA9IHNwZWMucm9vdEtleSB8fCBcInRpbGUubWV0YS5hZ2dyZWdhdGVkXCI7XHJcbiAgICAgICAgUmVuZGVyZXIuY2FsbCggdGhpcywgc3BlYyApO1xyXG4gICAgICAgIGluamVjdENzcyggdGhpcy5zcGVjICk7XHJcbiAgICB9XHJcblxyXG4gICAgVGV4dFNjb3JlV2VpZ2h0ZWRSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSZW5kZXJlci5wcm90b3R5cGUgKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGVudHJ5IHNlbGVjdG9yIHVuaXF1ZSB0byB0aGlzIFJlbmRlcmVyIEltcGxlbWVudGF0aW9uLlxyXG4gICAgICogQG1lbWJlcm9mIFRleHRTY29yZVJlbmRlcmVyXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBlbnRyeSBET00gc2VsZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIFRleHRTY29yZVdlaWdodGVkUmVuZGVyZXIucHJvdG90eXBlLmdldEVudHJ5U2VsZWN0b3IgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gXCIudGV4dC1zY29yZS1lbnRyeVwiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEltcGxlbWVudGF0aW9uIHNwZWNpZmljIHJlbmRlcmluZyBmdW5jdGlvbi5cclxuICAgICAqIEBtZW1iZXJvZiBUZXh0U2NvcmVSZW5kZXJlclxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSByYXcgZGF0YSBmb3IgYSB0aWxlIHRvIGJlIHJlbmRlcmVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt7aHRtbDogc3RyaW5nLCBlbnRyaWVzOiBBcnJheX19IFRoZSBodG1sIHRvIHJlbmRlciBhbmQgYW4gYXJyYXkgb2YgYWxsIHJlbmRlcmVkIGRhdGEgZW50cmllcy5cclxuICAgICAqL1xyXG4gICAgVGV4dFNjb3JlV2VpZ2h0ZWRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oIGRhdGEgKSB7XHJcblxyXG4gICAgICAgIHZhciBFTlRSWV9IRUlHSFQgPSAzMCxcclxuICAgICAgICAgICAgQkFSX0hFSUdIVCA9IDYsXHJcbiAgICAgICAgICAgIEJPVFRPTV9PRkZTRVQgPSBFTlRSWV9IRUlHSFQgLSBCQVJfSEVJR0hUIC0gMixcclxuICAgICAgICAgICAgc3BlYyA9IHRoaXMuc3BlYyxcclxuICAgICAgICAgICAgd2VpZ2h0cyA9IHNwZWMud2VpZ2h0cyxcclxuICAgICAgICAgICAgdGhyZXNob2xkID0gc3BlYy50aHJlc2hvbGQgfHwgNSxcclxuICAgICAgICAgICAgdGV4dEtleSA9IHNwZWMudGV4dC50ZXh0S2V5LFxyXG4gICAgICAgICAgICBjb3VudEtleSA9IHNwZWMudGV4dC5jb3VudEtleSxcclxuICAgICAgICAgICAgdmFsdWVzID0gUmVuZGVyZXJVdGlsLmdldEF0dHJpYnV0ZVZhbHVlKCBkYXRhLCBzcGVjLnJvb3RLZXkgKSxcclxuICAgICAgICAgICAgbGV2ZWxNaW5NYXggPSB0aGlzLnBhcmVudC5nZXRMZXZlbE1pbk1heCgpLFxyXG4gICAgICAgICAgICBudW1FbnRyaWVzID0gTWF0aC5taW4oIHZhbHVlcy5sZW5ndGgsIE1BWF9XT1JEU19ESVNQTEFZRUQgKSxcclxuICAgICAgICAgICAgbWluRm9udFNpemUgPSAxMyxcclxuICAgICAgICAgICAgbWF4Rm9udFNpemUgPSAxOCxcclxuICAgICAgICAgICAgbWluID0gTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICAgICAgbWF4ID0gMCxcclxuICAgICAgICAgICAgZW50cmllcyA9IFtdLFxyXG4gICAgICAgICAgICBodG1sID0gJycsXHJcbiAgICAgICAgICAgIGRlc2F0dXJhdGUsXHJcbiAgICAgICAgICAgIHBlcmNlbnRMYWJlbCxcclxuICAgICAgICAgICAgbWlkZGxlV2VpZ2h0SW5kZXgsXHJcbiAgICAgICAgICAgIG1pZGRsZVdlaWdodCxcclxuICAgICAgICAgICAgd2VpZ2h0Q291bnRzLFxyXG4gICAgICAgICAgICB3ZWlnaHRQZXJjZW50LFxyXG4gICAgICAgICAgICB3ZWlnaHQsXHJcbiAgICAgICAgICAgIGJhcldpZHRoLFxyXG4gICAgICAgICAgICB5T2Zmc2V0LFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgdGV4dCxcclxuICAgICAgICAgICAgY291bnQsXHJcbiAgICAgICAgICAgIGZvbnRTaXplLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBqO1xyXG5cclxuICAgICAgICB5T2Zmc2V0ID0gUmVuZGVyZXJVdGlsLmdldFlPZmZzZXQoIG51bUVudHJpZXMsIEVOVFJZX0hFSUdIVCtCQVJfSEVJR0hULCAxMjIgKTtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIG1pbiBmb3IgdGhlIHpvb20gbGV2ZWwgaXMgc3BlY2lmaWVkIGluIHRoZSBtZXRhLCB1c2UgaXRcclxuICAgICAgICBpZiAoIGxldmVsTWluTWF4Lm1pbmltdW0gKSB7XHJcbiAgICAgICAgICAgIG1pbiA9IFJlbmRlcmVyVXRpbC5nZXRBdHRyaWJ1dGVWYWx1ZSggbGV2ZWxNaW5NYXgubWluaW11bSwgY291bnRLZXkgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCggZnVuY3Rpb24oIHZhbHVlICkge1xyXG4gICAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4oIG1pbiwgUmVuZGVyZXJVdGlsLmdldEF0dHJpYnV0ZVZhbHVlKCB2YWx1ZSwgY291bnRLZXkgKSApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZSBtYXggZm9yIHRoZSB6b29tIGxldmVsIGlzIHNwZWNpZmllZCBpbiB0aGUgbWV0YSwgdXNlIGl0XHJcbiAgICAgICAgaWYgKCBsZXZlbE1pbk1heC5tYXhpbXVtICkge1xyXG4gICAgICAgICAgICBtYXggPSBSZW5kZXJlclV0aWwuZ2V0QXR0cmlidXRlVmFsdWUoIGxldmVsTWluTWF4Lm1heGltdW0sIGNvdW50S2V5ICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goIGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KCBtYXgsIFJlbmRlcmVyVXRpbC5nZXRBdHRyaWJ1dGVWYWx1ZSggdmFsdWUsIGNvdW50S2V5ICkgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGk9MDsgaTxudW1FbnRyaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaV07XHJcbiAgICAgICAgICAgIGVudHJpZXMucHVzaCggdmFsdWUgKTtcclxuICAgICAgICAgICAgdGV4dCA9IFJlbmRlcmVyVXRpbC5nZXRBdHRyaWJ1dGVWYWx1ZSggdmFsdWUsIHRleHRLZXkgKTtcclxuICAgICAgICAgICAgY291bnQgPSBSZW5kZXJlclV0aWwuZ2V0QXR0cmlidXRlVmFsdWUoIHZhbHVlLCBjb3VudEtleSApO1xyXG4gICAgICAgICAgICBkZXNhdHVyYXRlID0gKCBjb3VudCA8IHRocmVzaG9sZCApID8gXCJkZS1zYXR1cmF0ZVwiIDogXCJcIjtcclxuICAgICAgICAgICAgZm9udFNpemUgPSBSZW5kZXJlclV0aWwuZ2V0Rm9udFNpemUoXHJcbiAgICAgICAgICAgICAgICBjb3VudCxcclxuICAgICAgICAgICAgICAgIG1pbixcclxuICAgICAgICAgICAgICAgIG1heCxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5Gb250U2l6ZTogbWluRm9udFNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4Rm9udFNpemU6IG1heEZvbnRTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibG9nXCJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHdlaWdodFBlcmNlbnQgPSAoZm9udFNpemUtbWluRm9udFNpemUpIC8gKG1heEZvbnRTaXplLW1pbkZvbnRTaXplKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHBhcmVudFxyXG4gICAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwidGV4dC1zY29yZS1lbnRyeS1wYXJlbnRcIiBzdHlsZT1cInRvcDonICsgeU9mZnNldCArICdweDtcIj4nO1xyXG5cclxuICAgICAgICAgICAgLy8gY3JlYXRlIGVudHJ5XHJcbiAgICAgICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJ0ZXh0LXNjb3JlLWVudHJ5XCIgc3R5bGU9XCJoZWlnaHQ6JytFTlRSWV9IRUlHSFQrJ3B4O1wiPic7XHJcblxyXG4gICAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwidGV4dC1zY29yZS1lbnRyeS1jb3VudFwiPicrIGNvdW50ICsnPC9kaXY+JztcclxuXHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBsYWJlbFxyXG4gICAgICAgICAgICBwZXJjZW50TGFiZWwgPSBNYXRoLnJvdW5kKCAod2VpZ2h0UGVyY2VudCoxMDApIC8gMTAgKSAqIDEwO1xyXG4gICAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwidGV4dC1zY29yZS1sYWJlbCB0ZXh0LXNjb3JlLWxhYmVsLSdcclxuICAgICAgICAgICAgICAgICsgcGVyY2VudExhYmVsKycgJytkZXNhdHVyYXRlKydcIiBzdHlsZT1cIidcclxuICAgICAgICAgICAgICAgICsgJ2ZvbnQtc2l6ZTonKyBmb250U2l6ZSArJ3B4OydcclxuICAgICAgICAgICAgICAgICsgJ2xpbmUtaGVpZ2h0OicrIGZvbnRTaXplICsncHg7J1xyXG4gICAgICAgICAgICAgICAgKyAnYm90dG9tOicrLShCT1RUT01fT0ZGU0VULWZvbnRTaXplKSsncHg7XCI+Jyt0ZXh0Kyc8L2Rpdj4nO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBjb3VudCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgd2VpZ2h0c1xyXG4gICAgICAgICAgICAgICAgd2VpZ2h0Q291bnRzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKCBqPTA7IGo8d2VpZ2h0cy5sZW5ndGg7IGorKyApIHtcclxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQgPSBSZW5kZXJlclV0aWwuZ2V0QXR0cmlidXRlVmFsdWUoIHZhbHVlLCB3ZWlnaHRzW2pdLndlaWdodEtleSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodENvdW50cy5wdXNoKCB3ZWlnaHQgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIG1pZGRsZSB3ZWlnaHRcclxuICAgICAgICAgICAgICAgIG1pZGRsZVdlaWdodEluZGV4ID0gTWF0aC5mbG9vciggKHdlaWdodHMubGVuZ3RoLTEpIC8gMiApO1xyXG4gICAgICAgICAgICAgICAgLy8gc3VtIHRoZSBhbW91bnQgb2Ygd2VpZ2h0IHRvIGNlbnRyZSB0aGUgYmFyIG9uIHRoZSBtaWRkbGUgd2VpZ2h0XHJcbiAgICAgICAgICAgICAgICBpZiAoIHdlaWdodHMubGVuZ3RoICUgMiA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBtaWRkbGVXZWlnaHQgPSB3ZWlnaHRDb3VudHNbIG1pZGRsZVdlaWdodEluZGV4IF07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pZGRsZVdlaWdodCA9IHdlaWdodENvdW50c1sgbWlkZGxlV2VpZ2h0SW5kZXggXSAvIDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKCBqPW1pZGRsZVdlaWdodEluZGV4LTE7IGo+PTA7IGotLSApIHtcclxuICAgICAgICAgICAgICAgICAgICBtaWRkbGVXZWlnaHQgKz0gd2VpZ2h0Q291bnRzW2pdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYmFyV2lkdGggPSBNQVhfQkFSX1dJRFRIO1xyXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGJhciBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJ0ZXh0LXNjb3JlLXdlaWdodC1iYXJcIiBzdHlsZT1cIidcclxuICAgICAgICAgICAgICAgICAgICArICd3aWR0aDonICsgYmFyV2lkdGggKyAncHg7J1xyXG4gICAgICAgICAgICAgICAgICAgICsgJ2hlaWdodDonICsgQkFSX0hFSUdIVCArICdweDsnXHJcbiAgICAgICAgICAgICAgICAgICAgKyAnbGVmdDonICsgKC1iYXJXaWR0aCoobWlkZGxlV2VpZ2h0L2NvdW50KSkgKyAncHg7XCI+JztcclxuICAgICAgICAgICAgICAgIGZvciAoIGo9MDsgajx3ZWlnaHRzLmxlbmd0aDsgaisrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBiYXJcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwidGV4dC1zY29yZS13ZWlnaHQgdGV4dC1zY29yZS13ZWlnaHQtJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGogKycgJytkZXNhdHVyYXRlKydcIiBzdHlsZT1cIidcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnd2lkdGg6JysoKHdlaWdodENvdW50c1tqXS9jb3VudCkqMTAwKSsnJTtcIj48L2Rpdj4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPC9kaXY+JztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaHRtbCArPSAnPC9kaXY+JztcclxuICAgICAgICAgICAgaHRtbCArPSAnPC9kaXY+JztcclxuICAgICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cImNsZWFyXCI+PC9kaXY+JztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGh0bWw6IGh0bWwsXHJcbiAgICAgICAgICAgIGVudHJpZXM6IGVudHJpZXNcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRleHRTY29yZVdlaWdodGVkUmVuZGVyZXI7XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMyBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgd29yZCBjbG91ZCByZW5kZXJlci4gVXNlcyBhIHNldCBvZiB3b3JkcyBhbmQgdGhlaXIgY291bnRzIHRvIGdlbmVyYXRlIGEgd29yZCBjbG91ZC5cclxuICovXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi9SZW5kZXJlcicpLFxyXG4gICAgICAgIFJlbmRlcmVyVXRpbCA9IHJlcXVpcmUoJy4vUmVuZGVyZXJVdGlsJyksXHJcbiAgICAgICAgTUFYX1dPUkRTX0RJU1BMQVlFRCA9IDEwLFxyXG4gICAgICAgIEhPUklaT05UQUxfT0ZGU0VUID0gMTAsXHJcbiAgICAgICAgVkVSVElDQUxfT0ZGU0VUID0gMjQsXHJcbiAgICAgICAgU0laRV9GVU5DVElPTiA9ICdsb2cnLFxyXG4gICAgICAgIE1JTl9GT05UX1NJWkUgPSAxMyxcclxuICAgICAgICBNQVhfRk9OVF9TSVpFID0gMjgsXHJcbiAgICAgICAgc3BpcmFsUG9zaXRpb24sXHJcbiAgICAgICAgaW50ZXJzZWN0VGVzdCxcclxuICAgICAgICBvdmVybGFwVGVzdCxcclxuICAgICAgICBpbnRlcnNlY3RXb3JkLFxyXG4gICAgICAgIGdldFdvcmREaW1lbnNpb25zLFxyXG4gICAgICAgIGNyZWF0ZVdvcmRDbG91ZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGluaXRpYWwgcG9zaXRpb24sIHJldHVybiBhIG5ldyBwb3NpdGlvbiwgaW5jcmVtZW50YWxseSBzcGlyYWxsZWRcclxuICAgICAqIG91dHdhcmRzLlxyXG4gICAgICovXHJcbiAgICBzcGlyYWxQb3NpdGlvbiA9IGZ1bmN0aW9uKCBwb3MgKSB7XHJcbiAgICAgICAgdmFyIHBpMiA9IDIgKiBNYXRoLlBJLFxyXG4gICAgICAgICAgICBjaXJjID0gcGkyICogcG9zLnJhZGl1cyxcclxuICAgICAgICAgICAgaW5jID0gKCBwb3MuYXJjTGVuZ3RoID4gY2lyYy8xMCkgPyBjaXJjLzEwIDogcG9zLmFyY0xlbmd0aCxcclxuICAgICAgICAgICAgZGEgPSBpbmMgLyBwb3MucmFkaXVzLFxyXG4gICAgICAgICAgICBudCA9IChwb3MudCtkYSk7XHJcbiAgICAgICAgaWYgKG50ID4gcGkyKSB7XHJcbiAgICAgICAgICAgIG50ID0gbnQgJSBwaTI7XHJcbiAgICAgICAgICAgIHBvcy5yYWRpdXMgPSBwb3MucmFkaXVzICsgcG9zLnJhZGl1c0luYztcclxuICAgICAgICB9XHJcbiAgICAgICAgcG9zLnQgPSBudDtcclxuICAgICAgICBwb3MueCA9IHBvcy5yYWRpdXMgKiBNYXRoLmNvcyhudCk7XHJcbiAgICAgICAgcG9zLnkgPSBwb3MucmFkaXVzICogTWF0aC5zaW4obnQpO1xyXG4gICAgICAgIHJldHVybiBwb3M7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiBib3VuZGluZyBib3ggYSBpbnRlcnNlY3RzIGJvdW5kaW5nIGJveCBiXHJcbiAgICAgKi9cclxuICAgIGludGVyc2VjdFRlc3QgPSBmdW5jdGlvbiggYSwgYiApIHtcclxuICAgICAgICByZXR1cm4gKE1hdGguYWJzKGEueCAtIGIueCkgKiAyIDwgKGEud2lkdGggKyBiLndpZHRoKSkgJiZcclxuICAgICAgICAgICAgICAgKE1hdGguYWJzKGEueSAtIGIueSkgKiAyIDwgKGEuaGVpZ2h0ICsgYi5oZWlnaHQpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIGJvdW5kaW5nIGJveCBhIGlzIG5vdCBmdWxseSBjb250YWluZWQgaW5zaWRlIGJvdW5kaW5nIGJveCBiXHJcbiAgICAgKi9cclxuICAgIG92ZXJsYXBUZXN0ID0gZnVuY3Rpb24oIGEsIGIgKSB7XHJcbiAgICAgICAgcmV0dXJuICggYS54ICsgYS53aWR0aC8yID4gYi54K2Iud2lkdGgvMiB8fFxyXG4gICAgICAgICAgICAgICAgIGEueCAtIGEud2lkdGgvMiA8IGIueC1iLndpZHRoLzIgfHxcclxuICAgICAgICAgICAgICAgICBhLnkgKyBhLmhlaWdodC8yID4gYi55K2IuaGVpZ2h0LzIgfHxcclxuICAgICAgICAgICAgICAgICBhLnkgLSBhLmhlaWdodC8yIDwgYi55LWIuaGVpZ2h0LzIgKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBhIHdvcmQgaW50ZXJzZWN0cyBhbm90aGVyIHdvcmQsIG9yIGlzIG5vdCBmdWxseSBjb250YWluZWQgaW4gdGhlXHJcbiAgICAgKiB0aWxlIGJvdW5kaW5nIGJveFxyXG4gICAgICovXHJcbiAgICBpbnRlcnNlY3RXb3JkID0gZnVuY3Rpb24oIHBvc2l0aW9uLCBkaW1lbnNpb25zLCBjbG91ZCwgYmIgKSB7XHJcbiAgICAgICAgdmFyIGJveCA9IHtcclxuICAgICAgICAgICAgICAgIHg6IHBvc2l0aW9uLngsXHJcbiAgICAgICAgICAgICAgICB5OiBwb3NpdGlvbi55LFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBkaW1lbnNpb25zLmhlaWdodCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBkaW1lbnNpb25zLndpZHRoXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGk7XHJcbiAgICAgICAgZm9yICggaT0wOyBpPGNsb3VkLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICBpZiAoIGludGVyc2VjdFRlc3QoIGJveCwgY2xvdWRbaV0gKSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBpdCBkb2Vzbid0IGludGVyc2VjdCB0aGUgYm9yZGVyO1xyXG4gICAgICAgIGlmICggb3ZlcmxhcFRlc3QoIGJveCwgYmIgKSApIHtcclxuICAgICAgICAgICAgLy8gaWYgaXQgaGl0cyBhIGJvcmRlciwgaW5jcmVtZW50IGNvbGxpc2lvbiBjb3VudFxyXG4gICAgICAgICAgICAvLyBhbmQgZXh0ZW5kIGFyYyBsZW5ndGhcclxuICAgICAgICAgICAgcG9zaXRpb24uY29sbGlzaW9ucysrO1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5hcmNMZW5ndGggPSBwb3NpdGlvbi5yYWRpdXM7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcGl4ZWwgZGltZW5zaW9ucyBvZiB0aGUgbGFiZWxcclxuICAgICAqL1xyXG4gICAgZ2V0V29yZERpbWVuc2lvbnMgPSBmdW5jdGlvbiggc3RyLCBmb250U2l6ZSApIHtcclxuICAgICAgICB2YXIgJHRlbXAsXHJcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9IHt9O1xyXG4gICAgICAgICR0ZW1wID0gJCgnPGRpdiBjbGFzcz1cIndvcmQtY2xvdWQtbGFiZWwtdGVtcFwiIHN0eWxlPVwiZm9udC1zaXplOicrZm9udFNpemUrJ3B4O1wiPicrc3RyKyc8L2Rpdj4nKTtcclxuICAgICAgICAkKCdib2R5JykuYXBwZW5kKCAkdGVtcCApO1xyXG4gICAgICAgIGRpbWVuc2lvbi53aWR0aCA9ICR0ZW1wLm91dGVyV2lkdGgoKTtcclxuICAgICAgICBkaW1lbnNpb24uaGVpZ2h0ID0gJHRlbXAub3V0ZXJIZWlnaHQoKTtcclxuICAgICAgICAkdGVtcC5yZW1vdmUoKTtcclxuICAgICAgICByZXR1cm4gZGltZW5zaW9uO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHdvcmQgY2xvdWQgd29yZHMgY29udGFpbmluZyBmb250IHNpemUgYW5kIHggYW5kIHkgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgY3JlYXRlV29yZENsb3VkID0gZnVuY3Rpb24oIHdvcmRDb3VudHMsIG1pbiwgbWF4LCBzaXplRnVuY3Rpb24sIG1pbkZvbnRTaXplLCBtYXhGb250U2l6ZSApIHtcclxuICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMjU2IC0gSE9SSVpPTlRBTF9PRkZTRVQgKiAyLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyNTYgLSBWRVJUSUNBTF9PRkZTRVQgKiAyLFxyXG4gICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgIHk6IDBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvdWQgPSBbXSxcclxuICAgICAgICAgICAgcGVyY2VudCxcclxuICAgICAgICAgICAgaSwgd29yZCwgY291bnQsIGRpbSxcclxuICAgICAgICAgICAgZm9udFNpemUsIHBvcztcclxuICAgICAgICAvLyBzb3J0IHdvcmRzIGJ5IGZyZXF1ZW5jeVxyXG4gICAgICAgIHdvcmRDb3VudHMuc29ydCggZnVuY3Rpb24oIGEsIGIgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiLmNvdW50IC0gYS5jb3VudDtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBhc3NlbWJsZSB3b3JkIGNsb3VkXHJcbiAgICAgICAgZm9yICggaT0wOyBpPHdvcmRDb3VudHMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgIHdvcmQgPSB3b3JkQ291bnRzW2ldLndvcmQ7XHJcbiAgICAgICAgICAgIGNvdW50ID0gd29yZENvdW50c1tpXS5jb3VudDtcclxuICAgICAgICAgICAgLy8gZ2V0IGZvbnQgc2l6ZSBiYXNlZCBvbiBmb250IHNpemUgZnVuY3Rpb25cclxuICAgICAgICAgICAgZm9udFNpemUgPSBSZW5kZXJlclV0aWwuZ2V0Rm9udFNpemUoIGNvdW50LCBtaW4sIG1heCwge1xyXG4gICAgICAgICAgICAgICAgbWF4Rm9udFNpemU6IG1heEZvbnRTaXplLFxyXG4gICAgICAgICAgICAgICAgbWluRm9udFNpemU6IG1pbkZvbnRTaXplLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogc2l6ZUZ1bmN0aW9uXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBmcmVxdWVuY3kgcGVyY2VudFxyXG4gICAgICAgICAgICBwZXJjZW50ID0gKChmb250U2l6ZS1taW5Gb250U2l6ZSkgLyAobWF4Rm9udFNpemUtbWluRm9udFNpemUpKSoxMDA7XHJcbiAgICAgICAgICAgIC8vIGdldCBkaW1lbnNpb25zIG9mIHdvcmRcclxuICAgICAgICAgICAgZGltID0gZ2V0V29yZERpbWVuc2lvbnMoIHdvcmQsIGZvbnRTaXplICk7XHJcbiAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHNwaXJhbCBwb3NpdGlvblxyXG4gICAgICAgICAgICBwb3MgPSB7XHJcbiAgICAgICAgICAgICAgICByYWRpdXMgOiAxLFxyXG4gICAgICAgICAgICAgICAgcmFkaXVzSW5jIDogNSxcclxuICAgICAgICAgICAgICAgIGFyY0xlbmd0aCA6IDUsXHJcbiAgICAgICAgICAgICAgICB4IDogMCxcclxuICAgICAgICAgICAgICAgIHkgOiAwLFxyXG4gICAgICAgICAgICAgICAgdCA6IDAsXHJcbiAgICAgICAgICAgICAgICBjb2xsaXNpb25zIDogMFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIG51bVdvcmRzID0gd29yZENvdW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlKCBwb3MuY29sbGlzaW9ucyA8IG51bVdvcmRzICkge1xyXG4gICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHBvc2l0aW9uIGluIGEgc3BpcmFsXHJcbiAgICAgICAgICAgICAgICBwb3MgPSBzcGlyYWxQb3NpdGlvbiggcG9zICk7XHJcbiAgICAgICAgICAgICAgICAvLyB0ZXN0IGZvciBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgIGlmICggIWludGVyc2VjdFdvcmQoIHBvcywgZGltLCBjbG91ZCwgYm91bmRpbmdCb3ggKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBjbG91ZC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29yZDogd29yZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnk6IHdvcmRDb3VudHNbaV0uZW50cnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBmb250U2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudExhYmVsOiBNYXRoLnJvdW5kKCBwZXJjZW50IC8gMTAgKSAqIDEwLCAvLyByb3VuZCB0byBuZWFyZXN0IDEwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6cG9zLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6cG9zLnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkaW0ud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZGltLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG91ZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW50aWF0ZSBhIFdvcmRDbG91ZFJlbmRlcmVyIG9iamVjdC5cclxuICAgICAqIEBjbGFzcyBXb3JkQ2xvdWRSZW5kZXJlclxyXG4gICAgICogQGF1Z21lbnRzIFJlbmRlcmVyXHJcbiAgICAgKiBAY2xhc3NEZXNjIEEgUmVuZGVyZXIgaW1wbGVtZW50YXRpb24gdGhhdCByZW5kZXJzIGEgd29yZCBjbG91ZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3BlYyB7T2JqZWN0fSBUaGUgc3BlY2lmaWNhdGlvbiBvYmplY3QuXHJcbiAgICAgKiA8cHJlPlxyXG4gICAgICogICAgIHRleHQ6IHtcclxuICAgICAqICAgICAgICAgdGV4dEtleSAge1N0cmluZ3xGdW5jdGlvbn0gLSBUaGUgYXR0cmlidXRlIGZvciB0aGUgdGV4dCBpbiB0aGUgZGF0YSBlbnRyeS5cclxuICAgICAqICAgICAgICAgY291bnRLZXkge1N0cmluZ3xGdW5jdGlvbn0gLSBUaGUgYXR0cmlidXRlIGZvciB0aGUgY291bnQgaW4gdGhlIGRhdGEgZW50cnkuXHJcbiAgICAgKiAgICAgICAgIHRoZW1lcyAgIHtBcnJheX0gIC0gVGhlIGFycmF5IG9mIFJlbmRlclRoZW1lcyB0byBiZSBhdHRhY2hlZCB0byB0aGlzIGNvbXBvbmVudC5cclxuICAgICAqICAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gV29yZENsb3VkUmVuZGVyZXIoIHNwZWMgKSB7XHJcbiAgICAgICAgc3BlYy5yb290S2V5ID0gc3BlYy5yb290S2V5IHx8IFwidGlsZS5tZXRhLmFnZ3JlZ2F0ZWRcIjtcclxuICAgICAgICBzcGVjLnRleHQgPSBzcGVjLnRleHQgfHwge307XHJcbiAgICAgICAgUmVuZGVyZXIuY2FsbCggdGhpcywgc3BlYyApO1xyXG4gICAgICAgIHRoaXMuaW5qZWN0Q3NzKCB0aGlzLnNwZWMgKTtcclxuICAgIH1cclxuXHJcbiAgICBXb3JkQ2xvdWRSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSZW5kZXJlci5wcm90b3R5cGUgKTtcclxuXHJcbiAgICBXb3JkQ2xvdWRSZW5kZXJlci5wcm90b3R5cGUuZ2V0RW50cnlTZWxlY3RvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBcIi53b3JkLWNsb3VkLWxhYmVsXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIFdvcmRDbG91ZFJlbmRlcmVyLnByb3RvdHlwZS5pbmplY3RDc3MgPSBmdW5jdGlvbiggc3BlYyApIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoIHNwZWMudGV4dC50aGVtZXMgKSB7XHJcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgc3BlYy50ZXh0LnRoZW1lcy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIHNwZWMudGV4dC50aGVtZXNbaV0uaW5qZWN0VGhlbWUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBcIi53b3JkLWNsb3VkLWxhYmVsXCJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc3BlYy50ZXh0LnRoZW1lc1tpXS5pbmplY3RUaGVtZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IFwiLmNvdW50LXN1bW1hcnlcIlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFdvcmRDbG91ZFJlbmRlcmVyLnByb3RvdHlwZS5nZXRXb3JkU3R5bGVDbGFzcyA9IGZ1bmN0aW9uICggd29yZFByb3BzICkge1xyXG4gICAgICAgIHJldHVybiAnd29yZC1jbG91ZC1sYWJlbCB3b3JkLWNsb3VkLWxhYmVsLScgKyB3b3JkUHJvcHMucGVyY2VudExhYmVsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEltcGxlbWVudGF0aW9uIHNwZWNpZmljIHJlbmRlcmluZyBmdW5jdGlvbi5cclxuICAgICAqIEBtZW1iZXJvZiBXb3JkQ2xvdWRSZW5kZXJlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIHJhdyBkYXRhIGZvciBhIHRpbGUgdG8gYmUgcmVuZGVyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3todG1sOiBzdHJpbmcsIGVudHJpZXM6IEFycmF5fX0gVGhlIGh0bWwgdG8gcmVuZGVyIGFuZCBhbiBhcnJheSBvZiBhbGwgcmVuZGVyZWQgZGF0YSBlbnRyaWVzLlxyXG4gICAgICovXHJcbiAgICBXb3JkQ2xvdWRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oIGRhdGEgKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgdGV4dCA9IHRoaXMuc3BlYy50ZXh0LFxyXG4gICAgICAgICAgICB0ZXh0S2V5ID0gdGV4dC50ZXh0S2V5LFxyXG4gICAgICAgICAgICBjb3VudEtleSA9IHRleHQuY291bnRLZXksXHJcbiAgICAgICAgICAgIHZhbHVlcyA9IFJlbmRlcmVyVXRpbC5nZXRBdHRyaWJ1dGVWYWx1ZSggZGF0YSwgdGhpcy5zcGVjLnJvb3RLZXkgKSxcclxuICAgICAgICAgICAgbnVtRW50cmllcyA9IE1hdGgubWluKCB2YWx1ZXMubGVuZ3RoLCB0ZXh0Lm1heFdvcmRzIHx8IE1BWF9XT1JEU19ESVNQTEFZRUQgKSxcclxuICAgICAgICAgICAgbGV2ZWxNaW5NYXggPSB0aGlzLnBhcmVudC5nZXRMZXZlbE1pbk1heCgpLFxyXG4gICAgICAgICAgICBzaXplRnVuY3Rpb24gPSB0ZXh0LnNpemVGdW5jdGlvbiB8fCBTSVpFX0ZVTkNUSU9OLFxyXG4gICAgICAgICAgICBtaW5Gb250U2l6ZSA9IHRleHQubWluRm9udFNpemUgfHwgTUlOX0ZPTlRfU0laRSxcclxuICAgICAgICAgICAgbWF4Rm9udFNpemUgPSB0ZXh0Lm1heEZvbnRTaXplIHx8IE1BWF9GT05UX1NJWkUsXHJcbiAgICAgICAgICAgIG1pbiA9IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgICAgIG1heCA9IDAsXHJcblx0XHRcdCRodG1sID0gJChcIjxkaXY+PC9kaXY+XCIpLFxyXG4gICAgICAgICAgICB3b3JkQ291bnRzID0gW10sXHJcbiAgICAgICAgICAgIGVudHJpZXMgPSBbXSxcclxuICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgIHdvcmQsXHJcbiAgICAgICAgICAgIGNvdW50LFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBjbG91ZDtcclxuXHJcbiAgICAgICAgZm9yICggaT0wOyBpPG51bUVudHJpZXM7IGkrKyApIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaV07XHJcbiAgICAgICAgICAgIHdvcmQgPSBSZW5kZXJlclV0aWwuZ2V0QXR0cmlidXRlVmFsdWUoIHZhbHVlLCB0ZXh0S2V5ICk7XHJcbiAgICAgICAgICAgIGNvdW50ID0gUmVuZGVyZXJVdGlsLmdldEF0dHJpYnV0ZVZhbHVlKCB2YWx1ZSwgY291bnRLZXkgKTtcclxuICAgICAgICAgICAgbWluID0gTWF0aC5taW4oIG1pbiwgY291bnQgKTtcclxuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgoIG1heCwgY291bnQgKTtcclxuICAgICAgICAgICAgd29yZENvdW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHdvcmQ6IHdvcmQsXHJcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXHJcbiAgICAgICAgICAgICAgICBlbnRyeTogdmFsdWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZiB0aGUgbWluIGZvciB0aGUgem9vbSBsZXZlbCBpcyBzcGVjaWZpZWQgaW4gdGhlIG1ldGEsIHVzZSBpdFxyXG4gICAgICAgIGlmICggbGV2ZWxNaW5NYXgubWluaW11bSApIHtcclxuICAgICAgICAgICAgbWluID0gUmVuZGVyZXJVdGlsLmdldEF0dHJpYnV0ZVZhbHVlKCBsZXZlbE1pbk1heC5taW5pbXVtLCBjb3VudEtleSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgbWF4IGZvciB0aGUgem9vbSBsZXZlbCBpcyBzcGVjaWZpZWQgaW4gdGhlIG1ldGEsIHVzZSBpdFxyXG4gICAgICAgIGlmICggbGV2ZWxNaW5NYXgubWF4aW11bSApIHtcclxuICAgICAgICAgICAgbWF4ID0gUmVuZGVyZXJVdGlsLmdldEF0dHJpYnV0ZVZhbHVlKCBsZXZlbE1pbk1heC5tYXhpbXVtLCBjb3VudEtleSApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2xvdWQgPSBjcmVhdGVXb3JkQ2xvdWQoXHJcbiAgICAgICAgICAgIHdvcmRDb3VudHMsXHJcbiAgICAgICAgICAgIG1pbixcclxuICAgICAgICAgICAgbWF4LFxyXG4gICAgICAgICAgICBzaXplRnVuY3Rpb24sXHJcbiAgICAgICAgICAgIG1pbkZvbnRTaXplLFxyXG4gICAgICAgICAgICBtYXhGb250U2l6ZSk7XHJcblxyXG5cdFx0dmFyICRsYWJlbCA9ICQoJzxkaXYgY2xhc3M9XCJjb3VudC1zdW1tYXJ5XCI+PC9kaXY+Jyk7XHJcblx0XHQkaHRtbCA9ICRodG1sLmFwcGVuZCggJGxhYmVsICk7XHJcblxyXG4gICAgY2xvdWQuZm9yRWFjaCggZnVuY3Rpb24oIHdvcmQgKSB7XHJcblx0XHRcdGVudHJpZXMucHVzaCggd29yZC5lbnRyeSApO1xyXG4gICAgICAgICAgICB2YXIgJHdvcmRMYWJlbCA9ICQoJzxkaXYgJ1xyXG4gICAgICAgICAgICAgICAgICAgICsgJ2NsYXNzPVwiJyArIHNlbGYuZ2V0V29yZFN0eWxlQ2xhc3Mod29yZCkgKyAnXCIgJ1xyXG4gICAgICAgICAgICAgICAgICAgICsgJ3N0eWxlPVwiJ1xyXG4gICAgICAgICAgICAgICAgICAgICsgJ2ZvbnQtc2l6ZTonK3dvcmQuZm9udFNpemUrJ3B4OydcclxuICAgICAgICAgICAgICAgICAgICArICdsZWZ0OicrKDEyOCt3b3JkLngtKHdvcmQud2lkdGgvMikpKydweDsnXHJcbiAgICAgICAgICAgICAgICAgICAgKyAndG9wOicrKDEyOCt3b3JkLnktKHdvcmQuaGVpZ2h0LzIpKSsncHg7J1xyXG4gICAgICAgICAgICAgICAgICAgICsgJ3dpZHRoOicrd29yZC53aWR0aCsncHg7J1xyXG4gICAgICAgICAgICAgICAgICAgICsgJ2hlaWdodDonK3dvcmQuaGVpZ2h0KydweDtcIj4nK3dvcmQud29yZCsnPC9kaXY+Jyk7XHJcblx0XHRcdCR3b3JkTGFiZWwubW91c2VvdmVyKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdCRsYWJlbC5zaG93KCk7IC8vIHNob3cgbGFiZWxcclxuXHRcdFx0XHQkbGFiZWwudGV4dCggUmVuZGVyZXJVdGlsLmdldEF0dHJpYnV0ZVZhbHVlKCB3b3JkLmVudHJ5LCBjb3VudEtleSApICk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHQkd29yZExhYmVsLm1vdXNlb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdCRsYWJlbC5oaWRlKCk7IC8vIGhpZGUgbGFiZWxcclxuXHRcdFx0fSk7XHJcblx0XHRcdC8vIGFkZCBpdCB0byB0aGUgZ3JvdXBcclxuXHRcdFx0JGh0bWwgPSAkaHRtbC5hcHBlbmQoICR3b3JkTGFiZWwgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaHRtbDogJGh0bWwsXHJcbiAgICAgICAgZW50cmllczogZW50cmllc1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICBtb2R1bGUuZXhwb3J0cyA9IFdvcmRDbG91ZFJlbmRlcmVyO1xyXG59KCkpO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW50aWF0ZSBhIEFnZ3JlZ2F0b3Igb2JqZWN0LlxyXG4gICAgICogQGNsYXNzIEFnZ3JlZ2F0b3JcclxuICAgICAqIEBjbGFzc2Rlc2NcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQWdncmVnYXRvcigpIHtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGFycmF5IG9mIGJ1Y2tldHMsIHdpbGwgZXhlY3V0ZSB0aGUgcHJvdmlkZWQgYWdncmVnYXRpb25cclxuICAgICAqIHNwZWNpZmljYXRpb24gYWdhaW5zdCBhbGwgcmVsZXZhbnQgZW50cmllcy5cclxuICAgICAqIEBtZW1iZXJvZiBBZ2dyZWdhdG9yXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYnVja2V0cyAtIFRoZSBhcnJheSBvZiBidWNrZXRzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFnZ3JlZ2F0ZWQgYnVja2V0cy5cclxuICAgICAqL1xyXG4gICAgQWdncmVnYXRvci5wcm90b3R5cGUuYWdncmVnYXRlID0gZnVuY3Rpb24oIGJ1Y2tldHMgKSB7XHJcbiAgICAgICAgcmV0dXJuIGJ1Y2tldHM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNoZXMgdGhlIGFnZ3JlZ2F0b3IgdG8gaXRzIHJlc3BlY3RpdmUgbGF5ZXIuIFRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgY2FsbGVkXHJcbiAgICAgKiBtYW51YWxseS5cclxuICAgICAqIEBtZW1iZXJvZiBBZ2dyZWdhdG9yXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gVGhlIGxheWVyIHRvIGF0dGFjaCB0byB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKi9cclxuICAgICBBZ2dyZWdhdG9yLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiggbGF5ZXIgKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudCAhPT0gbGF5ZXIgKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcIlRoaXMgcmVuZGVyZXIgaGFzIGFscmVhZHkgYmVlbiBhdHRhY2hlZCBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBcInRvIGEgZGlmZmVyZW50IGxheWVyLCBwbGVhc2UgdXNlIGFub3RoZXIgaW5zdGFuY2UuXCIgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhcmVudCA9IGxheWVyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyBmb3IgdGhlIHNldCBvZiBidWNrZXRzLlxyXG4gICAgICogQG1lbWJlcm9mIEFnZ3JlZ2F0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBidWNrZXRzIC0gVGhlIGFycmF5IG9mIGJ1Y2tldHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJhbmdlIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgQWdncmVnYXRvci5wcm90b3R5cGUuZ2V0QnVja2V0UmFuZ2UgPSBmdW5jdGlvbiggYnVja2V0cyApIHtcclxuICAgICAgICB2YXIgdGlsZVRyYW5zZm9ybURhdGEgPSB0aGlzLnBhcmVudC5nZXRUaWxlVHJhbnNmb3JtRGF0YSgpLFxyXG4gICAgICAgICAgICBzdGFydCA9IHRpbGVUcmFuc2Zvcm1EYXRhLnN0YXJ0QnVja2V0LFxyXG4gICAgICAgICAgICBlbmQgPSB0aWxlVHJhbnNmb3JtRGF0YS5lbmRCdWNrZXQ7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ICE9PSB1bmRlZmluZWQgPyBzdGFydCA6IDAsXHJcbiAgICAgICAgICAgIGVuZDogZW5kICE9PSB1bmRlZmluZWQgPyBlbmQgOiBidWNrZXRzLmxlbmd0aCAtIDFcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0aGUgbGF5ZXIgbWV0YWRhdGEgZm9yIGEgdHJhbnNsYXRpb24gbWFwLiBJZiBpdCBleGlzdHMsIHJldHVybnNcclxuICAgICAqIHRoZSB0cmFuc2xhdGVkIGVudHJ5IGZvciB0aGUgcHJvdmlkZWQgdG9waWMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQWdncmVnYXRvclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b3BpYyAtIFRoZSB0b3BpYyB0byB0cmFuc2xhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHRyYW5zbGF0ZWQgdG9waWMuXHJcbiAgICAgKi9cclxuICAgIEFnZ3JlZ2F0b3IucHJvdG90eXBlLnRyYW5zbGF0ZVRvcGljID0gZnVuY3Rpb24oIHRvcGljICkge1xyXG4gICAgICAgIHZhciBtZXRhID0gdGhpcy5wYXJlbnQuc291cmNlLm1ldGEubWV0YTtcclxuICAgICAgICBpZiAoIG1ldGEudHJhbnNsYXRlZFRvcGljcyApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGEudHJhbnNsYXRlZFRvcGljc1sgdG9waWMgXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlcyBhIGZ1bmN0aW9uIGZvciBlYWNoIGJ1Y2tldCwgcGFzc2luZyB0aGUgYnVja2V0IGFuZCBvZmZzZXRcclxuICAgICAqIHJlZHVjZWQgaW5kZXggYXJndW1lbnRzLlxyXG4gICAgICogQG1lbWJlcm9mIEFnZ3JlZ2F0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBidWNrZXRzIC0gVGhlIGFycmF5IG9mIGJ1Y2tldHMuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuXHJcbiAgICAgKi9cclxuICAgIEFnZ3JlZ2F0b3IucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiggYnVja2V0cywgZnVuYyApIHtcclxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldEJ1Y2tldFJhbmdlKCBidWNrZXRzICksXHJcbiAgICAgICAgICAgIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZCA9IHJhbmdlLmVuZCxcclxuICAgICAgICAgICAgaTtcclxuICAgICAgICAvLyBmaXJzdCBpdGVyYXRlIG92ZXIgYWxsIGJ1Y2tldHMgYW5kIG9yZ2FuaXplIHRoZW0gYnkgaWRcclxuICAgICAgICBmb3IgKCBpPXN0YXJ0OyBpPD1lbmQ7IGkrKyApIHtcclxuICAgICAgICAgICAgLy8gc3VidHJhY3Qgc3RhcnQgdG8gYWx3YXlzIGhhdmUgaW5kZXggMCBiYXNlZFxyXG4gICAgICAgICAgICBpZiAoIGZ1bmMoIGJ1Y2tldHNbaV0sIGktc3RhcnQgKSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBZ2dyZWdhdG9yO1xyXG5cclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDEzIE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xyXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cclxuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBBZ2dyZWdhdG9yID0gcmVxdWlyZSgnLi9BZ2dyZWdhdG9yJyksXHJcbiAgICAgICAgVXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvVXRpbCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGUgYSBGcmVxdWVuY2llc0J5VG9waWNBZ2dyZWdhdG9yIG9iamVjdC5cclxuICAgICAqIEBjbGFzcyBGcmVxdWVuY2llc0J5VG9waWNBZ2dyZWdhdG9yXHJcbiAgICAgKiBAY2xhc3NkZXNjXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEZyZXF1ZW5jaWVzQnlUb3BpY0FnZ3JlZ2F0b3IoKSB7XHJcbiAgICB9XHJcblxyXG4gICAgRnJlcXVlbmNpZXNCeVRvcGljQWdncmVnYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBBZ2dyZWdhdG9yLnByb3RvdHlwZSApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYW4gYXJyYXkgb2YgYnVja2V0cywgd2lsbCBleGVjdXRlIHRoZSBwcm92aWRlZCBhZ2dyZWdhdGlvblxyXG4gICAgICogc3BlY2lmaWNhdGlvbiBhZ2FpbnN0IGFsbCByZWxldmFudCBlbnRyaWVzLlxyXG4gICAgICogQG1lbWJlcm9mIEZyZXF1ZW5jaWVzQnlUb3BpY0FnZ3JlZ2F0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBidWNrZXRzIC0gVGhlIGFycmF5IG9mIGJ1Y2tldHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgYWdncmVnYXRlZCBidWNrZXRzLlxyXG4gICAgICovXHJcbiAgICBGcmVxdWVuY2llc0J5VG9waWNBZ2dyZWdhdG9yLnByb3RvdHlwZS5hZ2dyZWdhdGUgPSBmdW5jdGlvbiggYnVja2V0cyApIHtcclxuICAgICAgICB2YXIgZnJlcXVlbmNpZXNCeVRvcGljID0ge30sXHJcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5nZXRCdWNrZXRSYW5nZSggYnVja2V0cyApLFxyXG4gICAgICAgICAgICBidWNrZXRDb3VudCA9IHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0ICsgMTtcclxuICAgICAgICB0aGlzLmZvckVhY2goXHJcbiAgICAgICAgICAgIGJ1Y2tldHMsXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKCBidWNrZXQsIGluZGV4ICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvcGljLFxyXG4gICAgICAgICAgICAgICAgICAgIGk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGJ1Y2tldCApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpPTA7IGk8YnVja2V0Lmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BpYyA9IGJ1Y2tldFtpXS50b3BpYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJlcXVlbmNpZXNCeVRvcGljWyB0b3BpYyBdID0gZnJlcXVlbmNpZXNCeVRvcGljWyB0b3BpYyBdIHx8IFV0aWwuZmlsbEFycmF5KCBidWNrZXRDb3VudCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmVxdWVuY2llc0J5VG9waWNbIHRvcGljIF1bIGluZGV4IF0gPSBidWNrZXRbaV0uc2NvcmUudG90YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmcmVxdWVuY2llc0J5VG9waWM7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gRnJlcXVlbmNpZXNCeVRvcGljQWdncmVnYXRvcjtcclxuXHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMyBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgQWdncmVnYXRvciA9IHJlcXVpcmUoJy4vQWdncmVnYXRvcicpLFxyXG4gICAgICAgIFV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL1V0aWwnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbnRpYXRlIGEgRnJlcXVlbmN5QXJyYXlzQnlUb3BpY0FnZ3JlZ2F0b3Igb2JqZWN0LlxyXG4gICAgICogQGNsYXNzIEZyZXF1ZW5jeUFycmF5c0J5VG9waWNBZ2dyZWdhdG9yXHJcbiAgICAgKiBAY2xhc3NkZXNjXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEZyZXF1ZW5jeUFycmF5c0J5VG9waWNBZ2dyZWdhdG9yKCkge1xyXG4gICAgfVxyXG5cclxuICAgIEZyZXF1ZW5jeUFycmF5c0J5VG9waWNBZ2dyZWdhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEFnZ3JlZ2F0b3IucHJvdG90eXBlICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBidWNrZXRzLCB3aWxsIGV4ZWN1dGUgdGhlIHByb3ZpZGVkIGFnZ3JlZ2F0aW9uXHJcbiAgICAgKiBzcGVjaWZpY2F0aW9uIGFnYWluc3QgYWxsIHJlbGV2YW50IGVudHJpZXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgRnJlcXVlbmN5QXJyYXlzQnlUb3BpY0FnZ3JlZ2F0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBidWNrZXRzIC0gVGhlIGFycmF5IG9mIGJ1Y2tldHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgYWdncmVnYXRlZCBidWNrZXRzLlxyXG4gICAgICovXHJcbiAgICBGcmVxdWVuY3lBcnJheXNCeVRvcGljQWdncmVnYXRvci5wcm90b3R5cGUuYWdncmVnYXRlID0gZnVuY3Rpb24oIGJ1Y2tldHMgKSB7XHJcbiAgICAgICAgdmFyIGZyZXF1ZW5jaWVzQnlUb3BpYyA9IHt9LFxyXG4gICAgICAgICAgICByYW5nZSA9IHRoaXMuZ2V0QnVja2V0UmFuZ2UoIGJ1Y2tldHMgKSxcclxuICAgICAgICAgICAgYnVja2V0Q291bnQgPSByYW5nZS5lbmQgLSByYW5nZS5zdGFydCArIDEsXHJcbiAgICAgICAgICAgIGxlbmd0aDtcclxuICAgICAgICB0aGlzLmZvckVhY2goXHJcbiAgICAgICAgICAgIGJ1Y2tldHMsXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKCBidWNrZXQsIGluZGV4ICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvcGljLFxyXG4gICAgICAgICAgICAgICAgICAgIGk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGJ1Y2tldCApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpPTA7IGk8YnVja2V0Lmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BpYyA9IGJ1Y2tldFtpXS50b3BpYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYnVja2V0W2ldLnNjb3JlLnRvdGFsLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJlcXVlbmNpZXNCeVRvcGljWyB0b3BpYyBdID0gZnJlcXVlbmNpZXNCeVRvcGljWyB0b3BpYyBdIHx8IFV0aWwuZmlsbEFycmF5KCBidWNrZXRDb3VudCwgVXRpbC5maWxsQXJyYXkoIGxlbmd0aCApICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyZXF1ZW5jaWVzQnlUb3BpY1sgdG9waWMgXVsgaW5kZXggXSA9IGJ1Y2tldFtpXS5zY29yZS50b3RhbC5zbGljZSggMCApOyAvLyBjb3B5XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmcmVxdWVuY2llc0J5VG9waWM7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gRnJlcXVlbmN5QXJyYXlzQnlUb3BpY0FnZ3JlZ2F0b3I7XHJcblxyXG59KCkpO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIEFnZ3JlZ2F0b3IgPSByZXF1aXJlKCcuL0FnZ3JlZ2F0b3InKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWFjaCBidWNrZXQsIGFuZCBwZXJmb3JtIHRoZSBhZ2dyZWdhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FnZ3JlZ2F0b3J9IGFnZ3JlZ2F0b3IgLSBUaGUgYWdncmVnYXRvciBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBidWNrZXRzIC0gVGhlIGFycmF5IG9mIGJ1Y2tldHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gVGhlIGFnZ3JlZ2F0ZWQgYnVja2V0cy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWdncmVnYXRlQnVja2V0KCBhZ2dyZWdhdG9yLCBidWNrZXRzICkge1xyXG4gICAgICAgIHZhciBhZ2dyZWdhdGlvbixcclxuICAgICAgICAgICAgc2NvcmUsXHJcbiAgICAgICAgICAgIHRvdGFsLFxyXG4gICAgICAgICAgICBpO1xyXG4gICAgICAgIC8vIHNldCBiYXNlIGFnZ3JlZ2F0b3JcclxuICAgICAgICBhZ2dyZWdhdGlvbiA9IHtcclxuICAgICAgICAgICAgdG9waWM6IGJ1Y2tldHNbMF0udG9waWMsXHJcbiAgICAgICAgICAgIHRvcGljRW5nbGlzaDogYWdncmVnYXRvci50cmFuc2xhdGVUb3BpYyggYnVja2V0c1swXS50b3BpYyApLFxyXG4gICAgICAgICAgICBjb3VudDogMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gZm9yIGVhY2ggYnVja2V0IG9mIGRhdGFcclxuICAgICAgICBmb3IgKCBpPTA7IGk8YnVja2V0cy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgLy8gYWRkIHRvIHRvdGFsIGNvdW50XHJcbiAgICAgICAgICAgIHNjb3JlID0gYnVja2V0c1tpXS5zY29yZTtcclxuICAgICAgICAgICAgaWYgKHNjb3JlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRvdGFsID0gKCB0eXBlb2Ygc2NvcmUgPT09IFwibnVtYmVyXCIgKSA/IHNjb3JlIDogc2NvcmUudG90YWw7XHJcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGlvbi5jb3VudCArPSB0b3RhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWdncmVnYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW50aWF0ZSBhIFRvcGljQ291bnRBZ2dyZWdhdG9yIG9iamVjdC5cclxuICAgICAqIEBjbGFzcyBUb3BpY0NvdW50QWdncmVnYXRvclxyXG4gICAgICogQGNsYXNzZGVzY1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBUb3BpY0NvdW50QWdncmVnYXRvcigpIHtcclxuICAgIH1cclxuXHJcbiAgICBUb3BpY0NvdW50QWdncmVnYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBBZ2dyZWdhdG9yLnByb3RvdHlwZSApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYW4gYXJyYXkgb2YgYnVja2V0cywgd2lsbCBleGVjdXRlIHRoZSBwcm92aWRlZCBhZ2dyZWdhdGlvblxyXG4gICAgICogc3BlY2lmaWNhdGlvbiBhZ2FpbnN0IGFsbCByZWxldmFudCBlbnRyaWVzLlxyXG4gICAgICogQG1lbWJlcm9mIFRvcGljQ291bnRBZ2dyZWdhdG9yXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYnVja2V0cyAtIFRoZSBhcnJheSBvZiBidWNrZXRzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFnZ3JlZ2F0ZWQgYnVja2V0cy5cclxuICAgICAqL1xyXG4gICAgVG9waWNDb3VudEFnZ3JlZ2F0b3IucHJvdG90eXBlLmFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKCBidWNrZXRzICkge1xyXG4gICAgICAgIHZhciBidWNrZXRzQnlUb3BpYyA9IHt9LFxyXG4gICAgICAgICAgICBhZ2dCdWNrZXRzID0gW10sXHJcbiAgICAgICAgICAgIHRvcGljO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaChcclxuICAgICAgICAgICAgYnVja2V0cyxcclxuICAgICAgICAgICAgZnVuY3Rpb24oIGJ1Y2tldCApIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b3BpYyxcclxuICAgICAgICAgICAgICAgICAgICBpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBidWNrZXQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaT0wOyBpPGJ1Y2tldC5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9waWMgPSBidWNrZXRbaV0udG9waWM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldHNCeVRvcGljWyB0b3BpYyBdID0gYnVja2V0c0J5VG9waWNbIHRvcGljIF0gfHwgW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldHNCeVRvcGljWyB0b3BpYyBdLnB1c2goIGJ1Y2tldFtpXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyB0aGVuLCBmb3IgZWFjaCBpZCwgYWdncmVnYXRlIHRoZSBidWNrZXRzXHJcbiAgICAgICAgZm9yICggdG9waWMgaW4gYnVja2V0c0J5VG9waWMgKSB7XHJcbiAgICAgICAgICAgIGlmICggYnVja2V0c0J5VG9waWMuaGFzT3duUHJvcGVydHkoIHRvcGljICkgKSB7XHJcbiAgICAgICAgICAgICAgICBhZ2dCdWNrZXRzLnB1c2goIGFnZ3JlZ2F0ZUJ1Y2tldCggdGhpcywgYnVja2V0c0J5VG9waWNbIHRvcGljIF0gKSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZpbmFsbHksIHNvcnQgdGhlbSBiYXNlZCBvbiBjb3VudFxyXG4gICAgICAgIGFnZ0J1Y2tldHMuc29ydCggZnVuY3Rpb24oIGEsIGIgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiLmNvdW50IC0gYS5jb3VudDtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYWdnQnVja2V0cztcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUb3BpY0NvdW50QWdncmVnYXRvcjtcclxuXHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMyBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgQWdncmVnYXRvciA9IHJlcXVpcmUoJy4vQWdncmVnYXRvcicpLFxyXG4gICAgICAgIFV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL1V0aWwnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWFjaCBidWNrZXQsIGFuZCBwZXJmb3JtIHRoZSBhZ2dyZWdhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FnZ3JlZ2F0b3J9IGFnZ3JlZ2F0b3IgLSBUaGUgYWdncmVnYXRvciBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBidWNrZXRzIC0gVGhlIGFycmF5IG9mIGJ1Y2tldHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gVGhlIGFnZ3JlZ2F0ZWQgYnVja2V0cy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWdncmVnYXRlQnVja2V0KCBhZ2dyZWdhdG9yLCBidWNrZXRzICkge1xyXG4gICAgICAgIHZhciBhZ2dyZWdhdGlvbixcclxuICAgICAgICAgICAgc2NvcmUsXHJcbiAgICAgICAgICAgIHRvdGFsLFxyXG4gICAgICAgICAgICB0ZXh0cyxcclxuICAgICAgICAgICAgcGFyc2VkLFxyXG4gICAgICAgICAgICBpLCBqLCBrO1xyXG4gICAgICAgIC8vIHNldCBiYXNlIGFnZ3JlZ2F0b3JcclxuICAgICAgICBhZ2dyZWdhdGlvbiA9IHtcclxuICAgICAgICAgICAgdG9waWM6IGJ1Y2tldHNbMF0udG9waWMsXHJcbiAgICAgICAgICAgIHRvcGljRW5nbGlzaDogYWdncmVnYXRvci50cmFuc2xhdGVUb3BpYyggYnVja2V0c1swXS50b3BpYyApLFxyXG4gICAgICAgICAgICBjb3VudHM6IFV0aWwuZmlsbEFycmF5KGJ1Y2tldHNbMF0uc2NvcmUgaW5zdGFuY2VvZiBBcnJheSA/XHJcblx0ICAgICAgICAgICAgYnVja2V0c1swXS5zY29yZS5sZW5ndGggOiBidWNrZXRzWzBdLnNjb3JlLnRvdGFsLmxlbmd0aCApLFxyXG4gICAgICAgICAgICB0b3RhbDogMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gZm9yIGVhY2ggYnVja2V0IG9mIGRhdGFcclxuICAgICAgICBmb3IgKCBpPTA7IGk8YnVja2V0cy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgc2NvcmUgPSBidWNrZXRzW2ldLnNjb3JlO1xyXG4gICAgICAgICAgICB0b3RhbCA9ICggc2NvcmUgaW5zdGFuY2VvZiBBcnJheSApID8gc2NvcmUgOiBzY29yZS50b3RhbDtcclxuICAgICAgICAgICAgLy8gYWRkIHRvIHRvdGFsIGNvdW50XHJcbiAgICAgICAgICAgIGZvciAoIGo9MDsgajx0b3RhbC5sZW5ndGg7IGorKyApIHtcclxuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0aW9uLmNvdW50c1tqXSArPSB0b3RhbFtqXTtcclxuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0aW9uLnRvdGFsICs9IHRvdGFsW2pdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGdldCBzZW50aW1lbnQuICduZWdhdGl2ZScsICdwb3NpdGl2ZScsIG9yICduZXV0cmFsJ1xyXG4gICAgICAgICAgICB0ZXh0cyA9IHNjb3JlLnRleHRzO1xyXG4gICAgICAgICAgICBpZiAoIHRleHRzICkge1xyXG4gICAgICAgICAgICAgICAgZm9yICggaz0wOyBrPHRleHRzLmxlbmd0aDsgaysrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoIHRleHRzW2tdLnRleHQgKTtcclxuICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGlvbi5zZW50aW1lbnQgPSBwYXJzZVNlbnRpbWVudCggcGFyc2VkWzJdICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGUgYSBUb3BpY0NvdW50QXJyYXlBZ2dyZWdhdG9yIG9iamVjdC5cclxuICAgICAqIEBjbGFzcyBUb3BpY0NvdW50QXJyYXlBZ2dyZWdhdG9yXHJcbiAgICAgKiBAY2xhc3NkZXNjXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFRvcGljQ291bnRBcnJheUFnZ3JlZ2F0b3IoKSB7XHJcbiAgICB9XHJcblxyXG4gICAgVG9waWNDb3VudEFycmF5QWdncmVnYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBBZ2dyZWdhdG9yLnByb3RvdHlwZSApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYW4gYXJyYXkgb2YgYnVja2V0cywgd2lsbCBleGVjdXRlIHRoZSBwcm92aWRlZCBhZ2dyZWdhdGlvblxyXG4gICAgICogc3BlY2lmaWNhdGlvbiBhZ2FpbnN0IGFsbCByZWxldmFudCBlbnRyaWVzLlxyXG4gICAgICogQG1lbWJlcm9mIFRvcGljQ291bnRBcnJheUFnZ3JlZ2F0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBidWNrZXRzIC0gVGhlIGFycmF5IG9mIGJ1Y2tldHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgYWdncmVnYXRlZCBidWNrZXRzLlxyXG4gICAgICovXHJcbiAgICBUb3BpY0NvdW50QXJyYXlBZ2dyZWdhdG9yLnByb3RvdHlwZS5hZ2dyZWdhdGUgPSBmdW5jdGlvbiggYnVja2V0cyApIHtcclxuICAgICAgICB2YXIgYnVja2V0c0J5VG9waWMgPSB7fSxcclxuICAgICAgICAgICAgYWdnQnVja2V0cyA9IFtdLFxyXG4gICAgICAgICAgICB0b3BpYztcclxuICAgICAgICB0aGlzLmZvckVhY2goXHJcbiAgICAgICAgICAgIGJ1Y2tldHMsXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKCBidWNrZXQgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9waWMsXHJcbiAgICAgICAgICAgICAgICAgICAgaTtcclxuICAgICAgICAgICAgICAgIGlmICggYnVja2V0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGk9MDsgaTxidWNrZXQubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljID0gYnVja2V0W2ldLnRvcGljO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWNrZXRzQnlUb3BpY1sgdG9waWMgXSA9IGJ1Y2tldHNCeVRvcGljWyB0b3BpYyBdIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWNrZXRzQnlUb3BpY1sgdG9waWMgXS5wdXNoKCBidWNrZXRbaV0gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gdGhlbiwgZm9yIGVhY2ggaWQsIGFnZ3JlZ2F0ZSB0aGUgYnVja2V0c1xyXG4gICAgICAgIGZvciAoIHRvcGljIGluIGJ1Y2tldHNCeVRvcGljICkge1xyXG4gICAgICAgICAgICBpZiAoIGJ1Y2tldHNCeVRvcGljLmhhc093blByb3BlcnR5KCB0b3BpYyApICkge1xyXG4gICAgICAgICAgICAgICAgYWdnQnVja2V0cy5wdXNoKCBhZ2dyZWdhdGVCdWNrZXQoIHRoaXMsIGJ1Y2tldHNCeVRvcGljWyB0b3BpYyBdICkgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmaW5hbGx5LCBzb3J0IHRoZW0gYmFzZWQgb24gY291bnRcclxuICAgICAgICBhZ2dCdWNrZXRzLnNvcnQoIGZ1bmN0aW9uKCBhLCBiICkge1xyXG4gICAgICAgICAgICByZXR1cm4gYi50b3RhbCAtIGEudG90YWw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFnZ0J1Y2tldHM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2VudGltZW50IGlkIHN0cmluZyBiYXNlZCBvbiB0aGUgbnVtZXJpY2FsIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBzZW50aW1lbnQgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHNlbnRpbWVudCBpZC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcGFyc2VTZW50aW1lbnQoIHZhbHVlICkge1xyXG4gICAgICAgIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCB2YWx1ZSA9PT0gLTEgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnbmVnYXRpdmUnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIHZhbHVlID09PSAxICkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3Bvc2l0aXZlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICduZXV0cmFsJztcclxuICAgIH1cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvcGljQ291bnRBcnJheUFnZ3JlZ2F0b3I7XHJcblxyXG59KCkpO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIEFnZ3JlZ2F0b3IgPSByZXF1aXJlKCcuL0FnZ3JlZ2F0b3InKSxcclxuICAgICAgICBVdGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9VdGlsJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW50aWF0ZSBhIFRvcGljRnJlcXVlbmN5QWdncmVnYXRvciBvYmplY3QuXHJcbiAgICAgKiBAY2xhc3MgVG9waWNGcmVxdWVuY3lBZ2dyZWdhdG9yXHJcbiAgICAgKiBAY2xhc3NkZXNjXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFRvcGljRnJlcXVlbmN5QWdncmVnYXRvcigpIHtcclxuICAgIH1cclxuXHJcbiAgICBUb3BpY0ZyZXF1ZW5jeUFnZ3JlZ2F0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQWdncmVnYXRvci5wcm90b3R5cGUgKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGFycmF5IG9mIGJ1Y2tldHMsIHdpbGwgZXhlY3V0ZSB0aGUgcHJvdmlkZWQgYWdncmVnYXRpb25cclxuICAgICAqIHNwZWNpZmljYXRpb24gYWdhaW5zdCBhbGwgcmVsZXZhbnQgZW50cmllcy5cclxuICAgICAqIEBtZW1iZXJvZiBUb3BpY0ZyZXF1ZW5jeUFnZ3JlZ2F0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBidWNrZXRzIC0gVGhlIGFycmF5IG9mIGJ1Y2tldHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgYWdncmVnYXRlZCBidWNrZXRzLlxyXG4gICAgICovXHJcbiAgICBUb3BpY0ZyZXF1ZW5jeUFnZ3JlZ2F0b3IucHJvdG90eXBlLmFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKCBidWNrZXRzICkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcclxuICAgICAgICAgICAgaW5kZXhCeVRvcGljID0ge30sXHJcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5nZXRCdWNrZXRSYW5nZSggYnVja2V0cyApLFxyXG4gICAgICAgICAgICBidWNrZXRDb3VudCA9IHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0ICsgMSxcclxuICAgICAgICAgICAgdG9waWNzID0gW107XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKFxyXG4gICAgICAgICAgICBidWNrZXRzLFxyXG4gICAgICAgICAgICBmdW5jdGlvbiggYnVja2V0LCBpbmRleCApIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b3BpY0luZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIHRvcGljLFxyXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsLFxyXG4gICAgICAgICAgICAgICAgICAgIGksIGosXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBidWNrZXQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaT0wOyBpPGJ1Y2tldC5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9waWMgPSBidWNrZXRbaV0udG9waWM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW5kZXhCeVRvcGljWyB0b3BpYyBdID09PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgaW5kZXggaWYgaXQgZG9lcyBub3QgZXhpc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QnlUb3BpY1sgdG9waWMgXSA9IHRvcGljcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9waWM6IHRvcGljLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljRW5nbGlzaDogdGhhdC50cmFuc2xhdGVUb3BpYyggdG9waWMgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmVxdWVuY2llczogVXRpbC5maWxsQXJyYXkoIGJ1Y2tldENvdW50IClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlID0gYnVja2V0W2ldLnNjb3JlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCA9ICggdHlwZW9mIHNjb3JlID09PSBcIm51bWJlclwiIHx8IHNjb3JlIGluc3RhbmNlb2YgQXJyYXkgKSA/IHNjb3JlIDogc2NvcmUudG90YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljSW5kZXggPSBpbmRleEJ5VG9waWNbIHRvcGljIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG90YWwgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIGFnZ3JlZ2F0ZSBhbmQgaW5kZXhlZCBhZ2dyZWdhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdG9waWNzWyB0b3BpY0luZGV4IF0uaW5kZXhlZENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9waWNzW3RvcGljSW5kZXhdLmluZGV4ZWRDb3VudCA9IG5ldyBBcnJheSh0b3RhbC5sZW5ndGgpLmZpbGwoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9waWNzW3RvcGljSW5kZXhdLmluZGV4ZWRGcmVxdWVuY2llcyA9IG5ldyBBcnJheShidWNrZXRDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRvcGljc1t0b3BpY0luZGV4XS5pbmRleGVkRnJlcXVlbmNpZXNbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9waWNzW3RvcGljSW5kZXhdLmluZGV4ZWRGcmVxdWVuY2llc1tpbmRleF0gPSBuZXcgQXJyYXkodG90YWwubGVuZ3RoKS5maWxsKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdW1tZWRUb3RhbCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRvdGFsLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdG90YWxbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtbWVkVG90YWwgKz0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljc1t0b3BpY0luZGV4XS5pbmRleGVkQ291bnRbal0gKz0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljc1t0b3BpY0luZGV4XS5pbmRleGVkRnJlcXVlbmNpZXNbaW5kZXhdW2pdICs9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsID0gc3VtbWVkVG90YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljc1sgdG9waWNJbmRleCBdLmNvdW50ICs9IHRvdGFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BpY3NbIHRvcGljSW5kZXggXS5mcmVxdWVuY2llc1sgaW5kZXggXSA9IHRvdGFsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBzb3J0IHRvcGljcyBiYXNlZCBvbiBjb3VudFxyXG4gICAgICAgIHRvcGljcy5zb3J0KCBmdW5jdGlvbiggYSwgYiApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIuY291bnQgLSBhLmNvdW50O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0b3BpY3M7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gVG9waWNGcmVxdWVuY3lBZ2dyZWdhdG9yO1xyXG5cclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDEzIE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xyXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cclxuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBBZ2dyZWdhdG9yID0gcmVxdWlyZSgnLi9BZ2dyZWdhdG9yJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzZW50aW1lbnQgaWQgc3RyaW5nIGJhc2VkIG9uIHRoZSBudW1lcmljYWwgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHNlbnRpbWVudCB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc2VudGltZW50IGlkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZVNlbnRpbWVudCggdmFsdWUgKSB7XHJcbiAgICAgICAgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIHZhbHVlID09PSAtMSApIHtcclxuICAgICAgICAgICAgcmV0dXJuICduZWdhdGl2ZSc7XHJcbiAgICAgICAgfSBlbHNlIGlmICggdmFsdWUgPT09IDEgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAncG9zaXRpdmUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ25ldXRyYWwnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlYWNoIGJ1Y2tldCwgYW5kIHBlcmZvcm0gdGhlIGFnZ3JlZ2F0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGhzIC0gVGhlIGFycmF5IG9mIHBhdGhzLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYnVja2V0cyAtIFRoZSBhcnJheSBvZiBidWNrZXRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFRoZSBhZ2dyZWdhdGVkIGJ1Y2tldHMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFnZ3JlZ2F0ZUJ1Y2tldCggYnVja2V0cyApIHtcclxuICAgICAgICB2YXIgdHdlZXRzID0gW10sXHJcbiAgICAgICAgICAgIHBhcnNlZCxcclxuICAgICAgICAgICAgdGV4dHMsXHJcbiAgICAgICAgICAgIGJ1Y2tldCxcclxuICAgICAgICAgICAgaSwgajtcclxuICAgICAgICBmb3IgKCBpPTA7IGk8YnVja2V0cy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgYnVja2V0ID0gYnVja2V0c1tpXTtcclxuICAgICAgICAgICAgdGV4dHMgPSBidWNrZXQuc2NvcmUudGV4dHM7XHJcbiAgICAgICAgICAgIGZvciAoIGo9MDsgajx0ZXh0cy5sZW5ndGg7IGorKyApIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoIHRleHRzW2pdLnRleHQgKTtcclxuICAgICAgICAgICAgICAgIHR3ZWV0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB1c2VyOiBwYXJzZWRbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogcGFyc2VkWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbnRpbWVudDogcGFyc2VTZW50aW1lbnQoIHBhcnNlZFsyXSApLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdGV4dHNbal0uc2NvcmVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0d2VldHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW50aWF0ZSBhIFR3ZWV0c0J5VG9waWNBZ2dyZWdhdG9yIG9iamVjdC5cclxuICAgICAqIEBjbGFzcyBUd2VldHNCeVRvcGljQWdncmVnYXRvclxyXG4gICAgICogQGNsYXNzZGVzY1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBUd2VldHNCeVRvcGljQWdncmVnYXRvcigpIHtcclxuICAgIH1cclxuXHJcbiAgICBUd2VldHNCeVRvcGljQWdncmVnYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBBZ2dyZWdhdG9yLnByb3RvdHlwZSApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYW4gYXJyYXkgb2YgYnVja2V0cywgd2lsbCBleGVjdXRlIHRoZSBwcm92aWRlZCBhZ2dyZWdhdGlvblxyXG4gICAgICogc3BlY2lmaWNhdGlvbiBhZ2FpbnN0IGFsbCByZWxldmFudCBlbnRyaWVzLlxyXG4gICAgICogQG1lbWJlcm9mIFR3ZWV0c0J5VG9waWNBZ2dyZWdhdG9yXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYnVja2V0cyAtIFRoZSBhcnJheSBvZiBidWNrZXRzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0QnVja2V0IC0gVGhlIHN0YXJ0IGJ1Y2tldC4gT3B0aW9uYWwuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kQnVja2V0IC0gVGhlIGVuZCBidWNrZXQuIE9wdGlvbmFsLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFnZ3JlZ2F0ZWQgYnVja2V0cy5cclxuICAgICAqL1xyXG4gICAgVHdlZXRzQnlUb3BpY0FnZ3JlZ2F0b3IucHJvdG90eXBlLmFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKCBidWNrZXRzICkge1xyXG4gICAgICAgIHZhciBidWNrZXRzQnlUb3BpYyA9IHt9LFxyXG4gICAgICAgICAgICB0d2VldHNCeVRvcGljID0ge30sXHJcbiAgICAgICAgICAgIHRvcGljO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaChcclxuICAgICAgICAgICAgYnVja2V0cyxcclxuICAgICAgICAgICAgZnVuY3Rpb24oIGJ1Y2tldCApIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b3BpYyxcclxuICAgICAgICAgICAgICAgICAgICBpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBidWNrZXQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaT0wOyBpPGJ1Y2tldC5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9waWMgPSBidWNrZXRbaV0udG9waWM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldHNCeVRvcGljWyB0b3BpYyBdID0gYnVja2V0c0J5VG9waWNbIHRvcGljIF0gfHwgW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldHNCeVRvcGljWyB0b3BpYyBdLnB1c2goIGJ1Y2tldFtpXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyB0aGVuLCBmb3IgZWFjaCBpZCwgYWdncmVnYXRlIHRoZSBidWNrZXRzXHJcbiAgICAgICAgZm9yICggdG9waWMgaW4gYnVja2V0c0J5VG9waWMgKSB7XHJcbiAgICAgICAgICAgIGlmICggYnVja2V0c0J5VG9waWMuaGFzT3duUHJvcGVydHkoIHRvcGljICkgKSB7XHJcbiAgICAgICAgICAgICAgICB0d2VldHNCeVRvcGljWyB0b3BpYyBdID0gYWdncmVnYXRlQnVja2V0KCBidWNrZXRzQnlUb3BpY1sgdG9waWMgXSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0d2VldHNCeVRvcGljO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFR3ZWV0c0J5VG9waWNBZ2dyZWdhdG9yO1xyXG5cclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xyXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cclxuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyksXHJcbiAgICAgICAgUHViU3ViID0gcmVxdWlyZSgnLi4vdXRpbC9QdWJTdWInKSxcclxuICAgICAgICBBeGlzVXRpbCA9IHJlcXVpcmUoJy4vQXhpc1V0aWwnKSxcclxuICAgICAgICBBWElTX1RJVExFX0NMQVNTID0gXCJheGlzLXRpdGxlLWxhYmVsXCIsXHJcbiAgICAgICAgQVhJU19ESVZfQ0xBU1NfU1VGRklYID0gXCItYXhpc1wiLFxyXG4gICAgICAgIEFYSVNfSEVBREVSX0NMQVNTID0gXCJheGlzLWhlYWRlclwiLFxyXG4gICAgICAgIEFYSVNfSEVBREVSX0NMQVNTX1NVRkZJWCA9IFwiLWF4aXMtaGVhZGVyXCIsXHJcbiAgICAgICAgQVhJU19DT05URU5UX0NMQVNTID0gXCJheGlzLWNvbnRlbnRcIixcclxuICAgICAgICBBWElTX0NPTlRFTlRfQ0xBU1NfU1VGRklYID0gXCItYXhpcy1jb250ZW50XCIsXHJcbiAgICAgICAgQVhJU19MQUJFTF9DTEFTUyA9IFwiYXhpcy1tYXJrZXItbGFiZWxcIixcclxuICAgICAgICBBWElTX1BPU0lUSU9ORURfTEFCRUxfQ0xBU1NfU1VGRklYID0gXCItYXhpcy1tYXJrZXItbGFiZWxcIiAsXHJcbiAgICAgICAgQVhJU19NQVJLRVJfQ0xBU1MgPSBcImF4aXMtbWFya2VyXCIsXHJcbiAgICAgICAgQVhJU19NQVJLRVJfU1VGRklYID0gXCItYXhpcy1tYXJrZXJcIixcclxuICAgICAgICBBWElTX1BPU0lUSU9OX1NVRkZJWCA9IFwiLWF4aXNcIixcclxuICAgICAgICBTUEFDSU5HX0JFVFdFRU5fTUFSS0VSX0FORF9MQUJFTCA9IDUsXHJcbiAgICAgICAgWl9JTkRFWCA9IDIwMDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgZHVtbXkgbWFya2VyIGxhYmVsIGVsZW1lbnQgdG8gbWVhc3VyZS4gVGhpcyBmdW5jdGlvblxyXG4gICAgICogaXMgdXNlZCBmb3IgbWVhc3VyaW5nLCBhcyB0aGUgcmVhbCBsYWJlbCBmdW5jIHNpemVzIHRoZSBsYWJlbHMgdG8gdGhlIGN1cnJlbnRcclxuICAgICAqIG1heCBtZWFzdXJlbWVudHNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF4aXMgICB7QXhpc30gICAgIHRoZSBheGlzIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBtYXJrZXIge09iamVjdH0gdGhlIG1hcmtlciBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUR1bW15TWFya2VyTGFiZWxIVE1MKCBheGlzLCBtYXJrZXIgKSB7XHJcbiAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwiJyArIEFYSVNfTEFCRUxfQ0xBU1NcclxuICAgICAgICAgICAgKyAnICcgKyBheGlzLmhvcml6b250YWxPclZlcnRpY2FsICsgQVhJU19QT1NJVElPTkVEX0xBQkVMX0NMQVNTX1NVRkZJWCArICdcIidcclxuICAgICAgICAgICAgKyAnc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTtcIj4nXHJcbiAgICAgICAgICAgICsgYXhpcy5mb3JtYXQoIG1hcmtlci5sYWJlbCApXHJcbiAgICAgICAgICAgICsgJzwvZGl2Pic7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbWFya2VyIGxhYmVsIGVsZW1lbnQgd2l0aCBwcm9wZXIgQ1NTXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBheGlzICAge0F4aXN9ICAgICB0aGUgYXhpcyBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gbWFya2VyIHtPYmplY3R9IHRoZSBtYXJrZXIgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVNYXJrZXJMYWJlbEhUTUwoIGF4aXMsIG1hcmtlciApIHtcclxuICAgICAgICB2YXIgcHJpbWFyeVBvc2l0aW9uLFxyXG4gICAgICAgICAgICBzZWNvbmRhcnlQb3NpdGlvbjtcclxuICAgICAgICBpZiAoIGF4aXMuaXNYQXhpcyApIHtcclxuICAgICAgICAgICAgLy8gaWYgeCBheGlzLCBhZGQgaGFsZiBvZiBsYWJlbCBsZW5ndGggYXMgdGV4dCBpcyBhbmNob3JlZCBmcm9tIGJvdHRvbVxyXG4gICAgICAgICAgICBwcmltYXJ5UG9zaXRpb24gPSBtYXJrZXIucGl4ZWwgLSBheGlzLk1BWF9MQUJFTF9VTlJPVEFURURfV0lEVEgqMC41O1xyXG4gICAgICAgICAgICBzZWNvbmRhcnlQb3NpdGlvbiA9ICBheGlzLkxBUkdFX01BUktFUl9MRU5HVEhcclxuICAgICAgICAgICAgICAgICsgU1BBQ0lOR19CRVRXRUVOX01BUktFUl9BTkRfTEFCRUw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcHJpbWFyeVBvc2l0aW9uID0gbWFya2VyLnBpeGVsIC0gYXhpcy5NQVhfTEFCRUxfSEVJR0hUKjAuNTtcclxuICAgICAgICAgICAgc2Vjb25kYXJ5UG9zaXRpb24gPSAgYXhpcy5MQVJHRV9NQVJLRVJfTEVOR1RIXHJcbiAgICAgICAgICAgICAgICArIFNQQUNJTkdfQkVUV0VFTl9NQVJLRVJfQU5EX0xBQkVMO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCInICsgQVhJU19MQUJFTF9DTEFTUyArICcgJ1xyXG4gICAgICAgICAgICArIGF4aXMuaG9yaXpvbnRhbE9yVmVydGljYWwgKyBBWElTX1BPU0lUSU9ORURfTEFCRUxfQ0xBU1NfU1VGRklYICsgJ1wiJ1xyXG4gICAgICAgICAgICArICdzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlOydcclxuICAgICAgICAgICAgKyAndGV4dC1hbGlnbjogY2VudGVyOyAnICAgIC8vIGNlbnRlciB0ZXh0IGhvcml6b250YWxseVxyXG4gICAgICAgICAgICArICdoZWlnaHQ6ICcgKyBheGlzLk1BWF9MQUJFTF9IRUlHSFQgKyAncHg7J1xyXG4gICAgICAgICAgICArICdsaW5lLWhlaWdodDogJyArIGF4aXMuTUFYX0xBQkVMX0hFSUdIVCArICdweDsnICAgLy8gY2VudGVyIHRleHQgdmVydGljYWxseVxyXG4gICAgICAgICAgICArIGF4aXMubGVmdE9yVG9wICsgXCI6XCIgKyBwcmltYXJ5UG9zaXRpb24gKyAncHg7J1xyXG4gICAgICAgICAgICArIGF4aXMub3Bwb3NpdGVQb3NpdGlvbiArIFwiOlwiICsgc2Vjb25kYXJ5UG9zaXRpb24gKyAncHg7XCI+J1xyXG4gICAgICAgICAgICArIGF4aXMuZm9ybWF0KCBtYXJrZXIubGFiZWwgKVxyXG4gICAgICAgICAgICArJzwvZGl2Pic7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbGFyZ2UgbWFya2VyIGVsZW1lbnQgd2l0aCBwcm9wZXIgQ1NTXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBheGlzICAge0F4aXN9ICAgICB0aGUgYXhpcyBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gbWFya2VyIHtPYmplY3R9IHRoZSBtYXJrZXIgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVMYXJnZU1hcmtlckhUTUwoIGF4aXMsIG1hcmtlciApIHtcclxuICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCInICsgQVhJU19NQVJLRVJfQ0xBU1NcclxuICAgICAgICAgICAgKyAnIGxhcmdlLScgKyBheGlzLmhvcml6b250YWxPclZlcnRpY2FsICsgQVhJU19NQVJLRVJfU1VGRklYXHJcbiAgICAgICAgICAgICsgJyAnICsgYXhpcy5wb3NpdGlvbiArIEFYSVNfUE9TSVRJT05fU1VGRklYICsgJ1wiJ1xyXG4gICAgICAgICAgICArICdzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlOydcclxuICAgICAgICAgICAgKyBheGlzLmxlZnRPclRvcCArIFwiOlwiICsgKG1hcmtlci5waXhlbCAtIGF4aXMuTEFSR0VfTUFSS0VSX0hBTEZfV0lEVEgpICsgJ3B4O1wiPidcclxuICAgICAgICAgICAgKyAnPC9kaXY+JztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBtYWpvciBtYXJrZXIgZWxlbWVudCB3aXRoIHByb3BlciBDU1NcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF4aXMgICB7QXhpc30gICAgIHRoZSBheGlzIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBtYXJrZXIge09iamVjdH0gdGhlIG1hcmtlciBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1lZGl1bU1hcmtlckhUTUwoIGF4aXMsIG1hcmtlciApIHtcclxuICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCInICsgQVhJU19NQVJLRVJfQ0xBU1NcclxuICAgICAgICAgICAgKyAnIG1lZGl1bS0nICsgYXhpcy5ob3Jpem9udGFsT3JWZXJ0aWNhbCArIEFYSVNfTUFSS0VSX1NVRkZJWFxyXG4gICAgICAgICAgICArICcgJyArIGF4aXMucG9zaXRpb24gKyBBWElTX1BPU0lUSU9OX1NVRkZJWCArICdcIidcclxuICAgICAgICAgICAgKyAnc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTsnXHJcbiAgICAgICAgICAgICsgYXhpcy5sZWZ0T3JUb3AgKyBcIjpcIiArIChtYXJrZXIucGl4ZWwgLSBheGlzLk1FRElVTV9NQVJLRVJfSEFMRl9XSURUSCkgKyAncHg7XCI+J1xyXG4gICAgICAgICAgICArICc8L2Rpdj4nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG1ham9yIG1hcmtlciBlbGVtZW50IHdpdGggcHJvcGVyIENTU1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXhpcyAgIHtBeGlzfSAgICAgdGhlIGF4aXMgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIG1hcmtlciB7T2JqZWN0fSB0aGUgbWFya2VyIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlU21hbGxNYXJrZXJIVE1MKCBheGlzLCBtYXJrZXIgKSB7XHJcbiAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwiJyArIEFYSVNfTUFSS0VSX0NMQVNTXHJcbiAgICAgICAgICAgICsgJyBzbWFsbC0nICsgYXhpcy5ob3Jpem9udGFsT3JWZXJ0aWNhbCArIEFYSVNfTUFSS0VSX1NVRkZJWFxyXG4gICAgICAgICAgICArICcgJyArIGF4aXMucG9zaXRpb24gKyBBWElTX1BPU0lUSU9OX1NVRkZJWCArICdcIidcclxuICAgICAgICAgICAgKyAnc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTsnXHJcbiAgICAgICAgICAgICsgYXhpcy5sZWZ0T3JUb3AgKyBcIjpcIiArIChtYXJrZXIucGl4ZWwgLSBheGlzLlNNQUxMX01BUktFUl9IQUxGX1dJRFRIKSArICdweDtcIj4nXHJcbiAgICAgICAgICAgICsgJzwvZGl2Pic7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWVhc3VyZUxhYmVsUm90YXRpb24oIGF4aXMsICRsYWJlbCApIHtcclxuICAgICAgICB2YXIgbWF0cml4LCB2YWx1ZXMsIGFuZ2xlO1xyXG4gICAgICAgIG1hdHJpeCA9ICRsYWJlbC5jc3MoXCItd2Via2l0LXRyYW5zZm9ybVwiKSB8fFxyXG4gICAgICAgICAgICAgICAgICRsYWJlbC5jc3MoXCItbW96LXRyYW5zZm9ybVwiKSAgICB8fFxyXG4gICAgICAgICAgICAgICAgICRsYWJlbC5jc3MoXCItbXMtdHJhbnNmb3JtXCIpICAgICB8fFxyXG4gICAgICAgICAgICAgICAgICRsYWJlbC5jc3MoXCItby10cmFuc2Zvcm1cIikgICAgICB8fFxyXG4gICAgICAgICAgICAgICAgICRsYWJlbC5jc3MoXCJ0cmFuc2Zvcm1cIikgfHwgJ25vbmUnO1xyXG4gICAgICAgIGlmKG1hdHJpeCAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcyA9IG1hdHJpeC5zcGxpdCgnKCcpWzFdLnNwbGl0KCcpJylbMF0uc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKHZhbHVlc1sxXSwgdmFsdWVzWzBdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhbmdsZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF4aXMuUk9UQVRJT05fUkFESUFOUyA9IE1hdGguYWJzKGFuZ2xlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtZWFzdXJlTGFiZWxFbGVtZW50KCBheGlzLCAkbGFiZWwgKSB7XHJcbiAgICAgICAgdmFyIHNpblcgPSAkbGFiZWwud2lkdGgoKSAqIE1hdGguc2luKCBheGlzLlJPVEFUSU9OX1JBRElBTlMgKSxcclxuICAgICAgICAgICAgc2luSCA9ICRsYWJlbC5oZWlnaHQoKSAqIE1hdGguc2luKCBheGlzLlJPVEFUSU9OX1JBRElBTlMgKSxcclxuICAgICAgICAgICAgY29zVyA9ICRsYWJlbC53aWR0aCgpICogTWF0aC5jb3MoIGF4aXMuUk9UQVRJT05fUkFESUFOUyApLFxyXG4gICAgICAgICAgICBjb3NIID0gJGxhYmVsLmhlaWdodCgpICogTWF0aC5jb3MoIGF4aXMuUk9UQVRJT05fUkFESUFOUyApO1xyXG4gICAgICAgIGF4aXMuTUFYX0xBQkVMX1dJRFRIID0gTWF0aC5tYXgoIHNpbkggKyBjb3NXLCBheGlzLk1BWF9MQUJFTF9XSURUSCApO1xyXG4gICAgICAgIGF4aXMuTUFYX0xBQkVMX0hFSUdIVCA9IE1hdGgubWF4KCBjb3NIICsgc2luVywgYXhpcy5NQVhfTEFCRUxfSEVJR0hUICk7XHJcbiAgICAgICAgYXhpcy5NQVhfTEFCRUxfVU5ST1RBVEVEX1dJRFRIID0gTWF0aC5tYXgoICRsYWJlbC53aWR0aCgpLCBheGlzLk1BWF9MQUJFTF9VTlJPVEFURURfV0lEVEggKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtZWFzdXJlTGFiZWxEaW1lbnNpb25zKCBheGlzICkge1xyXG4gICAgICAgIHZhciBtaW4gPSB7XHJcbiAgICAgICAgICAgICAgICBwaXhlbDogMCxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBheGlzLm1pblxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtYXggPSB7XHJcbiAgICAgICAgICAgICAgICBwaXhlbDogMCxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBheGlzLm1heFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAkdGVtcDtcclxuICAgICAgICAvLyBjbGVhciBwcmV2aW91cyBtZWFzdXJlbWVudHNcclxuICAgICAgICBheGlzLk1BWF9MQUJFTF9XSURUSCA9IDA7XHJcbiAgICAgICAgYXhpcy5NQVhfTEFCRUxfSEVJR0hUID0gMDtcclxuICAgICAgICBheGlzLk1BWF9MQUJFTF9VTlJPVEFURURfV0lEVEggPSAwO1xyXG4gICAgICAgIC8vIG1lYXN1cmUgbWF4IGxhYmVsXHJcbiAgICAgICAgJHRlbXAgPSAkKCBjcmVhdGVEdW1teU1hcmtlckxhYmVsSFRNTCggYXhpcywgbWF4ICkgKS5hcHBlbmRUbyggYXhpcy4kY29udGVudCApO1xyXG4gICAgICAgIG1lYXN1cmVMYWJlbEVsZW1lbnQoIGF4aXMsICR0ZW1wICk7XHJcbiAgICAgICAgJHRlbXAucmVtb3ZlKCk7XHJcbiAgICAgICAgLy8gbWVhc3VyZSBtaW4gbGFiZWxcclxuICAgICAgICAkdGVtcCA9ICQoIGNyZWF0ZUR1bW15TWFya2VyTGFiZWxIVE1MKCBheGlzLCBtaW4gKSApLmFwcGVuZFRvKCBheGlzLiRjb250ZW50ICk7XHJcbiAgICAgICAgbWVhc3VyZUxhYmVsRWxlbWVudCggYXhpcywgJHRlbXAgKTtcclxuICAgICAgICAkdGVtcC5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjcmVhdGUgdGVtcG9yYXJ5IGVsZW1lbnRzIHRvIGRldGVybWluZSB0aGUgcmVxdWlyZWQgcnVuLXRpbWVcclxuICAgICAqIGRpbWVuc2lvbnMuIFRoaXMgaXMgb25seSBiZSBjYWxsZWQgb25jZSBwZXIgYXhpcyBhcyB0aGVzZSBkaW1lbnNpb25zIHdpbGwgbmV2ZXIgY2hhbmdlLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXhpc3tBeGlzfSB0aGUgYXhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNhbGNFbGVtZW50RGltZW5zaW9ucyggYXhpcyApIHtcclxuICAgICAgICB2YXIgJHRlbXA7XHJcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgYWxsIG1lYXN1cmVtZW50cyB0byB6ZXJvXHJcbiAgICAgICAgYXhpcy5MQVJHRV9NQVJLRVJfTEVOR1RIID0gMDtcclxuICAgICAgICBheGlzLkxBUkdFX01BUktFUl9IQUxGX1dJRFRIID0gMDtcclxuICAgICAgICBheGlzLk1FRElVTV9NQVJLRVJfSEFMRl9XSURUSCA9IDA7XHJcbiAgICAgICAgYXhpcy5TTUFMTF9NQVJLRVJfSEFMRl9XSURUSCA9IDA7XHJcbiAgICAgICAgYXhpcy5ST1RBVElPTl9SQURJQU5TID0gMDtcclxuICAgICAgICBheGlzLkhFQURFUl9XSURUSCA9IDA7XHJcbiAgICAgICAgYXhpcy5USVRMRV9XSURUSCA9IDA7XHJcbiAgICAgICAgaWYgKCBheGlzLnRpdGxlICkge1xyXG4gICAgICAgICAgICAvLyB0aXRsZSB3aWR0aFxyXG4gICAgICAgICAgICBheGlzLlRJVExFX1dJRFRIID0gYXhpcy4kdGl0bGUud2lkdGgoKTtcclxuICAgICAgICAgICAgLy8gaGVhZGVyIHdpZHRoXHJcbiAgICAgICAgICAgIHN3aXRjaCAoIGF4aXMucG9zaXRpb24gKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9wXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5IRUFERVJfV0lEVEggPSBwYXJzZUludCggYXhpcy4kaGVhZGVyLmNzcyhcImJvcmRlci10b3Atd2lkdGhcIiksIDEwICk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcclxuICAgICAgICAgICAgICAgICAgICBheGlzLkhFQURFUl9XSURUSCA9IHBhcnNlSW50KCBheGlzLiRoZWFkZXIuY3NzKFwiYm9yZGVyLXJpZ2h0LXdpZHRoXCIpLCAxMCApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMuSEVBREVSX1dJRFRIID0gcGFyc2VJbnQoIGF4aXMuJGhlYWRlci5jc3MoXCJib3JkZXItYm90dG9tLXdpZHRoXCIpLCAxMCApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcclxuICAgICAgICAgICAgICAgICAgICBheGlzLkhFQURFUl9XSURUSCA9IHBhcnNlSW50KCBheGlzLiRoZWFkZXIuY3NzKFwiYm9yZGVyLWxlZnQtd2lkdGhcIiksIDEwICk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbWVhc3VyZSBsYXJnZSBtYXJrZXJzXHJcbiAgICAgICAgJHRlbXAgPSAkKGNyZWF0ZUxhcmdlTWFya2VySFRNTCggYXhpcywge3BpeGVsOjB9ICkpLmhpZGUoKS5hcHBlbmRUbyhheGlzLiRjb250ZW50KTtcclxuICAgICAgICBheGlzLkxBUkdFX01BUktFUl9MRU5HVEggPSAkdGVtcFtheGlzLm1hcmtlcldpZHRoT3JIZWlnaHRdKCk7XHJcbiAgICAgICAgYXhpcy5MQVJHRV9NQVJLRVJfSEFMRl9XSURUSCA9IE1hdGguZmxvb3IoICR0ZW1wW2F4aXMuYXhpc1dpZHRoT3JIZWlnaHRdKCkqMC41ICk7XHJcbiAgICAgICAgJHRlbXAucmVtb3ZlKCk7XHJcbiAgICAgICAgLy8gbWVhc3VyZSBtZWRpdW0gbWFya2Vyc1xyXG4gICAgICAgICR0ZW1wID0gJChjcmVhdGVNZWRpdW1NYXJrZXJIVE1MKCBheGlzLCB7cGl4ZWw6MH0gKSkuaGlkZSgpLmFwcGVuZFRvKGF4aXMuJGNvbnRlbnQpO1xyXG4gICAgICAgIGF4aXMuTUVESVVNX01BUktFUl9IQUxGX1dJRFRIID0gTWF0aC5mbG9vciggJHRlbXBbYXhpcy5heGlzV2lkdGhPckhlaWdodF0oKSAqIDAuNSk7XHJcbiAgICAgICAgJHRlbXAucmVtb3ZlKCk7XHJcbiAgICAgICAgLy8gbWVhc3VyZSBzbWFsbCBtYXJrZXJzXHJcbiAgICAgICAgJHRlbXAgPSAkKGNyZWF0ZVNtYWxsTWFya2VySFRNTCggYXhpcywge3BpeGVsOjB9ICkpLmhpZGUoKS5hcHBlbmRUbyhheGlzLiRjb250ZW50KTtcclxuICAgICAgICBheGlzLlNNQUxMX01BUktFUl9IQUxGX1dJRFRIID0gTWF0aC5mbG9vciggJHRlbXBbYXhpcy5heGlzV2lkdGhPckhlaWdodF0oKSAqIDAuNSk7XHJcbiAgICAgICAgJHRlbXAucmVtb3ZlKCk7XHJcbiAgICAgICAgLy8gbWVhc3VyZSBsYWJlbCByb3RhdGlvblxyXG4gICAgICAgICR0ZW1wID0gJCggY3JlYXRlRHVtbXlNYXJrZXJMYWJlbEhUTUwoIGF4aXMsIHtwaXhlbDowfSApICkuYXBwZW5kVG8oIGF4aXMuJGNvbnRlbnQgKTtcclxuICAgICAgICBtZWFzdXJlTGFiZWxSb3RhdGlvbiggYXhpcywgJHRlbXAgKTtcclxuICAgICAgICAkdGVtcC5yZW1vdmUoKTtcclxuICAgICAgICAvLyBtZWFzdXJlIGxhYmVsIGRpbWVuc2lvbnNcclxuICAgICAgICBtZWFzdXJlTGFiZWxEaW1lbnNpb25zKCBheGlzICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIHRoZSBheGlzIGxhYmVsIGVsZW1lbnQgd2l0aCBwcm9wZXIgQ1NTLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXhpcyB7QXhpc30gdGhlIGF4aXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVUaXRsZSggYXhpcyApIHtcclxuICAgICAgICB2YXIgcm90YXRpb24gPSBcIlwiLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW4gPVwiXCI7XHJcbiAgICAgICAgaWYgKCAhYXhpcy5pc1hBeGlzICkge1xyXG4gICAgICAgICAgICByb3RhdGlvbiA9IFwicm90YXRlKC05MGRlZylcIjtcclxuICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luID0gXCJ0b3AgbGVmdFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJCgnPHNwYW4gY2xhc3M9XCInK0FYSVNfVElUTEVfQ0xBU1MrJ1wiJ1xyXG4gICAgICAgICAgICArICdzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlOydcclxuICAgICAgICAgICAgKyAnLXdlYmtpdC10cmFuc2Zvcm06ICcgKyByb3RhdGlvbiArIFwiO1wiXHJcbiAgICAgICAgICAgICsgJy1tb3otdHJhbnNmb3JtOiAnICsgcm90YXRpb24gKyBcIjtcIlxyXG4gICAgICAgICAgICArICctbXMtdHJhbnNmb3JtOiAnICsgcm90YXRpb24gKyBcIjtcIlxyXG4gICAgICAgICAgICArICctby10cmFuc2Zvcm06ICcgKyByb3RhdGlvbiArIFwiO1wiXHJcbiAgICAgICAgICAgICsgJ3RyYW5zZm9ybTogJyArIHJvdGF0aW9uICsgXCI7XCJcclxuICAgICAgICAgICAgKyAnLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiAnICsgdHJhbnNmb3JtT3JpZ2luICsgXCI7XCJcclxuICAgICAgICAgICAgKyAnLW1vei10cmFuc2Zvcm0tb3JpZ2luOiAnICsgdHJhbnNmb3JtT3JpZ2luICsgXCI7XCJcclxuICAgICAgICAgICAgKyAnLW1zLXRyYW5zZm9ybS1vcmlnaW46ICcgKyB0cmFuc2Zvcm1PcmlnaW4gKyBcIjtcIlxyXG4gICAgICAgICAgICArICctby10cmFuc2Zvcm0tb3JpZ2luOiAnICsgdHJhbnNmb3JtT3JpZ2luICsgXCI7XCJcclxuICAgICAgICAgICAgKyAndHJhbnNmb3JtLW9yaWdpbjogJyArIHRyYW5zZm9ybU9yaWdpbiArIFwiO1wiXHJcbiAgICAgICAgICAgICsgJ1wiPicgKyBheGlzLnRpdGxlICsgJzwvZGl2PicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyB0aGUgYXhpcyBoZWFkZXIganF1ZXJ5IG9iamVjdC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF4aXMge0F4aXN9IHRoZSBheGlzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlSGVhZGVyKCBheGlzICkge1xyXG4gICAgICAgIHJldHVybiAkKCc8ZGl2IGNsYXNzPVwiJysgQVhJU19IRUFERVJfQ0xBU1MgKyBcIiBcIiArIGF4aXMuaG9yaXpvbnRhbE9yVmVydGljYWwgKyAnLWhlYWRlcicgK1wiIFwiICsgYXhpcy5wb3NpdGlvbiArIEFYSVNfSEVBREVSX0NMQVNTX1NVRkZJWCArICdcIidcclxuICAgICAgICAgICAgICAgKyAnc3R5bGU9XCJ6LWluZGV4OicrKFpfSU5ERVgrMikrJztcIj48L2Rpdj4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgdGhlIGF4aXMgaGVhZGVyIGJhY2tncm91bmQganF1ZXJ5IG9iamVjdC4gVGhpcyBpcyB1c2VkXHJcbiAgICAgKiB0byBhcHBseSBhIGJveC1zaGFkb3cgY3NzIHdpdGhvdXQgdWdseSBvdmVybGFwLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXhpcyB7QXhpc30gdGhlIGF4aXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVIZWFkZXJCYWNrKCBheGlzICkge1xyXG4gICAgICAgIHJldHVybiAkKCc8ZGl2IGNsYXNzPVwiJysgQVhJU19IRUFERVJfQ0xBU1MgKyBcIiBcIiArIEFYSVNfSEVBREVSX0NMQVNTICsgXCItYmFjayBcIiArIGF4aXMuaG9yaXpvbnRhbE9yVmVydGljYWwgKyAnLWhlYWRlci1iYWNrJyArICdcIidcclxuICAgICAgICAgICAgICAgKyAnc3R5bGU9XCJ6LWluZGV4OicrKFpfSU5ERVgrMSkrJzsnXHJcbiAgICAgICAgICAgICAgICsgYXhpcy5wb3NpdGlvbiArICc6MHB4OydcclxuICAgICAgICAgICAgICAgKyAoIGF4aXMuaXNYQXhpcyA/ICcnIDogJ3RvcDowcHg7JykgKyAnXCI+PC9kaXY+JyApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyB0aGUgZW1wdHkgYXhpcyBjb250ZW50IGpxdWVyeSBvYmplY3QuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBheGlzIHtBeGlzfSB0aGUgYXhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbnRlbnQoIGF4aXMgKSB7XHJcbiAgICAgICAgcmV0dXJuICQoJzxkaXYgY2xhc3M9XCInKyBBWElTX0NPTlRFTlRfQ0xBU1NcclxuICAgICAgICAgICAgICAgKyBcIiBcIiArIGF4aXMucG9zaXRpb24gKyBBWElTX0NPTlRFTlRfQ0xBU1NfU1VGRklYXHJcbiAgICAgICAgICAgICAgICsgJ1wiICBzdHlsZT1cInotaW5kZXg6JytaX0lOREVYKyc7XCI+PC9kaXY+Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIHRoZSBheGlzIHBhcmVudCBkaXYganF1ZXJ5IG9iamVjdC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF4aXMge0F4aXN9IHRoZSBheGlzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlQXhpcyggYXhpcyApIHtcclxuICAgICAgICB2YXIgJGF4aXMsXHJcbiAgICAgICAgICAgIGVuYWJsZVNsaWRlLFxyXG4gICAgICAgICAgICBkaXNhYmxlU2xpZGUsXHJcbiAgICAgICAgICAgIGhvcml6b250YWxTbGlkZSxcclxuICAgICAgICAgICAgdmVydGljYWxTbGlkZTtcclxuICAgICAgICBlbmFibGVTbGlkZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBzZXQgZW5hYmxlIC8gZGlzYWJsZSBjYWxsYmFja3MgaWYgY29sbGFwc2libGUgYXhpc1xyXG4gICAgICAgICAgICBpZiAoIGF4aXMuaXNYQXhpcyApIHtcclxuICAgICAgICAgICAgICAgIGF4aXMuJGhlYWRlci5jbGljayggdmVydGljYWxTbGlkZSApO1xyXG4gICAgICAgICAgICAgICAgYXhpcy4kY29udGVudC5jbGljayggdmVydGljYWxTbGlkZSApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXhpcy4kaGVhZGVyLmNsaWNrKCBob3Jpem9udGFsU2xpZGUgKTtcclxuICAgICAgICAgICAgICAgIGF4aXMuJGNvbnRlbnQuY2xpY2soIGhvcml6b250YWxTbGlkZSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBkaXNhYmxlU2xpZGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgYXhpcy4kaGVhZGVyLm9mZignY2xpY2snKTtcclxuICAgICAgICAgICAgYXhpcy4kY29udGVudC5vZmYoJ2NsaWNrJyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBob3Jpem9udGFsU2xpZGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgYXhpcy5zZXRFbmFibGVkKCAhYXhpcy5pc0VuYWJsZWQoKSApO1xyXG4gICAgICAgICAgICBheGlzLnVwZGF0ZURpbWVuc2lvbigpO1xyXG4gICAgICAgICAgICBkaXNhYmxlU2xpZGUoKTtcclxuICAgICAgICAgICAgYXhpcy4kY29udGVudC5hbmltYXRlKHt3aWR0aDogJ3RvZ2dsZSd9LCB7ZHVyYXRpb246IDMwMCwgY29tcGxldGU6IGZ1bmN0aW9uKCl7IGVuYWJsZVNsaWRlKCk7fSB9KTtcclxuICAgICAgICAgICAgYXhpcy5yZWRyYXcoKTtcclxuICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goIGF4aXMuZ2V0Q2hhbm5lbCgpLCB7IGZpZWxkOiAnb3BlbicsIHZhbHVlOiBheGlzLmlzRW5hYmxlZCgpIH0gKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZlcnRpY2FsU2xpZGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgYXhpcy5zZXRFbmFibGVkKCAhYXhpcy5pc0VuYWJsZWQoKSApO1xyXG4gICAgICAgICAgICBheGlzLnVwZGF0ZURpbWVuc2lvbigpO1xyXG4gICAgICAgICAgICBkaXNhYmxlU2xpZGUoKTtcclxuICAgICAgICAgICAgYXhpcy4kY29udGVudC5hbmltYXRlKHtoZWlnaHQ6ICd0b2dnbGUnfSwge2R1cmF0aW9uOiAzMDAsIGNvbXBsZXRlOiBmdW5jdGlvbigpeyBlbmFibGVTbGlkZSgpO30gfSk7XHJcbiAgICAgICAgICAgIGF4aXMucmVkcmF3KCk7XHJcbiAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCBheGlzLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ29wZW4nLCB2YWx1ZTogYXhpcy5pc0VuYWJsZWQoKSB9ICk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBjcmVhdGUgYXhpcyBjb250ZW50IGNvbnRhaW5lciBhbmQgYXBwZW5kIGl0IHRvIHJvb3RcclxuICAgICAgICBheGlzLiRjb250ZW50ID0gY3JlYXRlQ29udGVudCggYXhpcyApO1xyXG4gICAgICAgICRheGlzID0gJCgnPGRpdiBjbGFzcz1cImF4aXMgJysgYXhpcy5wb3NpdGlvbiArIEFYSVNfRElWX0NMQVNTX1NVRkZJWCArICdcIj48L2Rpdj4nKTtcclxuICAgICAgICAkYXhpcy5hcHBlbmQoIGF4aXMuJGNvbnRlbnQgKTtcclxuICAgICAgICBpZiAoIGF4aXMudGl0bGUgICkge1xyXG4gICAgICAgICAgICAvLyBvbmx5IGNyZWF0ZSB0aXRsZSBhbmQgaGVhZGVyIElGIGEgdGl0bGUgaXMgcHJvdmlkZWRcclxuICAgICAgICAgICAgYXhpcy4kdGl0bGUgPSBjcmVhdGVUaXRsZSggYXhpcyApO1xyXG4gICAgICAgICAgICBheGlzLiRoZWFkZXIgPSBjcmVhdGVIZWFkZXIoIGF4aXMgKS5hcHBlbmQoIGF4aXMuJHRpdGxlICk7XHJcbiAgICAgICAgICAgICRheGlzLmFwcGVuZCggYXhpcy4kaGVhZGVyICk7XHJcbiAgICAgICAgICAgICRheGlzLmFwcGVuZCggY3JlYXRlSGVhZGVyQmFjayggYXhpcyApICk7XHJcbiAgICAgICAgICAgIC8vIGVuYWJsZSBjYWxsYmFja3MsIGlmIGNvbGxhcHNpYmxlXHJcbiAgICAgICAgICAgIGlmICggYXhpcy5jb2xsYXBzaWJsZSApIHtcclxuICAgICAgICAgICAgICAgIGVuYWJsZVNsaWRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmV0dXJuIHJvb3RcclxuICAgICAgICByZXR1cm4gJGF4aXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBwb3NpdG9uIG9mIHRoZSBheGlzIHRpdGxlIG9mIGl0cyBzaXplIGNoYW5nZXMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBheGlzIHtBeGlzfSB0aGUgYXhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUF4aXNUaXRsZSggYXhpcyApIHtcclxuICAgICAgICAvLyB1cGRhdGUgYXhpcyBsZW5ndGhcclxuICAgICAgICB2YXIgJHRpdGxlID0gYXhpcy4kdGl0bGUsXHJcbiAgICAgICAgICAgIGF4aXNMZW5ndGgsXHJcbiAgICAgICAgICAgIHBhZGRpbmc7XHJcbiAgICAgICAgLy8gY2FsYyBuZXcgYXhpcyBsZW5ndGhcclxuICAgICAgICBpZiAoIGF4aXMuaXNYQXhpcyApIHtcclxuICAgICAgICAgICAgYXhpc0xlbmd0aCA9IGF4aXMuJG1hcC5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXhpc0xlbmd0aCA9IGF4aXMuJG1hcC5vdXRlckhlaWdodCgpIC0gKGF4aXMuSEVBREVSX1dJRFRIKjIpO1xyXG4gICAgICAgICAgICAvLyBhZGQgcG9zaXRpb24gb2Zmc2V0IGZvciB2ZXJ0aWNhbCBheGVzXHJcbiAgICAgICAgICAgICR0aXRsZS5jc3MoIGF4aXMubGVmdE9yVG9wLCBheGlzTGVuZ3RoK1wicHhcIiApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYWxjIHBhZGRpbmdcclxuICAgICAgICBwYWRkaW5nID0gKCBheGlzTGVuZ3RoLzIgKSAtICggYXhpcy5USVRMRV9XSURUSC8yICk7XHJcbiAgICAgICAgLy8gYWRkIHBhZGRpbmcgZm9yIGhvdmVyIGhpdCBib3hcclxuICAgICAgICAkdGl0bGUuY3NzKCAncGFkZGluZy1sZWZ0JywgcGFkZGluZyArIFwicHhcIiApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgYXhpcyBtYXJrZXIgZWxlbWVudHMgYW5kIGFwcGVuZHMgdGhlbSB0byB0aGUgY29udGVudCBkaXYuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBheGlzIHtBeGlzfSB0aGUgYXhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUF4aXNDb250ZW50KCBheGlzICkge1xyXG4gICAgICAgIHZhciBtYXJrZXJzLFxyXG4gICAgICAgICAgICBtYXJrZXJzSFRNTCA9IFwiXCIsXHJcbiAgICAgICAgICAgIG1hcmtlcnNCeVNpemUsXHJcbiAgICAgICAgICAgIGk7XHJcbiAgICAgICAgLy8gZ2VuZXJhdGUgYXJyYXkgb2YgbWFya2VyIGxhYmVscyBhbmQgcGl4ZWwgbG9jYXRpb25zXHJcbiAgICAgICAgbWFya2Vyc0J5U2l6ZSA9IEF4aXNVdGlsLmdldE1hcmtlcnMoIGF4aXMgKTtcclxuICAgICAgICAvLyBsYXJnZSBtYXJrZXJzXHJcbiAgICAgICAgbWFya2VycyA9IG1hcmtlcnNCeVNpemUubGFyZ2U7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbWFya2Vyc0hUTUwgKz0gY3JlYXRlTGFyZ2VNYXJrZXJIVE1MKCBheGlzLCBtYXJrZXJzW2ldICk7XHJcbiAgICAgICAgICAgIGlmICggbWFya2Vyc1tpXS5sYWJlbCApIHtcclxuICAgICAgICAgICAgICAgIG1hcmtlcnNIVE1MICs9IGNyZWF0ZU1hcmtlckxhYmVsSFRNTCggYXhpcywgbWFya2Vyc1tpXSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG1lZGl1bSBtYXJrZXJzXHJcbiAgICAgICAgbWFya2VycyA9IG1hcmtlcnNCeVNpemUubWVkaXVtO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG1hcmtlcnNIVE1MICs9IGNyZWF0ZU1lZGl1bU1hcmtlckhUTUwoIGF4aXMsIG1hcmtlcnNbaV0gKTtcclxuICAgICAgICAgICAgaWYgKCBtYXJrZXJzW2ldLmxhYmVsICkge1xyXG4gICAgICAgICAgICAgICAgbWFya2Vyc0hUTUwgKz0gY3JlYXRlTWFya2VyTGFiZWxIVE1MKCBheGlzLCBtYXJrZXJzW2ldICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc21hbGwgbWFya2Vyc1xyXG4gICAgICAgIG1hcmtlcnMgPSBtYXJrZXJzQnlTaXplLnNtYWxsO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG1hcmtlcnNIVE1MICs9IGNyZWF0ZVNtYWxsTWFya2VySFRNTCggYXhpcywgbWFya2Vyc1tpXSApO1xyXG4gICAgICAgICAgICBpZiAoIG1hcmtlcnNbaV0ubGFiZWwgKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXJzSFRNTCArPSBjcmVhdGVNYXJrZXJMYWJlbEhUTUwoIGF4aXMsIG1hcmtlcnNbaV0gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhcHBlbmQgYWxsIG1hcmtlcnMgYW5kIGxhYmVscyBhdCBvbmNlXHJcbiAgICAgICAgYXhpcy4kY29udGVudFswXS5pbm5lckhUTUwgPSBtYXJrZXJzSFRNTDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRyYXcgY2FsbGJhY2sgZnVuY3Rpb24gb24gbWFwICdtb3ZlJyBldmVudC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF4aXMge0F4aXN9IFRoZSBheGlzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVkcmF3Q2FsbGJhY2soIGF4aXMgKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBheGlzLnJlZHJhdygpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtb3VzZSBtYXJrZXIgY2FsbGJhY2sgZnVuY3Rpb24gb24gJ21vdXNlbW92ZScgZXZlbnQuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBheGlzIHtBeGlzfSBUaGUgYXhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1vdXNlTW92ZUNhbGxiYWNrKCBheGlzICkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggZXZlbnQgKSB7XHJcbiAgICAgICAgICAgIGlmICggIWF4aXMuZW5hYmxlZCApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWFya2VyID0gQXhpc1V0aWwuZ2V0TWFya2VyKCBheGlzLCBldmVudC54eS54LCBldmVudC54eS55ICk7XHJcbiAgICAgICAgICAgIGF4aXMuJGNvbnRlbnQuZmluZCggJy5tb3VzZS1tYXJrZXInICkucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGF4aXMuJGNvbnRlbnQuYXBwZW5kKCAkKCBjcmVhdGVMYXJnZU1hcmtlckhUTUwoIGF4aXMsIG1hcmtlciApICkuYWRkQ2xhc3MoICdtb3VzZS1tYXJrZXInICkgKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbW91c2UgaG92ZXIgY2FsbGJhY2sgZnVuY3Rpb24gb24gJ21vdXNlb3ZlcicgZXZlbnQuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBheGlzIHtBeGlzfSBUaGUgYXhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1vdXNlSG92ZXJDYWxsYmFjayggYXhpcyApIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gYXhpcy4kY29udGVudC5vZmZzZXQoKSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSBvZmZzZXQubGVmdCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gb2Zmc2V0LnRvcFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG1hcmtlciA9IEF4aXNVdGlsLmdldE1hcmtlciggYXhpcywgcG9zaXRpb24ueCwgcG9zaXRpb24ueSApLFxyXG4gICAgICAgICAgICAgICAgJGxhYmVsO1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmcgbWFya2Vyc1xyXG4gICAgICAgICAgICBheGlzLiRjb250ZW50LmZpbmQoICcuYXhpcy1ob3Zlci1sYWJlbCcgKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgYXhpcy4kY29udGVudC5maW5kKCAnLm1vdXNlLW1hcmtlcicgKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgLy8gY3JlYXRlIGxhYmVsXHJcbiAgICAgICAgICAgICRsYWJlbCA9ICQoJzxkaXYgY2xhc3M9XCJheGlzLWhvdmVyLWxhYmVsIGhvdmVyLWxhYmVsXCIgc3R5bGU9XCInK1xyXG4gICAgICAgICAgICAgICAgYXhpcy5sZWZ0T3JUb3ArJzonKyBtYXJrZXIucGl4ZWwgKydweDtcIj4nK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaG92ZXItbGFiZWwtdGV4dFwiPicrIGF4aXMuZm9ybWF0KCBtYXJrZXIubGFiZWwsIHRydWUgKSArJzwvZGl2PicrXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+Jyk7XHJcbiAgICAgICAgICAgIC8vIGFwcGVuZCBsYWJlbFxyXG4gICAgICAgICAgICBheGlzLiRjb250ZW50LmFwcGVuZCggJGxhYmVsICk7XHJcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIGxhYmVsXHJcbiAgICAgICAgICAgIGlmICggYXhpcy5pc1hBeGlzICkge1xyXG4gICAgICAgICAgICAgICAgJGxhYmVsLmNzcyggYXhpcy5vcHBvc2l0ZVBvc2l0aW9uLCAtKCAkbGFiZWwub3V0ZXJIZWlnaHQoKSArIDEwICkgKTtcclxuICAgICAgICAgICAgICAgICRsYWJlbC5jc3MoICdtYXJnaW4tbGVmdCcsIC0kbGFiZWwub3V0ZXJXaWR0aCgpLzIgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICRsYWJlbC5jc3MoIGF4aXMub3Bwb3NpdGVQb3NpdGlvbiwgLSggJGxhYmVsLm91dGVyV2lkdGgoKSArIDEwICkgKTtcclxuICAgICAgICAgICAgICAgICRsYWJlbC5jc3MoICdtYXJnaW4tdG9wJywgLSRsYWJlbC5vdXRlckhlaWdodCgpLzIgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgYW5kIGFwcGVuZCBtYXJrZXJcclxuICAgICAgICAgICAgYXhpcy4kY29udGVudC5hcHBlbmQoICQoIGNyZWF0ZUxhcmdlTWFya2VySFRNTCggYXhpcywgbWFya2VyICkgKS5hZGRDbGFzcyggJ21vdXNlLW1hcmtlcicgKSApO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtb3VzZSBob3ZlciBjYWxsYmFjayBmdW5jdGlvbiBvbiAnbW91c2VvdXQnIGV2ZW50LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXhpcyB7QXhpc30gVGhlIGF4aXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtb3VzZU91dENhbGxiYWNrKCBheGlzICkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgYXhpcy4kY29udGVudC5maW5kKCAnLmF4aXMtaG92ZXItbGFiZWwnICkucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGF4aXMuJGNvbnRlbnQuZmluZCggJy5tb3VzZS1tYXJrZXInICkucmVtb3ZlKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbnRpYXRlIGFuIEF4aXMgb2JqZWN0LlxyXG4gICAgICogQGNsYXNzIEF4aXNcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBtYXAgYXhpcyBvYmplY3QgdGhhdCB3aWxsIGF0dGFjaCB0byBhIG1hcCBlZGdlIGFuZCBkaXNwbGF5IGNvb3JkaW5hdGVzIGJhc2VkIG9uXHJcbiAgICAgKiAgICAgICAgICAgIHN1cHBsaWVkIGludGVydmFsIGFuZCB1bml0IHNwZWNpZmljYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNwZWMge09iamVjdH0gVGhlIHNwZWNpZmljYXRpb24gb2JqZWN0OlxyXG4gICAgICogPHByZT5cclxuXHQgKiB7XHJcbiAgICAgKiAgICAgcG9zaXRpb24ge1N0cmluZ30gIFNldCB0aGUgcG9zaXRpb24gdG8gdGhlIGJvdHRvbSBvZiB0aGUgbWFwLiBEZWZhdWx0ID0gXCJib3R0b21cIlxyXG4gICAgICogICAgIHRpdGxlICAgIHtTdHJpbmd9ICBTZXQgdGhlIHRpdGxlIG9mIHRoZSBheGlzIGxhYmVsLiBEZWZhdWx0ID0gXCJBeGlzXCJcclxuICAgICAqICAgICBlbmFibGVkICB7Ym9vbGVhbn0gSGF2ZSB0aGUgYXhpcyBpbml0aWFsaXplIHRvIGFuIG9wZW4gb3IgY2xvc2VkIHN0YXRlLiBEZWZhdWx0ID0gdHJ1ZVxyXG4gICAgICogICAgIHJlcGVhdCAgIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYXhpcyByZXBlYXRzLiBEZWZhdWx0ID0gZmFsc2VcclxuICAgICAqICAgICBpbnRlcnZhbHM6IHtcclxuICAgICAqICAgICAgICAgdHlwZSAgICAgICAgICB7U3RyaW5nfSAgV2hldGhlciB0aGUgaW50ZXJ2YWxzIGFyZSBieSBcInBlcmNlbnRhZ2VcIiBvciBieSBcInZhbHVlXCIuIERlZmF1bHQgPSBcInBlcmNlbnRhZ2VcIlxyXG4gICAgICogICAgICAgICBpbmNyZW1lbnQgICAgIHtudW1iZXJ9ICBUaGUgaW50ZXJ2YWwgaW5jcmVtZW50IGluLiBEZWZhdWx0ID0gMTBcclxuICAgICAqICAgICAgICAgcGl2b3QgICAgICAgICB7bnVtYmVyfSAgVGhlIHZhbHVlIGZyb20gd2l0aCBpbmNyZW1lbnRzIGFyZSBnZW5lcmF0ZWQgZnJvbS4gRGVmYXVsdCA9IHVuZGVmaW5lZFxyXG4gICAgICogICAgICAgICBzY2FsZUJ5Wm9vbSAgIHtib29sZWFufSBXaGV0aGVyIHRoZSBpbmNyZW1lbnRzIHNob3VsZCBiZSBzY2FsZWQgYnkgem9vbSBsZXZlbC4gRGVmYXVsdCA9IHRydWVcclxuICAgICAqICAgICAgICAgbWluUGl4ZWxXaWR0aCB7bnVtYmVyfSAgVGhlIG1pbmltdW0gd2lkdGggZm9yIGEgZnVsbCBheGlzIGluY3JlbWVudC4gRGVmYXVsdCA9IHVuZGVmaW5lZDtcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgICAgdW5pdHM6IHtcclxuICAgICAqICAgICAgICAgdHlwZSAgICAge1N0cmluZ30gIFRoZSB0eXBlIG9mIHVuaXQsIFtcImludGVnZXJcIiwgXCJkZWNpbWFsXCIsIFwidGhvdXNhbmRzXCIsIFwibWlsbGlvbnNcIiwgXCJiaWxsaW9uc1wiLCBcImRlZ3JlZXNcIl0uIERlZmF1bHQgPSBcImRlY2ltYWxcIlxyXG4gICAgICogICAgICAgICBkZWNpbWFscyB7bnVtYmVyfSAgVGhlIG51bWJlciBvZiBkZWNpbWFscyB0byBkaXNwbGF5LCBpZiBhcHBsaWNhYmxlLiBEZWZhdWx0ID0gMlxyXG4gICAgICogICAgICAgICBzdGVwRG93biB7Ym9vbGVhbn0gV2hldGhlciB2YWx1ZXMgc2hvdWxkIHN0ZXAgZG93biBieSB1bml0IHR5cGUsIGlmIGFwcGxpY2FibGUuIERlZmF1bHQgPSB0cnVlXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfVxyXG5cdCAqIDwvcHJlPlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBBeGlzKCBzcGVjICkge1xyXG5cclxuICAgICAgICB0aGlzLnV1aWQgPSBVdGlsLmdlbmVyYXRlVXVpZCgpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAoIHNwZWMucG9zaXRpb24gIT09IHVuZGVmaW5lZCApID8gc3BlYy5wb3NpdGlvbi50b0xvd2VyQ2FzZSgpIDogJ2JvdHRvbSc7XHJcbiAgICAgICAgdGhpcy5yZXBlYXQgPSAoIHNwZWMucmVwZWF0ICE9PSB1bmRlZmluZWQgKSA/IHNwZWMucmVwZWF0IDogZmFsc2U7XHJcbiAgICAgICAgdGhpcy50aXRsZSA9IHNwZWMudGl0bGUgfHwgbnVsbDtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSAoIHNwZWMuZW5hYmxlZCAhPT0gdW5kZWZpbmVkICkgPyBzcGVjLmVuYWJsZWQgOiB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29sbGFwc2libGUgPSAoIHNwZWMuY29sbGFwc2libGUgIT09IHVuZGVmaW5lZCApID8gc3BlYy5jb2xsYXBzaWJsZSA6IHRydWU7XHJcbiAgICAgICAgc3BlYy5pbnRlcnZhbHMgPSBzcGVjLmludGVydmFscyB8fCB7fTtcclxuICAgICAgICB0aGlzLmludGVydmFscyA9IHt9O1xyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzLnR5cGUgPSAoIHNwZWMuaW50ZXJ2YWxzLnR5cGUgIT09IHVuZGVmaW5lZCApID8gc3BlYy5pbnRlcnZhbHMudHlwZS50b0xvd2VyQ2FzZSgpIDogJ3BlcmNlbnRhZ2UnO1xyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzLmluY3JlbWVudCA9IHNwZWMuaW50ZXJ2YWxzLmluY3JlbWVudCB8fCAxMDtcclxuICAgICAgICB0aGlzLmludGVydmFscy5waXZvdCA9IHNwZWMuaW50ZXJ2YWxzLnBpdm90O1xyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzLnNjYWxlQnlab29tID0gKCBzcGVjLmludGVydmFscy5zY2FsZUJ5Wm9vbSAhPT0gdW5kZWZpbmVkICkgPyBzcGVjLmludGVydmFscy5zY2FsZUJ5Wm9vbSA6IHRydWU7XHJcbiAgICAgICAgdGhpcy5pbnRlcnZhbHMubWluUGl4ZWxXaWR0aCA9ICggc3BlYy5pbnRlcnZhbHMubWluUGl4ZWxXaWR0aCAhPT0gdW5kZWZpbmVkICkgPyBzcGVjLmludGVydmFscy5taW5QaXhlbFdpZHRoIDogZmFsc2U7XHJcblxyXG4gICAgICAgIHNwZWMudW5pdHMgPSBzcGVjLnVuaXRzIHx8IHt9O1xyXG4gICAgICAgIHRoaXMudW5pdHMgPSB7fTtcclxuICAgICAgICB0aGlzLnVuaXRzLnR5cGUgPSAoIHNwZWMudW5pdHMudHlwZSAhPT0gdW5kZWZpbmVkICkgPyBzcGVjLnVuaXRzLnR5cGUudG9Mb3dlckNhc2UoKSA6ICdkZWNpbWFsJztcclxuICAgICAgICB0aGlzLnVuaXRzLmRlY2ltYWxzID0gc3BlYy51bml0cy5kZWNpbWFscyB8fCAyO1xyXG4gICAgICAgIHRoaXMudW5pdHMuc3RlcERvd24gPSAoIHNwZWMudW5pdHMuc3RlcERvd24gIT09IHVuZGVmaW5lZCApID8gc3BlYy51bml0cy5zdGVwRG93biA6IHRydWU7XHJcbiAgICAgICAgdGhpcy51bml0cy5zY2FsZSA9IHNwZWMudW5pdHMuc2NhbGUgfHwgJ2xpbmVhcic7XHJcblxyXG4gICAgICAgIC8vIGdlbmVyYXRlIG1vcmUgYXR0cmlidXRlc1xyXG4gICAgICAgIHRoaXMuaXNYQXhpcyA9ICggdGhpcy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5wb3NpdGlvbiA9PT0gJ2JvdHRvbScgKTtcclxuICAgICAgICB0aGlzLmF4aXNXaWR0aE9ySGVpZ2h0ID0gdGhpcy5pc1hBeGlzID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIjtcclxuICAgICAgICB0aGlzLm1hcmtlcldpZHRoT3JIZWlnaHQgPSB0aGlzLmlzWEF4aXMgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xyXG4gICAgICAgIHRoaXMubGVmdE9yVG9wID0gdGhpcy5pc1hBeGlzID8gXCJsZWZ0XCIgOiBcInRvcFwiO1xyXG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbE9yVmVydGljYWwgPSAodGhpcy5pc1hBeGlzKSA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XHJcbiAgICAgICAgdGhpcy5vcHBvc2l0ZVBvc2l0aW9uID0gKHRoaXMucG9zaXRpb24gPT09ICdsZWZ0JykgPyAncmlnaHQnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMucG9zaXRpb24gPT09ICdyaWdodCcpID8gJ2xlZnQnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnBvc2l0aW9uID09PSAndG9wJykgPyAnYm90dG9tJyA6ICd0b3AnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWN0aXZhdGVzIHRoZSBBeGlzIG9iamVjdC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG4gICAgICogQG1lbWJlcm9mIEF4aXNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIEF4aXMucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gY3JlYXRlIHVuaXF1ZSBjYWxsYmFja3Mgc28gdGhleSBjYW4gYmUgcmVtb3ZlZCBsYXRlclxyXG4gICAgICAgIHRoaXMucmVkcmF3Q2FsbGJhY2sgPSByZWRyYXdDYWxsYmFjayggdGhpcyApO1xyXG4gICAgICAgIHRoaXMubW91c2VNb3ZlQ2FsbGJhY2sgPSBtb3VzZU1vdmVDYWxsYmFjayggdGhpcyApO1xyXG4gICAgICAgIHRoaXMubW91c2VIb3ZlckNhbGxiYWNrID0gbW91c2VIb3ZlckNhbGxiYWNrKCB0aGlzICk7XHJcbiAgICAgICAgdGhpcy5tb3VzZU91dENhbGxiYWNrID0gbW91c2VPdXRDYWxsYmFjayggdGhpcyApO1xyXG4gICAgICAgIC8vIGF0dGFjaCBjYWxsYmFja3NcclxuICAgICAgICB0aGlzLm1hcC5vbiggJ21vdmUnLCB0aGlzLnJlZHJhd0NhbGxiYWNrICk7XHJcbiAgICAgICAgdGhpcy5tYXAub24oICdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlTW92ZUNhbGxiYWNrICk7XHJcbiAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIGNvcmUgaHRtbCBlbGVtZW50c1xyXG4gICAgICAgIHRoaXMuJG1hcCA9ICQoIHRoaXMubWFwLmdldEVsZW1lbnQoKSApO1xyXG4gICAgICAgIHRoaXMuJGF4aXMgPSBjcmVhdGVBeGlzKCB0aGlzICk7XHJcbiAgICAgICAgdGhpcy4kbWFwLmFwcGVuZCggdGhpcy4kYXhpcyApO1xyXG5cclxuICAgICAgICB0aGlzLiRheGlzLm9uKCAnbW91c2Vtb3ZlJywgdGhpcy5tb3VzZUhvdmVyQ2FsbGJhY2sgKTtcclxuICAgICAgICB0aGlzLiRheGlzLm9uKCAnbW91c2VvdXQnLCB0aGlzLm1vdXNlT3V0Q2FsbGJhY2sgKTtcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBpbmRpdmlkdWFsIGVsZW1lbnRzIG9uY2VcclxuICAgICAgICBjYWxjRWxlbWVudERpbWVuc2lvbnMoIHRoaXMgKTtcclxuICAgICAgICAvLyBjaGVjayBpZiBheGlzIHN0YXJ0cyBvcGVuIG9yIGNsb3NlZFxyXG4gICAgICAgIGlmICggdGhpcy50aXRsZSAmJiAhdGhpcy5lbmFibGVkICkge1xyXG4gICAgICAgICAgICAvLyBzZXQgZW5hYmxlZCB0byB0cnVlLCBhcyB0aGUgdHJpZ2dlcmVkXHJcbiAgICAgICAgICAgIC8vIGNsaWNrIGV2ZW50IHdpbGwgdG9nZ2xlIHRoZSBlbmFibGVkIGZsYWdcclxuICAgICAgICAgICAgLy8gYmFjayB0byBmYWxzZVxyXG4gICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGNsb3NlIGFuZCBza2lwIGFuaW1hdGlvbjtcclxuICAgICAgICAgICAgdGhpcy4kaGVhZGVyLmNsaWNrKCk7XHJcbiAgICAgICAgICAgIHRoaXMuJGNvbnRlbnQuZmluaXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY3RpdmF0ZXMgdGhlIGxheWVyIG9iamVjdC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG4gICAgICogQG1lbWJlcm9mIEF4aXNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIEF4aXMucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLm1hcC5vZmYoICdtb3ZlJywgdGhpcy5yZWRyYXdDYWxsYmFjayApO1xyXG4gICAgICAgIHRoaXMubWFwLm9mZiggJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlQ2FsbGJhY2sgKTtcclxuICAgICAgICB0aGlzLiRheGlzLm9mZiggJ21vdXNlbW92ZScsIHRoaXMubW91c2VIb3ZlckNhbGxiYWNrICk7XHJcbiAgICAgICAgdGhpcy4kYXhpcy5vZmYoICdtb3VzZW91dCcsIHRoaXMubW91c2VPdXRDYWxsYmFjayApO1xyXG4gICAgICAgIHRoaXMuJGF4aXMucmVtb3ZlKCk7XHJcbiAgICAgICAgdGhpcy4kYXhpcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4kdGl0bGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuJGhlYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4kY29udGVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZWRyYXdDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tb3VzZU1vdmVDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tb3VzZUhvdmVyQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubW91c2VPZmZDYWxsYmFjayA9IG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBheGlzIGlzIGN1cnJlbnRseSBlbmFibGVkLCBmYWxzZSBpZiBub3QuXHJcbiAgICAgKiBAbWVtYmVyb2YgQXhpc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYXhpcyBpcyBlbmFibGVkIG9yIG5vdC5cclxuICAgICAqL1xyXG4gICAgQXhpcy5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgYXhpcy5cclxuICAgICAqIEBtZW1iZXJvZiBBeGlzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSAtIFdoZXRoZXIgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGF4aXMuXHJcbiAgICAgKi9cclxuICAgIEF4aXMucHJvdG90eXBlLnNldEVuYWJsZWQgPSBmdW5jdGlvbiggZW5hYmxlZCApIHtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSBlbmFibGVkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpbWVuc2lvbiBvZiB0aGUgY29udGVudCBkaXYgb2YgdGhlIGF4aXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQXhpc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgZGltZW5zaW9uIG9mIHRoZSBjb250ZW50IGRpdi5cclxuICAgICAqL1xyXG4gICAgQXhpcy5wcm90b3R5cGUuZ2V0Q29udGVudERpbWVuc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBkaW0gPSB0aGlzLmlzWEF4aXMgPyB0aGlzLk1BWF9MQUJFTF9IRUlHSFQgOiB0aGlzLk1BWF9MQUJFTF9XSURUSDtcclxuICAgICAgICBpZiAoIHRoaXMudGl0bGUgKSB7XHJcbiAgICAgICAgICAgIGRpbSArPSB0aGlzLkhFQURFUl9XSURUSDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpbSArIFNQQUNJTkdfQkVUV0VFTl9NQVJLRVJfQU5EX0xBQkVMKjIgKyB0aGlzLkxBUkdFX01BUktFUl9MRU5HVEg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhbGwgYXhlcyBvbiB0aGUgbWFwLCBkZXRlcm1pbmVzIHRoZSBtYXggY29udGVudCBzaXplLCBhbmRcclxuICAgICAqIHNldHMgdGhlIGNvbnRlbnQgZGltZW5zaW9uIHRvIHRoYXQgc2l6ZS5cclxuICAgICAqIEBtZW1iZXJvZiBBeGlzXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9IFRoZSBtYXggZGltZW5zaW9uIG9mIHRoZSBheGVzIGF0dGFjaGVkIHRvIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIEF4aXMucHJvdG90eXBlLmdldE1heENvbnRlbnREaW1lbnNpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbWF4QXhpc0xhYmVsRGltID0gMDtcclxuICAgICAgICBfLmZvckluKCB0aGlzLm1hcC5heGVzLCBmdW5jdGlvbiggYXhpcyApIHtcclxuICAgICAgICAgICAgbWF4QXhpc0xhYmVsRGltID0gTWF0aC5tYXgoIGF4aXMuZ2V0Q29udGVudERpbWVuc2lvbigpIHx8IDAsIG1heEF4aXNMYWJlbERpbSApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBtYXhBeGlzTGFiZWxEaW07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY29udGVudCBkaW1lbnNpb24gb2YgdGhlIGF4aXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQXhpc1xyXG4gICAgICovXHJcbiAgICBBeGlzLnByb3RvdHlwZS51cGRhdGVEaW1lbnNpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgZGltID0gdGhpcy5pc1hBeGlzID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xyXG4gICAgICAgIHRoaXMuJGNvbnRlbnRbIGRpbSBdKCB0aGlzLmdldE1heENvbnRlbnREaW1lbnNpb24oIHRoaXMubWFwICkgKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIG11dGFibGUgc3BlYyBhdHRyaWJ1dGVzIGhhdmUgY2hhbmdlZCwgaWYgc28sIHJlZHJhd3MgdGhlIGF4aXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQXhpc1xyXG4gICAgICovXHJcbiAgICBBeGlzLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIHRoaXMudGl0bGUgKSB7XHJcbiAgICAgICAgICAgIC8vIGFsd2F5cyB1cGRhdGUgdGl0bGUgcG9zaXRpb24gKGluIGNhc2Ugb2Ygd2luZG93IHJlc2l6ZSlcclxuICAgICAgICAgICAgdXBkYXRlQXhpc1RpdGxlKCB0aGlzICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGV4aXQgZWFybHkgaWYgbm8gbWFya2VycyBhcmUgdmlzaWJsZVxyXG4gICAgICAgIGlmICggIXRoaXMuaXNFbmFibGVkKCkgKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbWVhc3VyZSBsYWJlbCBkaW1lbnNpb25zXHJcbiAgICAgICAgbWVhc3VyZUxhYmVsRGltZW5zaW9ucyggdGhpcyApO1xyXG4gICAgICAgIC8vIGFkZCBlYWNoIG1hcmtlciB0byBjb3JyZWN0IHBpeGVsIGxvY2F0aW9uIGluIGF4aXMgRE9NIGVsZW1lbnRzXHJcbiAgICAgICAgdXBkYXRlQXhpc0NvbnRlbnQoIHRoaXMgKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JtYXQgYSB2YWx1ZSBieSB0aGUgYXhpcyB1bml0IHNwZWNpZmljYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZvcm1hdC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmVyYm9zZSAtIFdoZXRoZXIgdGhlIGZvcm1hdHRpbmcgc2hvdWxkIGJlIHZlcmJvc2UuIChvcHRpb25hbClcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIGZvcm1hdHRlZCB2YWx1ZSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIEF4aXMucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCB2YWx1ZSwgdmVyYm9zZSApIHtcclxuICAgICAgICByZXR1cm4gQXhpc1V0aWwuZm9ybWF0VGV4dCggdGhpcywgdmFsdWUsIHRoaXMudW5pdHMsIHZlcmJvc2UgKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwdWJsaXNoL3N1YnNjcmliZSBjaGFubmVsIGlkIG9mIHRoaXMgc3BlY2lmaWMgYXhpcy5cclxuICAgICAqIEBtZW1iZXJvZiBBeGlzXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHB1Ymxpc2gvc3Vic2NyaWJlIGNoYW5uZWwgZm9yIHRoZSBheGlzLlxyXG4gICAgICovXHJcbiAgICAgQXhpcy5wcm90b3R5cGUuZ2V0Q2hhbm5lbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ2F4aXMuJyArIHRoaXMucG9zaXRpb24gKyAnLicgKyB0aGlzLnV1aWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQXhpcztcclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xyXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cclxuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4vKipcclxuICogQSB1dGlsaXR5IG5hbWVzcGFjZSBjb250YWluaW5nIGF4aXMgcmVsYXRlZCBmdW5jdGlvbmFsaXR5LlxyXG4gKi9cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvVXRpbCcpLFxyXG4gICAgICAgIE1hcFV0aWwgPSByZXF1aXJlKCcuL01hcFV0aWwnKSxcclxuICAgICAgICBNQVJLRVJfVFlQRV9PUkRFUiA9IFsnbGFyZ2UnLCAnc21hbGwnLCAnbWVkaXVtJywgJ3NtYWxsJ107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcml2YXRlOiBHaXZlbiBhIHZhbHVlIHRoYXQgaXMgb3V0c2lkZSBvZiB0aGUgbWluIGFuZCBtYXggb2YgYXhpcyxcclxuICAgICAqIGVuc3VyZSB0aGUgdmFsdWVzIHJvbGxvdmVyIHByb3Blcmx5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF4aXMgIHtBeGlzfSAgIHRoZSBheGlzIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSB7bnVtYmVyfSBvcmlnaW5hbCB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0TWFya2VyUm9sbG92ZXIoIGF4aXMsIHZhbHVlICkge1xyXG4gICAgICAgIHZhciByb2xsb3ZlcjtcclxuICAgICAgICBpZiAoIGF4aXMucmVwZWF0ICkge1xyXG4gICAgICAgICAgICAvLyBpZiByZXBlYXQgZW5hYmxlZCBlbnN1cmUgbGFiZWwgdmFsdWUgd3JhcHMgcGFzdCBtaW4vbWF4IHByb3Blcmx5XHJcbiAgICAgICAgICAgIGlmICggdmFsdWUgPiBheGlzLm1heCApIHtcclxuICAgICAgICAgICAgICAgIHJvbGxvdmVyID0gdmFsdWUgLSBheGlzLm1heCArIGF4aXMubWluO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCB2YWx1ZSA8IGF4aXMubWluICkge1xyXG4gICAgICAgICAgICAgICAgcm9sbG92ZXIgPSB2YWx1ZSArIGF4aXMubWF4IC0gYXhpcy5taW47XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb2xsb3ZlciA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm9uLXJlcGVhdCBsYWJlbCBpcyBhbHdheXMgdmFsdWUgYXMgdGhlcmUgaXMgbm8gd3JhcCBhcm91bmRcclxuICAgICAgICAgICAgcm9sbG92ZXIgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJvbGxvdmVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZTogUmV0dXJucyB0aGUgcGl4ZWwgcG9zaXRpb24gZm9yIHRoZSB2YWx1ZSBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXhpcyAge0F4aXN9ICAgYXhpcyBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUge251bWJlcn0gdGhlIGNvb3JkaW5hdGUgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyB7aW50fSBwaXhlbCBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRQaXhlbFBvc2l0aW9uKCBheGlzLCB2YWx1ZSApIHtcclxuICAgICAgICAvLyBnaXZlbiBhbiBheGlzIHZhbHVlLCBnZXQgdGhlIHBpeGVsIHBvc2l0aW9uIG9uIHRoZSBwYWdlXHJcbiAgICAgICAgaWYgKCBheGlzLmlzWEF4aXMgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXBVdGlsLmdldFZpZXdwb3J0UGl4ZWxGcm9tQ29vcmQoIGF4aXMubWFwLCB2YWx1ZSwgMCApLng7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBNYXBVdGlsLmdldFZpZXdwb3J0UGl4ZWxGcm9tQ29vcmQoIGF4aXMubWFwLCAwLCB2YWx1ZSApLnk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcml2YXRlOiBGaWxscyBhbiBhcnJheSBvZiBtYXJrZXJzIGJ5IHN1YiBpbmNyZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBheGlzICAgICAge0F4aXN9ICAgYXhpcyBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gc3RhcnQgICAgIHtudW1iZXJ9IHN0YXJ0IGluY3JlbWVudC5cclxuICAgICAqIEBwYXJhbSBlbmQgICAgICAge251bWJlcn0gZW5kIGluY3JlbWVudFxyXG4gICAgICogQHBhcmFtIGludGVydmFscyB7T2JqZWN0fSBpbnRlcnZhbHMgc3BlY2lmaWNhdGlvbiBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyB7e2xhcmdlOiBBcnJheSwgbWVkaXVtOiBBcnJheSwgc21hbGw6IEFycmF5fX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZmlsbEFycmF5QnlJbmNyZW1lbnQoIGF4aXMsIHN0YXJ0LCBlbmQsIGludGVydmFscyApIHtcclxuICAgICAgICB2YXIgRVBTSUxPTiA9ICggZW5kIC0gc3RhcnQgKSAqIDAuMDAwMDAxLFxyXG4gICAgICAgICAgICBzdWJJbmNyZW1lbnQgPSBpbnRlcnZhbHMuc3ViSW5jcmVtZW50LFxyXG4gICAgICAgICAgICBzdGFydGluZ01hcmtlclR5cGVJbmRleCA9IGludGVydmFscy5zdGFydGluZ01hcmtlclR5cGVJbmRleCxcclxuICAgICAgICAgICAgbWFya2VycyA9IHtcclxuICAgICAgICAgICAgICAgIGxhcmdlOiBbXSxcclxuICAgICAgICAgICAgICAgIG1lZGl1bTogW10sXHJcbiAgICAgICAgICAgICAgICBzbWFsbDogW11cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaSA9IFV0aWwubW9kKCBzdGFydGluZ01hcmtlclR5cGVJbmRleCwgTUFSS0VSX1RZUEVfT1JERVIubGVuZ3RoICksXHJcbiAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICBtYXJrZXI7XHJcbiAgICAgICAgLy8gcmVkdWNlIHN1YiBpbmNyZW1lbnQgYnkgZXBzaWxvbiB0byBwcmV2ZW50IHByZWNpc2lvbiBlcnJvcnMgY3VsbGluZyBtYXggcG9pbnRcclxuICAgICAgICBpZiAoIGF4aXMudW5pdHMudHlwZSAhPT0gJ3RpbWUnICYmXHJcbiAgICAgICAgICAgIGF4aXMudW5pdHMudHlwZSAhPT0gJ2RhdGUnICYmXHJcbiAgICAgICAgICAgIGF4aXMudW5pdHMudHlwZSAhPT0gJ2knICYmXHJcbiAgICAgICAgICAgIGF4aXMudW5pdHMudHlwZSAhPT0gJ2ludCcgJiZcclxuICAgICAgICAgICAgYXhpcy51bml0cy50eXBlICE9PSAnaW50ZWdlcicgKSB7XHJcbiAgICAgICAgICAgIHN1YkluY3JlbWVudCAtPSBFUFNJTE9OO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKCB2YWx1ZT1zdGFydDsgdmFsdWU8PWVuZDsgdmFsdWUrPXN1YkluY3JlbWVudCApIHtcclxuICAgICAgICAgICAgbWFya2VyID0ge1xyXG4gICAgICAgICAgICAgICAgcGl4ZWw6IGdldFBpeGVsUG9zaXRpb24oIGF4aXMsIHZhbHVlIClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKCBNQVJLRVJfVFlQRV9PUkRFUltpXSA9PT0gXCJsYXJnZVwiICkge1xyXG4gICAgICAgICAgICAgICAgbWFya2VyLmxhYmVsID0gZ2V0TWFya2VyUm9sbG92ZXIoIGF4aXMsIHZhbHVlICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWFya2Vyc1sgTUFSS0VSX1RZUEVfT1JERVJbaV0gXS5wdXNoKCBtYXJrZXIgKTtcclxuICAgICAgICAgICAgaSA9IChpICsgMSkgJSBNQVJLRVJfVFlQRV9PUkRFUi5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZTogUmV0dXJucyB0aGUgbWluaW11bSB2aXNpYmxlIGluY3JlbWVudCBvbiB0aGUgYXhpcy4gQWxzbyBzZXRzIHRoZVxyXG4gICAgICogJ3N0YXJ0aW5nTWFya2VyVHlwZUluZGV4JyBhdHRyaWJ1dGUgb24gdGhlIGludGVydmFscyBvYmplY3QgdG8gZGlzdGluZ3Vpc2hcclxuICAgICAqIHdoaWNoIHR5cGUgb2YgbWFya2VyIHRvIHN0YXJ0IG9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBheGlzICAgICAge0F4aXN9ICAgYXhpcyBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWxzIHtPYmplY3R9IGludGVydmFscyBzcGVjaWZpY2F0aW9uIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG1pbmltdW0gaW5jcmVtZW50LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRNaW5JbmNyZW1lbnQoIGF4aXMsIGludGVydmFscyApIHtcclxuICAgICAgICB2YXIgbWluQ3VsbCwgLy8gZXhhY3QgdmFsdWUgb2YgY3VsbCBwb2ludCwgYW55IHZhbHVlIGxlc3Mgd2lsbCBiZSBjdWxsZWQgZnJvbSB2aWV3XHJcbiAgICAgICAgICAgIGluY3JlbWVudENvdW50OyAvLyBudW1iZXIgb2Ygc3ViIGluY3JlbWVudHMgZnJvbSB0aGUgcGl2b3RcclxuICAgICAgICBpZiAoIGF4aXMuaXNYQXhpcyApIHtcclxuICAgICAgICAgICAgbWluQ3VsbCA9IE1hcFV0aWwuZ2V0Q29vcmRGcm9tVmlld3BvcnRQaXhlbCggYXhpcy5tYXAsIDAsIDAgKS54O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1pbkN1bGwgPSBNYXBVdGlsLmdldENvb3JkRnJvbVZpZXdwb3J0UGl4ZWwoIGF4aXMubWFwLCAwLCBheGlzLm1hcC5nZXRWaWV3cG9ydEhlaWdodCgpICkueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCAhYXhpcy5yZXBlYXQgJiYgbWluQ3VsbCA8IGF4aXMubWluICkge1xyXG4gICAgICAgICAgICAvLyBwcmV2ZW50IHJvbGwtb3ZlclxyXG4gICAgICAgICAgICBtaW5DdWxsID0gYXhpcy5taW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRldGVybWluZSBob3cgbWFueSBzdWIgaW5jcmVtZW50cyBmcm9tIHRoZSBwaXZvdCB0byB0aGUgbWluaW11bSBjdWxsaW5nIHBvaW50XHJcbiAgICAgICAgaW5jcmVtZW50Q291bnQgPSBNYXRoLmNlaWwoICggbWluQ3VsbCAtIGludGVydmFscy5waXZvdCApIC8gaW50ZXJ2YWxzLnN1YkluY3JlbWVudCwgbWluQ3VsbCApO1xyXG4gICAgICAgIGludGVydmFscy5zdGFydGluZ01hcmtlclR5cGVJbmRleCA9IGluY3JlbWVudENvdW50O1xyXG4gICAgICAgIC8vIHJldHVybiB0aGUgbWluaW11bSBpbmNyZW1lbnQgdGhhdCBpcyBzdGlsbCBpbiB2aWV3XHJcbiAgICAgICAgcmV0dXJuIGludGVydmFscy5waXZvdCArIGludGVydmFscy5zdWJJbmNyZW1lbnQgKiBpbmNyZW1lbnRDb3VudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByaXZhdGU6IFJldHVybnMgdGhlIG1heGltdW0gdmlzaWJsZSBpbmNyZW1lbnQgb24gdGhlIGF4aXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF4aXMgICAgICB7QXhpc30gICBheGlzIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBpbnRlcnZhbHMge09iamVjdH0gaW50ZXJ2YWxzIHNwZWNpZmljYXRpb24gb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gbWF4aW11bSBpbmNyZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldE1heEluY3JlbWVudCggYXhpcywgaW50ZXJ2YWxzICkge1xyXG4gICAgICAgIHZhciBtYXhDdWxsLCAvLyBleGFjdCB2YWx1ZSBvZiBjdWxsIHBvaW50LCBhbnkgdmFsdWUgZ3JlYXRlciB3aWxsIGJlIGN1bGxlZCBmcm9tIHZpZXdcclxuICAgICAgICAgICAgaW5jcmVtZW50Q291bnQ7IC8vIG51bWJlciBvZiBzdWIgaW5jcmVtZW50cyBmcm9tIHRoZSBwaXZvdFxyXG4gICAgICAgIGlmICggYXhpcy5pc1hBeGlzICkge1xyXG4gICAgICAgICAgICBtYXhDdWxsID0gTWFwVXRpbC5nZXRDb29yZEZyb21WaWV3cG9ydFBpeGVsKCBheGlzLm1hcCwgYXhpcy5tYXAuZ2V0Vmlld3BvcnRXaWR0aCgpLCAwICkueDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtYXhDdWxsID0gTWFwVXRpbC5nZXRDb29yZEZyb21WaWV3cG9ydFBpeGVsKCBheGlzLm1hcCwgMCwgMCApLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggIWF4aXMucmVwZWF0ICYmIG1heEN1bGwgPiBheGlzLm1heCApIHtcclxuICAgICAgICAgICAgLy8gcHJldmVudCByb2xsLW92ZXJcclxuICAgICAgICAgICAgbWF4Q3VsbCA9IGF4aXMubWF4O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgc3ViIGluY3JlbWVudHMgZnJvbSB0aGUgcGl2b3QgdG8gdGhlIG1heGltdW0gY3VsbGluZyBwb2ludFxyXG4gICAgICAgIGluY3JlbWVudENvdW50ID0gTWF0aC5mbG9vciggKCBtYXhDdWxsIC0gaW50ZXJ2YWxzLnBpdm90ICkgLyBpbnRlcnZhbHMuc3ViSW5jcmVtZW50LCBtYXhDdWxsICk7XHJcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBtYXhpbXVtIGluY3JlbWVudCB0aGF0IGlzIHN0aWxsIGluIHZpZXdcclxuICAgICAgICByZXR1cm4gaW50ZXJ2YWxzLnBpdm90ICsgaW50ZXJ2YWxzLnN1YkluY3JlbWVudCAqIGluY3JlbWVudENvdW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZTogUm91bmRzIGEgdmFsdWUgdG8gYW4gaW50ZWdlciByZXByZXNlbnRhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUge251bWJlcn0gdGhlIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMge2ludH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0SW50ZWdlciggdmFsdWUgKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcml2YXRlOiBGb3JtYXRzIGEgbnVtYmVyIGluIHNjaWVudGlmaWMgbm90YXRpb24gcm91bmRpbmcgdG8gbmVhcmVzdCBkZWNpbWFscy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgICAge251bWJlcn0gdGhlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIGRlY2ltYWxzIHtpbnR9ICAgIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKiBAcGFyYW0gYWxsb3dTdGVwRG93biB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gc3RlcCBkb3duIHVuaXRzIGlmIDwgMVxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0U2NpZW50aWZpY05vdGF0aW9uKCB2YWx1ZSwgZGVjaW1hbHMgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvRXhwb25lbnRpYWwoZGVjaW1hbHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZTogUm91bmRzIGEgdmFsdWUgdG8gYW4gZmxvYXRpbmcgcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aCBzcGVjaWZpYyBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgICAge251bWJlcn0gdGhlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIGRlY2ltYWxzIHtpbnR9ICAgIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmb3JtYXROdW1iZXIoIHZhbHVlLCBkZWNpbWFscywgYWxsb3dTdGVwRG93biApIHtcclxuICAgICAgICB2YXIgdHJ1bmNWYWx1ZSA9IE1hdGgucG93KCAxMCwgLWRlY2ltYWxzICk7XHJcbiAgICAgICAgaWYgKGFsbG93U3RlcERvd24gJiYgdmFsdWUgPCB0cnVuY1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRTY2llbnRpZmljTm90YXRpb24oIHZhbHVlLCBkZWNpbWFscyApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVXRpbC5yb3VuZFRvRGVjaW1hbHMoIHZhbHVlLCBkZWNpbWFscyApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZTogUm91bmRzIGEgdmFsdWUgdG8gYW4gZmxvYXRpbmcgcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhvdXNhbmRzIHdpdGggYSAnSycgYXBwZW5kZWRcclxuICAgICAqIG9udG8gdGhlIGVuZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgICAgICAgICB7bnVtYmVyfSAgdGhlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIGRlY2ltYWxzICAgICAge2ludH0gICAgIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKiBAcGFyYW0gYWxsb3dTdGVwRG93biB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gc3RlcCBkb3duIHVuaXRzIGlmIDwgMVxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0VGhvdXNhbmQoIHZhbHVlLCBkZWNpbWFscywgYWxsb3dTdGVwRG93biApIHtcclxuICAgICAgICB2YXIgdHJ1bmNWYWx1ZSA9IHZhbHVlIC8gMWUzO1xyXG4gICAgICAgIGlmICggYWxsb3dTdGVwRG93biAmJiBNYXRoLmFicyggdHJ1bmNWYWx1ZSApIDwgMSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlciggdmFsdWUsIGRlY2ltYWxzLCB0cnVlICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBVdGlsLnJvdW5kVG9EZWNpbWFscyggdHJ1bmNWYWx1ZSwgZGVjaW1hbHMgKSArICdLJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByaXZhdGU6IFJvdW5kcyBhIHZhbHVlIHRvIGFuIGZsb2F0aW5nIHBvaW50IHJlcHJlc2VudGF0aW9uIG9mIG1pbGxpb25zIHdpdGggYW4gJ00nIGFwcGVuZGVkXHJcbiAgICAgKiBvbnRvIHRoZSBlbmQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlICAgICAgICAge251bWJlcn0gIHRoZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSBkZWNpbWFscyAgICAgIHtpbnR9ICAgICB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICogQHBhcmFtIGFsbG93U3RlcERvd24ge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRvIHN0ZXAgZG93biB1bml0cyBpZiA8IDFcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvcm1hdE1pbGxpb24oIHZhbHVlLCBkZWNpbWFscywgYWxsb3dTdGVwRG93biApIHtcclxuICAgICAgICB2YXIgdHJ1bmNWYWx1ZSA9IHZhbHVlIC8gMWU2O1xyXG4gICAgICAgIGlmICggYWxsb3dTdGVwRG93biAmJiBNYXRoLmFicyggdHJ1bmNWYWx1ZSApIDwgMSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFRob3VzYW5kKCB2YWx1ZSwgZGVjaW1hbHMsIHRydWUgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFV0aWwucm91bmRUb0RlY2ltYWxzKCB0cnVuY1ZhbHVlLCBkZWNpbWFscyApICsgJ00nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZTogUm91bmRzIGEgdmFsdWUgdG8gYW4gZmxvYXRpbmcgcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgYmlsbGlvbnMgd2l0aCBhICdCJyBhcHBlbmRlZFxyXG4gICAgICogb250byB0aGUgZW5kLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAgICAgICAgIHtudW1iZXJ9ICB0aGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gZGVjaW1hbHMgICAgICB7aW50fSAgICAgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAqIEBwYXJhbSBhbGxvd1N0ZXBEb3duIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byBzdGVwIGRvd24gdW5pdHMgaWYgPCAxXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmb3JtYXRCaWxsaW9uKCB2YWx1ZSwgZGVjaW1hbHMsIGFsbG93U3RlcERvd24gKSB7XHJcbiAgICAgICAgdmFyIHRydW5jVmFsdWUgPSB2YWx1ZSAvIDFlOTtcclxuICAgICAgICBpZiAoIGFsbG93U3RlcERvd24gJiYgTWF0aC5hYnMoIHRydW5jVmFsdWUgKSA8IDEgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRNaWxsaW9uKCB2YWx1ZSwgZGVjaW1hbHMsIHRydWUgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFV0aWwucm91bmRUb0RlY2ltYWxzKCB0cnVuY1ZhbHVlLCBkZWNpbWFscyApICsgJ0InO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZTogRm9ybWF0cyBhIHRpbWVzdGFtcCBpbnRvIGEgZGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUge2ludH0gdW5peCB0aW1lc3RhbXAuXHJcbiAgICAgKiBAcGFyYW0gdmVyYm9zZSB7Ym9vbGVhbn0gZm9ybWF0IHRvIGEgbG9uZ2VyIG1vcmUgaHVtYW4gcmVhZGFibGUgZGF0ZVxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0VGltZSggYXhpcywgdmFsdWUsIHZlcmJvc2UgKSB7XHJcbiAgICAgICAgdmFyIHRpbWUgPSBtb21lbnQudXRjKCB2YWx1ZSApO1xyXG4gICAgICAgIGlmICggdmVyYm9zZSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRpbWUuZm9ybWF0KCBcIk1NTSBELCBoOm1tOnNzYVwiICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbiggKCBheGlzLm1heCAtIGF4aXMubWluICkgLyBNYXRoLnBvdyggMiwgYXhpcy5tYXAuZ2V0Wm9vbSgpICkgKTtcclxuICAgICAgICBpZiAoIGR1cmF0aW9uLmFzTW9udGhzKCkgPiAxNiApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRpbWUuZm9ybWF0KCBcIllZWVlcIiApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIGR1cmF0aW9uLmFzTW9udGhzKCkgPiAyICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGltZS5mb3JtYXQoIFwiTU1NIFlZWVlcIiApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGltZS5mb3JtYXQoIFwiTU1NIEQsIFlZWVlcIiApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZTogRm9ybWF0cyBhIGZsb2F0aW5nIHBvaW50IG51bWJlciBhbmQgYXBwZW5kcyBhICdkZWdyZWVzJyBzeW1ib2wuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlICAgIHtmbG9hdH0gZGVncmVlcyB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSBkZWNpbWFscyB7aW50fSAgIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmb3JtYXREZWdyZWVzKCB2YWx1ZSwgZGVjaW1hbHMgKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlciggdmFsdWUsIGRlY2ltYWxzICkgKyBcIlxcdTAwYjBcIjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByaXZhdGU6IFJldHVybnMgYSBzdWIgaW5jcmVtZW50IGZvciB0aGUgYXhpcy4gVGhpcyBpcyBzY2FsZWQgYmFzZSBvbiBhXHJcbiAgICAgKiB0aGUgJ21pblBpeGVsV2lkdGgnIGludGVydmFsIHByb3BlcnR5LlxyXG4gICAgICogQHBhcmFtIGF4aXMgICAgICB7QXhpc30gICBheGlzIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBpbmNyZW1lbnQge251bWJlcn0gaW5jcmVtZW50IGZvciB0aGUgYXhpcy5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHN1YiBpbmNyZW1lbnQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFN1YkluY3JlbWVudCggYXhpcywgaW5jcmVtZW50ICkge1xyXG4gICAgICAgIHZhciBwb3dlck9mVHdvID0gMSxcclxuICAgICAgICAgICAgc3ViSW5jcmVtZW50ID0gaW5jcmVtZW50IC8gTUFSS0VSX1RZUEVfT1JERVIubGVuZ3RoO1xyXG4gICAgICAgIGlmICggYXhpcy5pbnRlcnZhbHMubWluUGl4ZWxXaWR0aCApIHtcclxuICAgICAgICAgICAgLy8gZW5zdXJlIGluY3JlbWVudCBpcyBvZiBtaW5pbXVtIHdpZHRoXHJcbiAgICAgICAgICAgIHdoaWxlICggTWF0aC5hYnMoIGdldFBpeGVsUG9zaXRpb24oIGF4aXMsIGluY3JlbWVudCpwb3dlck9mVHdvICkgLVxyXG4gICAgICAgICAgICAgICAgZ2V0UGl4ZWxQb3NpdGlvbiggYXhpcywgMCApICkgPCBheGlzLmludGVydmFscy5taW5QaXhlbFdpZHRoICkge1xyXG4gICAgICAgICAgICAgICAgcG93ZXJPZlR3byAqPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdWJJbmNyZW1lbnQgKiBwb3dlck9mVHdvO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZTogQWRkcyBhIHRpbWUgYmFzZWQgbWFya2VyIHRvIHRoZSBtYXJrZXJzIGFycmF5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXhpc30gYXhpcyAtIFRoZSBheGlzIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIFRoZSBmaXJzdCB2aXNpYmxlIHZhbHVlIG9uIHRoZSBheGlzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCAtIFRoZSBsYXN0IHZpc2libGUgdmFsdWUgb24gdGhlIGF4aXMuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXJrZXJzIC0gVGhlIG1hcmtlcnMgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gVGhlIHRpbWVzdGFtcCB2YWx1ZSB0byBhZGQuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFkZExhYmVsIC0gV2hldGhlciBvciBub3QgdG8gYWRkIGEgbGFiZWwgdG8gdGhlIG1hcmtlci5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRkVGltZU1hcmtlciggYXhpcywgc3RhcnQsIGVuZCwgbWFya2VycywgdGltZXN0YW1wLCBhZGRMYWJlbCApIHtcclxuICAgICAgICBpZiAoIHRpbWVzdGFtcCA+PSBzdGFydCAmJiB0aW1lc3RhbXAgPD0gZW5kICkge1xyXG4gICAgICAgICAgICB2YXIgbWFya2VyID0ge1xyXG4gICAgICAgICAgICAgICAgcGl4ZWw6IGdldFBpeGVsUG9zaXRpb24oIGF4aXMsIHRpbWVzdGFtcCApXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICggYWRkTGFiZWwgKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIubGFiZWwgPSB0aW1lc3RhbXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWFya2Vycy5wdXNoKCBtYXJrZXIgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcml2YXRlOiBTcGxpdHMgdGhlIHRpbWUgdW5pdCBpbnRvIG5vbiBmbG9hdGluZyBwb2ludCB1bml0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IHR5cGUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBUaGUgbnVtYmVyIG9mIHVuaXRzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzcGxpdFRpbWVVbml0KCB1bml0LCBjb3VudCApIHtcclxuICAgICAgICAvLyBpZiB1bml0IGlzIGFscmVhZHkgYSBub24gZmxvYXRpbmcgcG9pbnQgY291bnQsIHJldHVybiBlYXJseVxyXG4gICAgICAgIGlmICggY291bnQgJSAxID09PSAwICkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdW5pdDogdW5pdCxcclxuICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzcGxpdCB1bml0IHRvIG5leHQgc3VidW5pdFxyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICBzd2l0Y2ggKCB1bml0ICkge1xyXG4gICAgICAgICAgICBjYXNlIFwieWVhclwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaXQ6IFwibW9udGhcIixcclxuICAgICAgICAgICAgICAgICAgICBjb3VudDogY291bnQgKiAxMlxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibW9udGhcIjpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB1bml0OiBcIndlZWtcIixcclxuICAgICAgICAgICAgICAgICAgICBjb3VudDogY291bnQgKiA0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ3ZWVrXCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pdDogXCJkYXlcIixcclxuICAgICAgICAgICAgICAgICAgICBjb3VudDogY291bnQgKiA3XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkYXlcIjpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB1bml0OiBcImhvdXJcIixcclxuICAgICAgICAgICAgICAgICAgICBjb3VudDogY291bnQgKiAyNFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbm5vdCBzcGxpdCB0aW1lIHVuaXRzIGV2ZW5seVwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB1bml0IHN0aWxsIGlzbid0IHNwbGl0IGV2ZW5seSwgcmVjdXJzZSBmdXJ0aGVyXHJcbiAgICAgICAgaWYgKCByZXN1bHQuY291bnQgJSAxICE9PSAwICkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3BsaXRUaW1lVW5pdCggcmVzdWx0LnVuaXQsIHJlc3VsdC5jb3VudCApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZTogQWRkcyB0aW1lIGJhc2VkIG1hcmtlcnMgYmFzZWQgb24gc29tZSBhbGlnbm1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBeGlzfSBheGlzIC0gVGhlIGF4aXMgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWFya2VycyAtIFRoZSBtYXJrZXJzIGFycmF5LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gVGhlIGZpcnN0IHZpc2libGUgdmFsdWUgb24gdGhlIGF4aXMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIC0gVGhlIGxhc3QgdmlzaWJsZSB2YWx1ZSBvbiB0aGUgYXhpcy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlnbkJ5IC0gVGhlIHVuaXQgdG8gYWxpZ24gdGhlIG1hcmtlcnMgYnkuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IGJ5IHdoaWNoIHRvIHN0ZXAgYnkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnRQZXJMYWJlbCAtIFRoZSBudW1iZXIgb2YgdW5pdHMgcGVyIGxhYmVsLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhZGRUaW1lQWxpZ25lZE1hcmtlcnMoIGF4aXMsIG1hcmtlcnMsIHN0YXJ0LCBlbmQsIGFsaWduQnksIHVuaXQsIGNvdW50UGVyTGFiZWwgKSB7XHJcbiAgICAgICAgdmFyIGFsaWduZWRTdGFydCA9IG1vbWVudC51dGMoIHN0YXJ0ICkuc3RhcnRPZiggYWxpZ25CeSApLnZhbHVlT2YoKSxcclxuICAgICAgICAgICAgZHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24oIGVuZCAtIGFsaWduZWRTdGFydCApLFxyXG4gICAgICAgICAgICBudW1Vbml0cyA9IGR1cmF0aW9uLmFzKCB1bml0ICsgXCJzXCIgKSxcclxuICAgICAgICAgICAgc3RlcCA9IGNvdW50UGVyTGFiZWwgPj0gMSA/IGNvdW50UGVyTGFiZWwgOiAxLFxyXG4gICAgICAgICAgICBzdWJVbml0LFxyXG4gICAgICAgICAgICBhbGlnbmVkLFxyXG4gICAgICAgICAgICBsYXJnZSxcclxuICAgICAgICAgICAgbWVkaXVtLFxyXG4gICAgICAgICAgICBzbWFsbCxcclxuICAgICAgICAgICAgaSwgajtcclxuICAgICAgICBmb3IgKCBpPTA7IGk8bnVtVW5pdHM7IGkrPXN0ZXAgKSB7XHJcbiAgICAgICAgICAgIC8vIGdldCB0aW1lc3RhbXAgb2YgYWxpZ25lZCB1bml0XHJcbiAgICAgICAgICAgIGFsaWduZWQgPSBtb21lbnQudXRjKCBhbGlnbmVkU3RhcnQgKS5hZGQoIGksIHVuaXQgKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIC8vIGRldGVybWluZSBudW1iZXIgb2Ygc3ViIGRpdmlzaW9uc1xyXG4gICAgICAgICAgICB2YXIgbnVtU3ViRGl2aXNpb25zID0gMS9jb3VudFBlckxhYmVsO1xyXG4gICAgICAgICAgICBmb3IgKCBqPTA7IGo8bnVtU3ViRGl2aXNpb25zOyBqKysgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ViRGl2aWRlZCA9IHNwbGl0VGltZVVuaXQoIHVuaXQsIGNvdW50UGVyTGFiZWwgKTtcclxuICAgICAgICAgICAgICAgIGxhcmdlID0gbW9tZW50LnV0YyggYWxpZ25lZCApLmFkZCggaipzdWJEaXZpZGVkLmNvdW50LCBzdWJEaXZpZGVkLnVuaXQgKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgbGFyZ2UgbWFya2VyXHJcbiAgICAgICAgICAgICAgICBhZGRUaW1lTWFya2VyKCBheGlzLCBzdGFydCwgZW5kLCBtYXJrZXJzLmxhcmdlLCBsYXJnZSwgdHJ1ZSApO1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkIG1lZGl1bSBtYXJrZXJcclxuICAgICAgICAgICAgICAgIHN1YlVuaXQgPSBzcGxpdFRpbWVVbml0KCBzdWJEaXZpZGVkLnVuaXQsIHN1YkRpdmlkZWQuY291bnQgLyAyICk7XHJcbiAgICAgICAgICAgICAgICBtZWRpdW0gPSBtb21lbnQudXRjKCBsYXJnZSApLmFkZCggc3ViVW5pdC5jb3VudCwgc3ViVW5pdC51bml0ICsgXCJzXCIgKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICBhZGRUaW1lTWFya2VyKCBheGlzLCBzdGFydCwgZW5kLCBtYXJrZXJzLm1lZGl1bSwgbWVkaXVtICk7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgc21hbGwgbWFya2VyXHJcbiAgICAgICAgICAgICAgICBzdWJVbml0ID0gc3BsaXRUaW1lVW5pdCggc3ViRGl2aWRlZC51bml0LCBzdWJEaXZpZGVkLmNvdW50IC8gNCApO1xyXG4gICAgICAgICAgICAgICAgc21hbGwgPSBtb21lbnQudXRjKCBsYXJnZSApLmFkZCggc3ViVW5pdC5jb3VudCwgc3ViVW5pdC51bml0ICsgXCJzXCIgKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICBhZGRUaW1lTWFya2VyKCBheGlzLCBzdGFydCwgZW5kLCBtYXJrZXJzLnNtYWxsLCBzbWFsbCApO1xyXG4gICAgICAgICAgICAgICAgc21hbGwgPSBtb21lbnQudXRjKCBsYXJnZSApLmFkZCggc3ViVW5pdC5jb3VudCAqIDMsIHN1YlVuaXQudW5pdCArIFwic1wiICkudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgYWRkVGltZU1hcmtlciggYXhpcywgc3RhcnQsIGVuZCwgbWFya2Vycy5zbWFsbCwgc21hbGwgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByaXZhdGU6IEZpbGxzIGFuIGFycmF5IG9mIG1hcmtlcnMgYnkgdGltZSBiYXNlZCBzdWIgaW5jcmVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXhpcyAgICAgIHtBeGlzfSAgIGF4aXMgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHN0YXJ0ICAgICB7bnVtYmVyfSBzdGFydCBpbmNyZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gZW5kICAgICAgIHtudW1iZXJ9IGVuZCBpbmNyZW1lbnRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZmlsbEFycmF5QnlUaW1lSW5jcmVtZW50KCBheGlzLCBzdGFydCwgZW5kICkge1xyXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbiggKCBheGlzLm1heCAtIGF4aXMubWluICkgLyBNYXRoLnBvdyggMiwgYXhpcy5tYXAuZ2V0Wm9vbSgpICkgKSxcclxuICAgICAgICAgICAgbWFya2VycyA9IHtcclxuICAgICAgICAgICAgICAgIGxhcmdlOiBbXSxcclxuICAgICAgICAgICAgICAgIG1lZGl1bTogW10sXHJcbiAgICAgICAgICAgICAgICBzbWFsbDogW11cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBpZiAoIGR1cmF0aW9uLmFzTW9udGhzKCkgPiAxNiApIHtcclxuICAgICAgICAgICAgYWRkVGltZUFsaWduZWRNYXJrZXJzKCBheGlzLCBtYXJrZXJzLCBzdGFydCwgZW5kLCBcInllYXJcIiwgXCJ5ZWFyXCIsIDEgKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCBkdXJhdGlvbi5hc01vbnRocygpID4gOCApIHtcclxuICAgICAgICAgICAgYWRkVGltZUFsaWduZWRNYXJrZXJzKCBheGlzLCBtYXJrZXJzLCBzdGFydCwgZW5kLCBcInllYXJcIiwgXCJtb250aFwiLCA0ICk7XHJcbiAgICAgICAgfSBlbHNlIGlmICggZHVyYXRpb24uYXNNb250aHMoKSA+IDQgKSB7XHJcbiAgICAgICAgICAgIGFkZFRpbWVBbGlnbmVkTWFya2VycyggYXhpcywgbWFya2Vycywgc3RhcnQsIGVuZCwgXCJ5ZWFyXCIsIFwibW9udGhcIiwgMiApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIGR1cmF0aW9uLmFzTW9udGhzKCkgPiAyICkge1xyXG4gICAgICAgICAgICBhZGRUaW1lQWxpZ25lZE1hcmtlcnMoIGF4aXMsIG1hcmtlcnMsIHN0YXJ0LCBlbmQsIFwieWVhclwiLCBcIm1vbnRoXCIsIDEgKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCBkdXJhdGlvbi5hc01vbnRocygpID4gMSApIHtcclxuICAgICAgICAgICAgYWRkVGltZUFsaWduZWRNYXJrZXJzKCBheGlzLCBtYXJrZXJzLCBzdGFydCwgZW5kLCBcInllYXJcIiwgXCJtb250aFwiLCAwLjUgKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCBkdXJhdGlvbi5hc1dlZWtzKCkgPiAyICkge1xyXG4gICAgICAgICAgICBhZGRUaW1lQWxpZ25lZE1hcmtlcnMoIGF4aXMsIG1hcmtlcnMsIHN0YXJ0LCBlbmQsIFwieWVhclwiLCBcIm1vbnRoXCIsIDAuMjUgKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCBkdXJhdGlvbi5hc1dlZWtzKCkgPiAxICkge1xyXG4gICAgICAgICAgICBhZGRUaW1lQWxpZ25lZE1hcmtlcnMoIGF4aXMsIG1hcmtlcnMsIHN0YXJ0LCBlbmQsIFwieWVhclwiLCBcImRheVwiLCA0ICk7XHJcbiAgICAgICAgfSBlbHNlIGlmICggZHVyYXRpb24uYXNEYXlzKCkgPiA0ICkge1xyXG4gICAgICAgICAgICBhZGRUaW1lQWxpZ25lZE1hcmtlcnMoIGF4aXMsIG1hcmtlcnMsIHN0YXJ0LCBlbmQsIFwieWVhclwiLCBcImRheVwiLCAyICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYWRkVGltZUFsaWduZWRNYXJrZXJzKCBheGlzLCBtYXJrZXJzLCBzdGFydCwgZW5kLCBcInllYXJcIiwgXCJkYXlcIiwgMSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWFya2VycztcclxuICAgIH1cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRm9ybWF0cyBheGlzIG1hcmtlciBsYWJlbCB0ZXh0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHZhbHVlIHtudW1iZXJ9IHZhbHVlIG9mIHRoZSBsYWJlbFxyXG4gICAgICAgICAqIEBwYXJhbSB1bml0cyB7T2JqZWN0fSB1bml0IHNwZWNpZmljYXRpb24gb2YgdGhlIGF4aXMuXHJcbiAgICAgICAgICogQHBhcmFtIHZlcmJvc2Uge2Jvb2xlYW59IGZvcm1hdCB0byBhIG1vcmUgdmVyYm9zZSBmb3JtYXQsIGlmIGF2YWlsYWJsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmb3JtYXRUZXh0OiBmdW5jdGlvbiggYXhpcywgdmFsdWUsIHVuaXRzLCB2ZXJib3NlICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCAhdW5pdHMgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyKCB2YWx1ZSwgMiApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodW5pdHMuc2NhbGUgPT09IFwibG9nMTBcIikge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnBvdygxMCwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKCB1bml0cy50eXBlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2RlZ3JlZXMnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnZGVncmVlJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2RlZyc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXREZWdyZWVzKCB2YWx1ZSwgdW5pdHMuZGVjaW1hbHMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICd0aW1lJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0VGltZSggYXhpcywgdmFsdWUsIHZlcmJvc2UgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdrJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3Rob3VzYW5kJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3Rob3VzYW5kcyc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRUaG91c2FuZCggdmFsdWUsIHVuaXRzLmRlY2ltYWxzLCB1bml0cy5zdGVwRG93biApO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlvbic6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaW9ucyc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRNaWxsaW9uKCB2YWx1ZSwgdW5pdHMuZGVjaW1hbHMsIHVuaXRzLnN0ZXBEb3duICk7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnYic6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdiaWxsaW9uJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2JpbGxpb25zJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEJpbGxpb24oIHZhbHVlLCB1bml0cy5kZWNpbWFscywgdW5pdHMuc3RlcERvd24gKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdpJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2ludCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdpbnRlZ2VyJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEludGVnZXIoIHZhbHVlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlciggdmFsdWUsIHVuaXRzLmRlY2ltYWxzICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZW5lcmF0ZXMgYSBtYXJrZXIgdmFsdWUgZm9yIHRoZSBnaXZlbiB2aWV3cG9ydCBwaXhlbCBjb29yZHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gYXhpcyB7QXhpc30gdGhlIGF4aXMgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB2eCAgIHtpbnR9ICB4IHZpZXdwb3J0IHBpeGVsIGNvb3JkaW5hdGVcclxuICAgICAgICAgKiBAcGFyYW0gdnkgICB7aW50fSAgeSB2aWV3cG9ydCBwaXhlbCBjb29yZGluYXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0TWFya2VyOiBmdW5jdGlvbiggYXhpcywgdngsIHZ5ICkge1xyXG4gICAgICAgICAgICB2YXIgeE9yWSA9IGF4aXMuaXNYQXhpcyA/ICd4JyA6ICd5JyxcclxuICAgICAgICAgICAgICAgIHBpeGVsID0gKCBheGlzLmlzWEF4aXMgKSA/IHZ4IDogdnksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hcFV0aWwuZ2V0Q29vcmRGcm9tVmlld3BvcnRQaXhlbCggYXhpcy5tYXAsIHZ4LCB2eSApWyB4T3JZIF07XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogZ2V0TWFya2VyUm9sbG92ZXIoYXhpcywgdmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgcGl4ZWw6IHBpeGVsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2VuZXJhdGVzIGFsbCB2aXNpYmxlIG1hcmtlciB2YWx1ZXMsIHJldHVybnMgYXJyYXkgb2Ygb2JqZWN0cywgY29udGFpbmluZ1xyXG4gICAgICAgICAqIGxhYmVscyBhbmQgcGl4ZWwgbG9jYXRpb25zXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gYXhpcyB7QXhpc30gdGhlIGF4aXMgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldE1hcmtlcnM6IGZ1bmN0aW9uKCBheGlzICkge1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWxzID0ge30sXHJcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnQsXHJcbiAgICAgICAgICAgICAgICBtaW5JbmNyZW1lbnQsXHJcbiAgICAgICAgICAgICAgICBtYXhJbmNyZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICAvLyB0aW1lIGJhc2VkIGF4aXMgcGFydGl0aW9ucyBhcmVuJ3QgJ2V2ZW4nLCB0aGV5IHNob3VsZCBjb3JyZXNwb25kIGJhc2VkXHJcbiAgICAgICAgICAgIC8vIG9uIHRoZSBzY2FsZSBhdCB3aGljaCB0aGUgZGF0YSBpcyBjdXJyZW50bHkgYmVpbmcgc2hvd24sIHRoZXJlZm9yZSB0aGVzZVxyXG4gICAgICAgICAgICAvLyBtYXJrZXJzIHdpbGwgYmUgZ2VuZXJhdGVkIGFzIHRoZWlyIG93biBlZGdlIGNhc2VcclxuICAgICAgICAgICAgaWYgKCBheGlzLnVuaXRzLnR5cGUgPT09IFwidGltZVwiICkge1xyXG4gICAgICAgICAgICAgICAgbWluSW5jcmVtZW50ID0gZ2V0TWluSW5jcmVtZW50KCBheGlzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGl2b3Q6IGF4aXMubWluLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YkluY3JlbWVudDogMTAwMCAqIDYwICogNjBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbWF4SW5jcmVtZW50ID0gZ2V0TWF4SW5jcmVtZW50KCBheGlzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGl2b3Q6IGF4aXMubWluLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YkluY3JlbWVudDogMTAwMCAqIDYwICogNjBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGxBcnJheUJ5VGltZUluY3JlbWVudCggYXhpcywgbWluSW5jcmVtZW50LCBtYXhJbmNyZW1lbnQgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3dpdGNoICggYXhpcy5pbnRlcnZhbHMudHlwZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaXhlZFwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIiNcIjpcclxuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgZml4ZWQgaW50ZXJ2YWxcclxuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnQgPSBheGlzLmludGVydmFscy5pbmNyZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHBpdm90IGJ5IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxzLnBpdm90ID0gKCBheGlzLmludGVydmFscy5waXZvdCAhPT0gdW5kZWZpbmVkICkgPyBheGlzLmludGVydmFscy5waXZvdCA6IGF4aXMubWluO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHBlcmNlbnRhZ2VcclxuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnQgPSBheGlzLmludGVydmFscy5pbmNyZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50ID0gKCBpbmNyZW1lbnQgPiAxICkgPyBpbmNyZW1lbnQgKiAwLjAxIDogaW5jcmVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudCA9ICggYXhpcy5tYXggLSBheGlzLm1pbiApICogaW5jcmVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGludGVydmFscy5waXZvdCA9ICggYXhpcy5pbnRlcnZhbHMucGl2b3QgIT09IHVuZGVmaW5lZCApID8gYXhpcy5pbnRlcnZhbHMucGl2b3QgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBwZXJjZW50YWdlcyB0byBbMC0xXSBub3QgWzAtMTAwXVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaW50ZXJ2YWxzLnBpdm90ID4gMSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxzLnBpdm90ID0gaW50ZXJ2YWxzLnBpdm90IC8gMTAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxjIHBpdm90IHZhbHVlIGJ5IHBlcmNlbnRhZ2VcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbHMucGl2b3QgPSBheGlzLm1pbiArICggaW50ZXJ2YWxzLnBpdm90ICogKCBheGlzLm1heCAtIGF4aXMubWluICkgKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gc2NhbGUgaW5jcmVtZW50IGlmIHNwZWNpZmllZFxyXG4gICAgICAgICAgICBpZiAoIGF4aXMuaW50ZXJ2YWxzLnNjYWxlQnlab29tICkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2NhbGUgaW5jcmVtZW50IGJ5IHpvb21cclxuICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IGluY3JlbWVudCAvIE1hdGgucG93KDIsIE1hdGgubWF4KCBheGlzLm1hcC5nZXRab29tKCkgLSAxLCAwKSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2ludGVydmFscy5pbmNyZW1lbnQgPSBpbmNyZW1lbnQ7XHJcbiAgICAgICAgICAgIGludGVydmFscy5zdWJJbmNyZW1lbnQgPSBnZXRTdWJJbmNyZW1lbnQoIGF4aXMsIGluY3JlbWVudCApO1xyXG5cclxuICAgICAgICAgICAgLy8gZ2V0IG1pbmltdW0gYW5kIG1heGltdW0gdmlzaWJsZSBpbmNyZW1lbnRzIG9uIHRoZSBheGlzXHJcbiAgICAgICAgICAgIG1pbkluY3JlbWVudCA9IGdldE1pbkluY3JlbWVudCggYXhpcywgaW50ZXJ2YWxzICk7XHJcbiAgICAgICAgICAgIG1heEluY3JlbWVudCA9IGdldE1heEluY3JlbWVudCggYXhpcywgaW50ZXJ2YWxzICk7XHJcblxyXG4gICAgICAgICAgICAvLyBhZGQgYWxsIHBvaW50cyBiZXR3ZWVuIG1pbmltdW0gdmlzaWJsZSB2YWx1ZSBhbmQgbWF4aW11bSB2aXNpYmxlIHZhbHVlXHJcbiAgICAgICAgICAgIHJldHVybiBmaWxsQXJyYXlCeUluY3JlbWVudCggYXhpcywgbWluSW5jcmVtZW50LCBtYXhJbmNyZW1lbnQsIGludGVydmFscyApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgQXhpcyA9IHJlcXVpcmUoJy4vQXhpcycpLFxyXG4gICAgICAgIFBlbmRpbmdMYXllciA9IHJlcXVpcmUoJy4uL2xheWVyL1BlbmRpbmdMYXllcicpLFxyXG4gICAgICAgIE1hcFV0aWwgPSByZXF1aXJlKCcuL01hcFV0aWwnKSxcclxuICAgICAgICBMYXllciA9IHJlcXVpcmUoJy4uL2xheWVyL0xheWVyJyksXHJcbiAgICAgICAgQ2Fyb3VzZWwgPSByZXF1aXJlKCcuLi9sYXllci9DYXJvdXNlbCcpLFxyXG4gICAgICAgIEJhc2VMYXllciA9IHJlcXVpcmUoJy4uL2xheWVyL0Jhc2VMYXllcicpLFxyXG4gICAgICAgIFB1YlN1YiA9IHJlcXVpcmUoJy4uL3V0aWwvUHViU3ViJyksXHJcbiAgICAgICAgQXJlYU9mSW50ZXJlc3RUaWxlUHlyYW1pZCA9IHJlcXVpcmUoJy4uL2Jpbm5pbmcvQXJlYU9mSW50ZXJlc3RUaWxlUHlyYW1pZCcpLFxyXG4gICAgICAgIFdlYk1lcmNhdG9yVGlsZVB5cmFtaWQgPSByZXF1aXJlKCcuLi9iaW5uaW5nL1dlYk1lcmNhdG9yVGlsZVB5cmFtaWQnKSxcclxuICAgICAgICBUaWxlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9iaW5uaW5nL1RpbGVJdGVyYXRvcicpLFxyXG4gICAgICAgIFRJTEVTSVpFID0gMjU2LFxyXG4gICAgICAgIE1BUktFUl9aX0lOREVYID0gNTAwMCxcclxuICAgICAgICBzZXRNYXBDYWxsYmFja3MsXHJcbiAgICAgICAgYWN0aXZhdGVDb21wb25lbnQsXHJcbiAgICAgICAgZGVhY3RpdmF0ZUNvbXBvbmVudCxcclxuICAgICAgICBhY3RpdmF0ZURlZmVycmVkQ29tcG9uZW50cyxcclxuICAgICAgICBhZGRCYXNlTGF5ZXIsXHJcbiAgICAgICAgYWRkTGF5ZXIsXHJcbiAgICAgICAgYWRkQ2Fyb3VzZWwsXHJcbiAgICAgICAgYWRkQXhpcyxcclxuICAgICAgICByZW1vdmVCYXNlTGF5ZXIsXHJcbiAgICAgICAgcmVtb3ZlTGF5ZXIsXHJcbiAgICAgICAgcmVtb3ZlQ2Fyb3VzZWwsXHJcbiAgICAgICAgcmVtb3ZlQXhpcyxcclxuICAgICAgICByZXNldExheWVyWkluZGljZXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY2FsbGJhY2tzIHRvIHVwZGF0ZSB0aGUgbWFwcyB0aWxlIGZvY3VzLCBpZGVudGlmeWluZyB3aGljaCB0aWxlXHJcbiAgICAgKiB0aGUgdXNlciBpcyBjdXJyZW50bHkgaG92ZXJpbmcgb3Zlci5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCB7TWFwfSBUaGUgbWFwIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgc2V0TWFwQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG1hcCApIHtcclxuICAgICAgICB2YXIgcHJldmlvdXNNb3VzZSA9IHt9O1xyXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRpbGVGb2N1cyggeCwgeSApIHtcclxuICAgICAgICAgICAgdmFyIHRpbGVBbmRCaW4gPSBNYXBVdGlsLmdldFRpbGVBbmRCaW5Gcm9tVmlld3BvcnRQaXhlbCggbWFwLCB4LCB5LCAxLCAxICksXHJcbiAgICAgICAgICAgICAgICB0aWxla2V5ID0gdGlsZUFuZEJpbi50aWxlLmxldmVsICsgXCIsXCJcclxuICAgICAgICAgICAgICAgICAgICArIHRpbGVBbmRCaW4udGlsZS54SW5kZXggKyBcIixcIlxyXG4gICAgICAgICAgICAgICAgICAgICsgdGlsZUFuZEJpbi50aWxlLnlJbmRleDtcclxuICAgICAgICAgICAgaWYgKCB0aWxla2V5ICE9PSBtYXAudGlsZUZvY3VzICkge1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSB1cGRhdGUgdGlsZWZvY3VzIGlmIGl0IGFjdHVhbGx5IGNoYW5nZXNcclxuICAgICAgICAgICAgICAgIG1hcC5wcmV2aW91c1RpbGVGb2N1cyA9IG1hcC50aWxlRm9jdXM7XHJcbiAgICAgICAgICAgICAgICBtYXAudGlsZUZvY3VzID0gdGlsZWtleTtcclxuICAgICAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCAnbGF5ZXInLCB7IGZpZWxkOiAndGlsZUZvY3VzJywgdmFsdWU6IHRpbGVrZXkgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0IHRpbGUgZm9jdXMgY2FsbGJhY2tzXHJcbiAgICAgICAgbWFwLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiggZXZlbnQgKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZVRpbGVGb2N1cyggZXZlbnQueHkueCwgZXZlbnQueHkueSApO1xyXG4gICAgICAgICAgICBwcmV2aW91c01vdXNlLnggPSBldmVudC54eS54O1xyXG4gICAgICAgICAgICBwcmV2aW91c01vdXNlLnkgPSBldmVudC54eS55O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG1hcC5vbignem9vbWVuZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB1cGRhdGVUaWxlRm9jdXMoIHByZXZpb3VzTW91c2UueCwgcHJldmlvdXNNb3VzZS55ICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gaWYgbW91c2Vkb3duIHdoaWxlIG1hcCBpcyBwYW5uaW5nLCBpbnRlcnJ1cHQgcGFuXHJcbiAgICAgICAgbWFwLm9sTWFwLmV2ZW50cy5yZWdpc3RlciggXCJtb3VzZWRvd25cIiwgbWFwLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBpZiAoIG1hcC5vbE1hcC5wYW5Ud2VlbiApIHtcclxuICAgICAgICAgICAgICAgIG1hcC5vbE1hcC5wYW5Ud2Vlbi5jYWxsYmFja3MgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbWFwLm9sTWFwLnBhblR3ZWVuLnN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHRydWUgKTtcclxuICAgICAgICAvLyBjcmVhdGUgcmVzaXplIGNhbGxiYWNrXHJcbiAgICAgICAgbWFwLnJlc2l6ZUNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIG1hcC5vbE1hcC51cGRhdGVTaXplKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBzZXQgcmVzaXplIGNhbGxiYWNrXHJcbiAgICAgICAgJCggd2luZG93ICkub24oICdyZXNpemUnLCBtYXAucmVzaXplQ2FsbGJhY2sgKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZXMgYSBjb21wb25lbnQuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgICAgICAge01hcH0gVGhlIG1hcCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IHsqfSAgIFRoZSBjb21wb25lbnQgdG8gYWN0aXZhdGUuXHJcbiAgICAgKi9cclxuICAgIGFjdGl2YXRlQ29tcG9uZW50ID0gZnVuY3Rpb24oIG1hcCwgY29tcG9uZW50ICkge1xyXG4gICAgICAgIGlmICggY29tcG9uZW50IGluc3RhbmNlb2YgQ2Fyb3VzZWwgKSB7XHJcbiAgICAgICAgICAgIGFkZENhcm91c2VsKCBtYXAsIGNvbXBvbmVudCApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIGNvbXBvbmVudCBpbnN0YW5jZW9mIExheWVyICkge1xyXG4gICAgICAgICAgICBpZiAoIGNvbXBvbmVudC5jYXJvdXNlbCApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgICAgICAgIFwiWW91IGNhbm5vdCBhZGQgYSBsYXllciB0aGF0IGlzIHBhcnQgb2YgYSBjYXJvdXNlbCB0byBhIG1hcCBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpbmRlcGVuZGVudGx5LCByZW1vdmUgaXQgZnJvbSB0aGUgY2Fyb3VzZWwgZmlyc3QuXCIgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhZGRMYXllciggbWFwLCBjb21wb25lbnQgKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCBjb21wb25lbnQgaW5zdGFuY2VvZiBBeGlzICkge1xyXG4gICAgICAgICAgICBhZGRBeGlzKCBtYXAsIGNvbXBvbmVudCApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWFjdGl2YXRlcyBhIGNvbXBvbmVudC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCAgICAgICB7TWFwfSBUaGUgbWFwIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBjb21wb25lbnQgeyp9ICAgVGhlIGNvbXBvbmVudCB0byBkZWFjdGl2YXRlLlxyXG4gICAgICovXHJcbiAgICBkZWFjdGl2YXRlQ29tcG9uZW50ID0gZnVuY3Rpb24oIG1hcCwgY29tcG9uZW50ICkge1xyXG4gICAgICAgIGlmICggY29tcG9uZW50IGluc3RhbmNlb2YgQmFzZUxheWVyICkge1xyXG4gICAgICAgICAgICByZW1vdmVCYXNlTGF5ZXIoIG1hcCwgY29tcG9uZW50ICk7XHJcbiAgICAgICAgfSBlbHNlIGlmICggY29tcG9uZW50IGluc3RhbmNlb2YgQ2Fyb3VzZWwgKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUNhcm91c2VsKCBtYXAsIGNvbXBvbmVudCApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIGNvbXBvbmVudCBpbnN0YW5jZW9mIExheWVyICkge1xyXG4gICAgICAgICAgICByZW1vdmVMYXllciggbWFwLCBjb21wb25lbnQgKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCBjb21wb25lbnQgaW5zdGFuY2VvZiBBeGlzICkge1xyXG4gICAgICAgICAgICByZW1vdmVBeGlzKCBtYXAsIGNvbXBvbmVudCApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZXMgZGVmZXJyZWQgY29tcG9uZW50cyB3aGVuIHRoZSBtYXAgaXMgcmVhZHkuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAge01hcH0gVGhlIG1hcCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGFjdGl2YXRlRGVmZXJyZWRDb21wb25lbnRzID0gZnVuY3Rpb24oIG1hcCApIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKCBpPTA7IGk8bWFwLmRlZmVycmVkcy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgYWN0aXZhdGVDb21wb25lbnQoIG1hcCwgbWFwLmRlZmVycmVkc1tpXSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgbWFwLmRlZmVycmVkcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgYmFzZSBsYXllciB0byB0aGUgbWFwLiBJZiBubyBiYXNlbGF5ZXIgaXMgYXR0YWNoZWQsIGl0XHJcbiAgICAgKiB3aWxsIGFsc28gYWN0aXZhdGUgaXQsIGFsb25nIHdpdGggYW55IGRlZmVycmVkIGNvbXBvbmVudHMgdGhhdCB3ZXJlIGF0dGFjaGVkXHJcbiAgICAgKiBmaXJzdC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCAgICAgICB7TWFwfSAgICAgICBUaGUgbWFwIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBiYXNlbGF5ZXIge0Jhc2VMYXllcn0gVGhlIGJhc2VsYXllciBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGFkZEJhc2VMYXllciA9IGZ1bmN0aW9uKCBtYXAsIGJhc2VsYXllciApIHtcclxuICAgICAgICAvLyBhZGQgbWFwIHRvIGJhc2VsYXllclxyXG4gICAgICAgIGJhc2VsYXllci5tYXAgPSBtYXA7XHJcbiAgICAgICAgLy8gYWRkIHRvIGJhc2VsYXllciBhcnJheVxyXG4gICAgICAgIG1hcC5iYXNlbGF5ZXJzID0gbWFwLmJhc2VsYXllcnMgfHwgW107XHJcbiAgICAgICAgbWFwLmJhc2VsYXllcnMucHVzaCggYmFzZWxheWVyICk7XHJcbiAgICAgICAgLy8gaWYgZmlyc3QgYmFzZWxheWVyLCBhY3RpdmF0ZSB0aGUgbWFwXHJcbiAgICAgICAgaWYgKCBtYXAuYmFzZUxheWVySW5kZXggPCAwICkge1xyXG4gICAgICAgICAgICAvLyBvcGVubGF5ZXJzIG1hcHMgcmVxdWlyZSBhIGJhc2VsYXllciB0byBvcGVyYXRlLCBvbmNlXHJcbiAgICAgICAgICAgIC8vIHRoaXMgYmFzZWxheWVyIGlzIHNldCwgYWN0aXZhdGUgdGhlIG1hcFxyXG4gICAgICAgICAgICBtYXAuc2V0QmFzZUxheWVySW5kZXgoIDAgKTtcclxuICAgICAgICAgICAgLy8gc2V0IGluaXRpYWwgdmlld3BvaW50LCByZXF1aXJlZCBieSBvcGVubGF5ZXJzXHJcbiAgICAgICAgICAgIG1hcC5vbE1hcC56b29tVG9NYXhFeHRlbnQoKTtcclxuICAgICAgICAgICAgLy8gc2V0IG1vdXNlIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICBzZXRNYXBDYWxsYmFja3MoIG1hcCApO1xyXG4gICAgICAgICAgICAvLyBjcmVhdGUgcGVuZGluZyBsYXllciBub3dcclxuICAgICAgICAgICAgaWYgKCBtYXAuc2hvd1BlbmRpbmdUaWxlcyApIHtcclxuICAgICAgICAgICAgICAgIG1hcC5wZW5kaW5nTGF5ZXIgPSBuZXcgUGVuZGluZ0xheWVyKCk7XHJcbiAgICAgICAgICAgICAgICBtYXAucGVuZGluZ0xheWVyLm1hcCA9IG1hcDtcclxuICAgICAgICAgICAgICAgIG1hcC5wZW5kaW5nTGF5ZXIuYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIG1hcC5kZWZlcnJlZHMgKSB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmF0ZURlZmVycmVkQ29tcG9uZW50cyggbWFwICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGxheWVyIG9iamVjdCB0byB0aGUgbWFwIGFuZCBhY3RpdmF0ZXMgaXQuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgICB7TWFwfSAgIFRoZSBtYXAgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGxheWVyIHtMYXllcn0gVGhlIGxheWVyIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgYWRkTGF5ZXIgPSBmdW5jdGlvbiggbWFwLCBsYXllciApIHtcclxuICAgICAgICAvLyBhZGQgbWFwIHRvIGxheWVyXHJcbiAgICAgICAgbGF5ZXIubWFwID0gbWFwO1xyXG4gICAgICAgIC8vIHRyYWNrIGxheWVyXHJcbiAgICAgICAgaWYgKCBtYXAuc2hvd1BlbmRpbmdUaWxlcyAmJiBsYXllci5zaG93UGVuZGluZ1RpbGVzICkge1xyXG4gICAgICAgICAgICBtYXAucGVuZGluZ0xheWVyLnJlZ2lzdGVyKCBsYXllciApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhY3RpdmF0ZSB0aGUgbGF5ZXJcclxuICAgICAgICBsYXllci5hY3RpdmF0ZSgpO1xyXG4gICAgICAgIC8vIGFkZCB0byBsYXllciBhcnJheVxyXG4gICAgICAgIG1hcC5sYXllcnMgPSBtYXAubGF5ZXJzIHx8IFtdO1xyXG4gICAgICAgIG1hcC5sYXllcnMucHVzaCggbGF5ZXIgKTtcclxuICAgICAgICAvLyBhZGQgaXQgdG8gbGF5ZXIgbWFwXHJcbiAgICAgICAgbWFwLmxheWVyc0J5SWQgPSBtYXAubGF5ZXJzQnlJZCB8fCB7fTtcclxuICAgICAgICBtYXAubGF5ZXJzQnlJZFsgbGF5ZXIuZ2V0VVVJRCgpIF0gPSBsYXllcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgY2Fyb3VzZWwgb2JqZWN0IHRvIHRoZSBtYXAgYW5kIGFjdGl2YXRlcyBpdC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCAgIHtNYXB9ICAgVGhlIG1hcCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gY2Fyb3VzZWwge0Nhcm91c2VsfSBUaGUgY2Fyb3VzZWwgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBhZGRDYXJvdXNlbCA9IGZ1bmN0aW9uKCBtYXAsIGNhcm91c2VsICkge1xyXG4gICAgICAgIC8vIGFkZCBtYXAgdG8gY2Fyb3VzZWxcclxuICAgICAgICBjYXJvdXNlbC5tYXAgPSBtYXA7XHJcbiAgICAgICAgLy8gYWN0aXZhdGUgdGhlIGNhcm91c2VsXHJcbiAgICAgICAgY2Fyb3VzZWwuYWN0aXZhdGUoKTtcclxuICAgICAgICAvLyBhZGQgdG8gY2Fyb3VzZWwgYXJyYXlcclxuICAgICAgICBtYXAuY2Fyb3VzZWxzID0gbWFwLmNhcm91c2VscyB8fCBbXTtcclxuICAgICAgICBtYXAuY2Fyb3VzZWxzLnB1c2goIGNhcm91c2VsICk7XHJcbiAgICAgICAgLy8gYWRkIGl0IHRvIGNhcm91c2VsIG1hcFxyXG4gICAgICAgIG1hcC5jYXJvdXNlbHNCeUlkID0gbWFwLmNhcm91c2Vsc0J5SWQgfHwge307XHJcbiAgICAgICAgbWFwLmNhcm91c2Vsc0J5SWRbIGNhcm91c2VsLmdldFVVSUQoKSBdID0gY2Fyb3VzZWw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBBeGlzIG9iamVjdCB0byB0aGUgbWFwIGFuZCBhY3RpdmF0ZXMgaXQuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgIHtNYXB9ICBUaGUgbWFwIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBheGlzIHtBeGlzfSBUaGUgbGF5ZXIgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBhZGRBeGlzID0gZnVuY3Rpb24oIG1hcCwgYXhpcyApIHtcclxuICAgICAgICAvLyBzZXQgbWluL21heCBiYXNlZCBvbiBweXJhbWlkXHJcbiAgICAgICAgaWYgKCBheGlzLnBvc2l0aW9uID09PSAndG9wJyB8fCBheGlzLnBvc2l0aW9uID09PSAnYm90dG9tJyApIHtcclxuICAgICAgICAgICAgYXhpcy5taW4gPSBtYXAucHlyYW1pZC5taW5YO1xyXG4gICAgICAgICAgICBheGlzLm1heCA9IG1hcC5weXJhbWlkLm1heFg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXhpcy5taW4gPSBtYXAucHlyYW1pZC5taW5ZO1xyXG4gICAgICAgICAgICBheGlzLm1heCA9IG1hcC5weXJhbWlkLm1heFk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFjdGl2YXRlIGFuZCBhdHRhY2ggdG8gbWFwXHJcbiAgICAgICAgYXhpcy5tYXAgPSBtYXA7XHJcbiAgICAgICAgYXhpcy5hY3RpdmF0ZSgpO1xyXG4gICAgICAgIG1hcC5heGVzID0gbWFwLmF4ZXMgfHwge307XHJcbiAgICAgICAgbWFwLmF4ZXNbIGF4aXMucG9zaXRpb24gXSA9IGF4aXM7XHJcbiAgICAgICAgLy8gdXBkYXRlIGRpbWVuc2lvbnNcclxuICAgICAgICBfLmZvckluKCBtYXAuYXhlcywgZnVuY3Rpb24oIHZhbHVlICkge1xyXG4gICAgICAgICAgICB2YWx1ZS51cGRhdGVEaW1lbnNpb24oKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyByZWRyYXdcclxuICAgICAgICBfLmZvckluKCBtYXAuYXhlcywgZnVuY3Rpb24oIHZhbHVlICkge1xyXG4gICAgICAgICAgICB2YWx1ZS5yZWRyYXcoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgYmFzZSBsYXllciBmcm9tIHRoZSBtYXAuIElmIG5vIG90aGVyIGJhc2VsYXllciBpcyBhdHRhY2hlZCwgaXRcclxuICAgICAqIHdpbGwgcmVmdXNlIHRvIGRvIHNvLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFwICAgICAgIHtNYXB9ICAgICAgIFRoZSBtYXAgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGJhc2VsYXllciB7QmFzZUxheWVyfSBUaGUgYmFzZWxheWVyIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQmFzZUxheWVyID0gZnVuY3Rpb24oIG1hcCwgYmFzZWxheWVyICkge1xyXG4gICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICAvLyBpZiBvbmx5IDEgYmFzZWxheWVyIGF2YWlsYWJsZSwgaWdub3JlXHJcbiAgICAgICAgaWYgKCAhbWFwLmRlc3Ryb3lpbmcgJiYgbWFwLmJhc2VsYXllcnMubGVuZ3RoID09PSAxICkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnRXJyb3I6IGF0dGVtcHRpbmcgdG8gcmVtb3ZlIG9ubHkgYmFzZWxheWVyIGZyb20gJyArXHJcbiAgICAgICAgICAgICAgICAnbWFwLCB0aGlzIGRlc3Ryb3lzIHRoZSBtYXAsIHVzZSBkZXN0cm95KCkgaW5zdGVhZCcgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBnZXQgaW5kZXggb2YgYmFzZWxheWVyXHJcbiAgICAgICAgaW5kZXggPSBtYXAuYmFzZWxheWVycy5pbmRleE9mKCBiYXNlbGF5ZXIgKTtcclxuICAgICAgICAgLy8gcmVtb3ZlIGJhc2VsYXllciBmcm9tIGFycmF5XHJcbiAgICAgICAgbWFwLmJhc2VsYXllcnMuc3BsaWNlKCBpbmRleCwgMSApO1xyXG4gICAgICAgIC8vIGlmIHdlIGFyZSByZW1vdmluZyBhbiBhY3RpdmUgYmFzZSBsYXllciwgY2hhbmdlIHRvXHJcbiAgICAgICAgLy8gbmV4dCBpbmRleFxyXG4gICAgICAgIGlmICggaW5kZXggPT09IG1hcC5iYXNlTGF5ZXJJbmRleCApIHtcclxuICAgICAgICAgICAgLy8gZ2V0IHJlcGxhY2VtZW50IGluZGV4XHJcbiAgICAgICAgICAgIGluZGV4ID0gKCBtYXAuYmFzZWxheWVyc1sgaW5kZXggXSApID8gaW5kZXggOiBpbmRleC0xO1xyXG4gICAgICAgICAgICAvLyByZXBsYWNlIGJhc2VsYXllclxyXG4gICAgICAgICAgICBtYXAuc2V0QmFzZUxheWVySW5kZXgoIGluZGV4ICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCBpbmRleCA8IG1hcC5iYXNlTGF5ZXJJbmRleCApIHtcclxuICAgICAgICAgICAgICAgIG1hcC5iYXNlTGF5ZXJJbmRleC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJhc2VsYXllci5tYXAgPSBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBsYXllciBvYmplY3QgZnJvbSB0aGUgbWFwIGFuZCBkZWFjdGl2YXRlcyBpdC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCAgIHtNYXB9ICAgVGhlIG1hcCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIge0xheWVyfSBUaGUgbGF5ZXIgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICByZW1vdmVMYXllciA9IGZ1bmN0aW9uKCBtYXAsIGxheWVyICkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IG1hcC5sYXllcnMuaW5kZXhPZiggbGF5ZXIgKTtcclxuICAgICAgICBpZiAoIGluZGV4ICE9PSAtMSApIHtcclxuICAgICAgICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIGxheWVyIG1hcFxyXG4gICAgICAgICAgICBkZWxldGUgbWFwLmxheWVyc0J5SWRbIGxheWVyLmdldFVVSUQoKSBdO1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgaXQgZnJvbSBsYXllciBhcnJheVxyXG4gICAgICAgICAgICBtYXAubGF5ZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcclxuICAgICAgICAgICAgLy8gdHJhY2sgbGF5ZXJcclxuICAgICAgICAgICAgaWYgKCBtYXAuc2hvd1BlbmRpbmdUaWxlcyApIHtcclxuICAgICAgICAgICAgICAgIG1hcC5wZW5kaW5nTGF5ZXIudW5yZWdpc3RlciggbGF5ZXIgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBkZWFjdGl2YXRlIGl0XHJcbiAgICAgICAgICAgIGxheWVyLmRlYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgbGF5ZXIubWFwID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gcmVzZXQgei1pbmRpY2VzXHJcbiAgICAgICAgICAgIHJlc2V0TGF5ZXJaSW5kaWNlcyggbWFwICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBjYXJvdXNlbCBvYmplY3QgZnJvbSB0aGUgbWFwIGFuZCBkZWFjdGl2YXRlcyBpdC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCAgIHtNYXB9ICAgVGhlIG1hcCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gY2Fyb3VzZWwge0Nhcm91c2VsfSBUaGUgY2Fyb3VzZWwgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICByZW1vdmVDYXJvdXNlbCA9IGZ1bmN0aW9uKCBtYXAsIGNhcm91c2VsICkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IG1hcC5jYXJvdXNlbHMuaW5kZXhPZiggY2Fyb3VzZWwgKTtcclxuICAgICAgICBpZiAoIGluZGV4ICE9PSAtMSApIHtcclxuICAgICAgICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIGxheWVyIG1hcFxyXG4gICAgICAgICAgICBkZWxldGUgbWFwLmNhcm91c2Vsc0J5SWRbIGNhcm91c2VsLmdldFVVSUQoKSBdO1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgaXQgZnJvbSBsYXllciBhcnJheVxyXG4gICAgICAgICAgICBtYXAuY2Fyb3VzZWxzLnNwbGljZSggaW5kZXgsIDEgKTtcclxuICAgICAgICAgICAgLy8gZGVhY3RpdmF0ZSBpdFxyXG4gICAgICAgICAgICBjYXJvdXNlbC5kZWFjdGl2YXRlKCk7XHJcbiAgICAgICAgICAgIGNhcm91c2VsLm1hcCA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIHJlc2V0IHotaW5kaWNlc1xyXG4gICAgICAgICAgICByZXNldExheWVyWkluZGljZXMoIG1hcCApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIEF4aXMgb2JqZWN0IGZyb20gdGhlIG1hcCBhbmQgZGVhY3RpdmF0ZXMgaXQuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgIHtNYXB9ICAgVGhlIG1hcCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gYXhpcyB7QXhpc30gVGhlIGxheWVyIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQXhpcyA9IGZ1bmN0aW9uKCBtYXAsIGF4aXMgKSB7XHJcbiAgICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gYXhlcyBtYXBcclxuICAgICAgICBkZWxldGUgbWFwLmF4ZXNbIGF4aXMucG9zaXRpb24gXTtcclxuICAgICAgICAvLyBkZWFjdGl2YXRlIGl0XHJcbiAgICAgICAgYXhpcy5kZWFjdGl2YXRlKCk7XHJcbiAgICAgICAgYXhpcy5tYXAgPSBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92aW5nIGxheWVycyBjYXVzZXMgYSB6LWluZGV4IHJlc2V0IHNpbmNlIHdlIHVzZSBjc3Mgei1pbmRleCByYXRoZXJcclxuICAgICAqIHRoYW4gT3BlbkxheWVycydzIGJ1aWx0IGluIHJlbGF0aXZlIGluZGV4aW5nICh3aGljaCBzdWNrcyBmb3IgZHluYW1pYyBtYXBzKS5cclxuICAgICAqIFRoaXMgaXMgdXNlZCB0byByZXNldCBhbGwgei1pbmRpY2VzIGFjY29yZGluZ2x5LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge01hcH0gbWFwIC0gVGhlIG1hcCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0TGF5ZXJaSW5kaWNlcyA9IGZ1bmN0aW9uKCBtYXAgKSB7XHJcbiAgICAgICAgdmFyIGxheWVycyA9IG1hcC5sYXllcnMsXHJcbiAgICAgICAgICAgIGJhc2VsYXllcixcclxuICAgICAgICAgICAgaTtcclxuICAgICAgICBpZiAoIG1hcC5sYXllcnMgKSB7XHJcbiAgICAgICAgICAgIGZvciAoIGk9MDsgaTxsYXllcnMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICBsYXllcnNbaV0uc2V0WkluZGV4KCBsYXllcnNbaV0uZ2V0WkluZGV4KCkgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIG1hcC5iYXNlTGF5ZXJJbmRleCA+PSAwICkge1xyXG4gICAgICAgICAgICBiYXNlbGF5ZXIgPSBtYXAuYmFzZWxheWVyc1sgbWFwLmJhc2VMYXllckluZGV4IF07XHJcbiAgICAgICAgICAgIGJhc2VsYXllci5yZXNldFpJbmRleCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIG1hcC5vbE1hcmtlcnMgKSB7XHJcbiAgICAgICAgICAgICQoIG1hcC5vbE1hcmtlcnMuZGl2ICkuY3NzKCAnei1pbmRleCcsIE1BUktFUl9aX0lOREVYICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbnRpYXRlIGEgTWFwIG9iamVjdC5cclxuICAgICAqIEBjbGFzcyBNYXBcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBtYXAgb2JqZWN0IHRoYXQgYWN0cyBhcyBhIGNlbnRyYWwgY29udGFpbmVyIGZvciBhbGwgbGF5ZXJzIGFuZCBvdGhlciBtYXBcclxuICAgICAqICAgICAgICAgICAgY29tcG9uZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBUaGUgRE9NIGVsZW1lbnQgaWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNwZWMgLSBUaGUgc3BlY2lmaWNhdGlvbiBvYmplY3QuXHJcbiAgICAgKiA8cHJlPlxyXG4gICAgICoge1xyXG4gICAgICogICAgIHB5cmFtaWQge1N0cmluZ30gLSBUaGUgcHlyYW1pZCB0eXBlIGZvciB0aGUgbWFwLiBEZWZhdWx0cyB0byAnV2ViTWVyY2F0b3InXHJcbiAgICAgKiAgICAgb3B0aW9uczoge1xyXG4gICAgICogICAgICAgICBudW1ab29tTGV2ZWxzIHtpbnRlZ2VyfSAtIFRoZSBudW1iZXIgb2Ygem9vbSBsZXZlbHMuIERlZmF1bHQgPSAxOC5cclxuICAgICAqICAgICAgICAgdW5pdHMge2ludGVnZXJ9IC0gVGhlIHVuaXRzIHVzZWQgZm9yIHRoZSBtYXAuIERlZmF1bHQgPSAnbScuXHJcbiAgICAgKiAgICAgICAgIHpvb21EZWxheSB7aW50ZWdlcn0gLSBUaGUgZGVsYXkgYmVmb3JlIHJlcXVlc3RpbmcgdGlsZXMgb24gYSB6b29tLiBEZWZhdWx0ID0gNDAwLlxyXG4gICAgICogICAgICAgICBtb3ZlRGVsYXkge2ludGVnZXJ9IC0gVGhlIGRlbGF5IGJlZm9yZSByZXF1ZXN0aW5nIHRpbGVzIG9uIGEgcGFuLiBEZWZhdWx0ID0gNDAwLlxyXG4gICAgICogICAgIH1cclxuICAgICAqIH1cclxuICAgICAqIDwvcHJlPlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBNYXAoIGlkLCBzcGVjICkge1xyXG4gICAgICAgIHNwZWMgPSBzcGVjIHx8IHt9O1xyXG4gICAgICAgIHNwZWMub3B0aW9ucyA9IHNwZWMub3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBzcGVjLnRoZW1lID0gc3BlYy50aGVtZSB8fCAnZGFyayc7XHJcbiAgICAgICAgLy8gZWxlbWVudCBpZFxyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICAvLyBzZXQgbWFwIHRpbGUgcHlyYW1pZFxyXG4gICAgICAgIHRoaXMuc2V0UHlyYW1pZCggc3BlYy5weXJhbWlkICk7XHJcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBiYXNlIGxheWVyIGluZGV4IHRvIC0xIGZvciBubyBiYXNlbGF5ZXJcclxuICAgICAgICB0aGlzLmJhc2VMYXllckluZGV4ID0gLTE7XHJcbiAgICAgICAgLy8gZGlzYWJsZSBraW5ldGljIHBhblxyXG4gICAgICAgIE9wZW5MYXllcnMuQ29udHJvbC5EcmFnUGFuLnByb3RvdHlwZS5lbmFibGVLaW5ldGljID0gZmFsc2U7XHJcblx0XHQvLyBuYXZpZ2F0aW9uIGNvbnRyb2xzXHJcblx0XHR0aGlzLm5hdmlnYXRpb25Db250cm9scyA9IG5ldyBPcGVuTGF5ZXJzLkNvbnRyb2wuTmF2aWdhdGlvbih7XHJcblx0XHRcdGRvY3VtZW50RHJhZzogdHJ1ZSxcclxuXHRcdFx0em9vbUJveEVuYWJsZWQ6IGZhbHNlXHJcblx0XHR9KTtcclxuXHRcdC8vIHpvb20gY29udHJvbHNcclxuXHRcdHRoaXMuem9vbUNvbnRyb2xzID0gbmV3IE9wZW5MYXllcnMuQ29udHJvbC5ab29tKCk7XHJcbiAgICAgICAgLy8gY3JlYXRlIG1hcCBvYmplY3RcclxuICAgICAgICB0aGlzLm9sTWFwID0gbmV3IE9wZW5MYXllcnMuTWFwKCB0aGlzLmlkLCB7XHJcbiAgICAgICAgICAgIHRoZW1lOiBudWxsLCAvLyBwcmV2ZW50IE9wZW5MYXllcnMgZnJvbSBjaGVja2luZyBmb3IgZGVmYXVsdCBjc3NcclxuICAgICAgICAgICAgcHJvamVjdGlvbjogbmV3IE9wZW5MYXllcnMuUHJvamVjdGlvbiggXCJFUFNHOjkwMDkxM1wiICksXHJcbiAgICAgICAgICAgIGRpc3BsYXlQcm9qZWN0aW9uOiBuZXcgT3BlbkxheWVycy5Qcm9qZWN0aW9uKCBcIkVQU0c6NDMyNlwiICksXHJcbiAgICAgICAgICAgIG1heEV4dGVudDogT3BlbkxheWVycy5Cb3VuZHMuZnJvbUFycmF5KFtcclxuICAgICAgICAgICAgICAgIC0yMDAzNzUwOC4zNDI3ODkyNDQsXHJcbiAgICAgICAgICAgICAgICAtMjAwMzc1MDguMzQyNzg5MjQ0LFxyXG4gICAgICAgICAgICAgICAgMjAwMzc1MDguMzQyNzg5MjQ0LFxyXG4gICAgICAgICAgICAgICAgMjAwMzc1MDguMzQyNzg5MjQ0XHJcbiAgICAgICAgICAgIF0pLFxyXG4gICAgICAgICAgICB6b29tTWV0aG9kOiBudWxsLFxyXG4gICAgICAgICAgICB1bml0czogc3BlYy5vcHRpb25zLnVuaXRzIHx8IFwibVwiLFxyXG4gICAgICAgICAgICBudW1ab29tTGV2ZWxzOiBzcGVjLm9wdGlvbnMubnVtWm9vbUxldmVscyB8fCAxOCxcclxuICAgICAgICAgICAgZmFsbFRocm91Z2g6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbnRyb2xzOiBbXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25Db250cm9scyxcclxuICAgICAgICAgICAgICAgIHRoaXMuem9vbUNvbnRyb2xzXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHRpbGVNYW5hZ2VyOiBPcGVuTGF5ZXJzLlRpbGVNYW5hZ2VyID8gbmV3IE9wZW5MYXllcnMuVGlsZU1hbmFnZXIoe1xyXG4gICAgICAgICAgICAgICAgbW92ZURlbGF5OiBzcGVjLm9wdGlvbnMubW92ZURlbGF5ICE9PSB1bmRlZmluZWQgPyBzcGVjLm9wdGlvbnMubW92ZURlbGF5IDogNDAwLFxyXG4gICAgICAgICAgICAgICAgem9vbURlbGF5OiBzcGVjLm9wdGlvbnMuem9vbURlbGF5ICE9PSB1bmRlZmluZWQgPyBzcGVjLm9wdGlvbnMuem9vbURlbGF5IDogNDAwXHJcbiAgICAgICAgICAgIH0pIDogdW5kZWZpbmVkXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gc2hvdyBhbmltYXRpb24gb24gcGVuZGluZyB0aWxlc1xyXG4gICAgICAgIHRoaXMuc2hvd1BlbmRpbmdUaWxlcyA9ICggc3BlYy5zaG93UGVuZGluZ1RpbGVzICE9PSB1bmRlZmluZWQgKSA/IHNwZWMuc2hvd1BlbmRpbmdUaWxlcyA6IHRydWU7XHJcbiAgICAgICAgLy8gc2V0IHRoZW1lLCBkZWZhdWx0IHRvICdkYXJrJyB0aGVtZVxyXG4gICAgICAgIHRoaXMuc2V0VGhlbWUoIHNwZWMudGhlbWUgKTtcclxuICAgIH1cclxuXHJcbiAgICBNYXAucHJvdG90eXBlID0ge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBjb21wb25lbnRzIGFuZCBkZXN0cm95cyB0aGUgbWFwLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNYXAucHJvdG90eXBlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxheWVyXHJcbiAgICAgICAgICAgIGlmICggdGhpcy5wZW5kaW5nTGF5ZXIgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdMYXllci5kZWFjdGl2YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdMYXllci5tYXAgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTGF5ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBtYXJrZXIgbGF5ZXJcclxuICAgICAgICAgICAgaWYgKCB0aGlzLm9sTWFya2VycyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2xNYXAucmVtb3ZlTGF5ZXIoIHRoaXMub2xNYXJrZXJzICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9sTWFya2VycyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5sYXllcnMuZm9yRWFjaCggZnVuY3Rpb24oIGxheWVyICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoIGxheWVyICk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMgKTtcclxuICAgICAgICAgICAgXy5mb3JJbiggdGhpcy5heGVzLCBmdW5jdGlvbiggYXhpcyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKCBheGlzICk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMgKTtcclxuICAgICAgICAgICAgdGhpcy5iYXNlbGF5ZXJzLmZvckVhY2goIGZ1bmN0aW9uKCBiYXNlbGF5ZXIgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSggYmFzZWxheWVyICk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMgKTtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIHdpbmRvdyByZXNpemUgY2FsbGJhY2tcclxuICAgICAgICAgICAgJCggd2luZG93ICkub2ZmKCAncmVzaXplJywgdGhpcy5yZXNpemVDYWxsYmFjayApO1xyXG4gICAgICAgICAgICAvLyBkZXN0cm95IG1hcFxyXG4gICAgICAgICAgICB0aGlzLm9sTWFwLmRlc3Ryb3koKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29tcG9uZW50IHRvIHRoZSBtYXAuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1hcC5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7TGF5ZXJ8QXhpc30gY29tcG9uZW50IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWRkOiBmdW5jdGlvbiggY29tcG9uZW50ICkge1xyXG4gICAgICAgICAgICBpZiAoIGNvbXBvbmVudCBpbnN0YW5jZW9mIEJhc2VMYXllciApIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIGEgYmFzZWxheWVyLCBhZGQgaXRcclxuICAgICAgICAgICAgICAgIGFkZEJhc2VMYXllciggdGhpcywgY29tcG9uZW50ICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCB0aGlzLmJhc2VMYXllckluZGV4IDwgMCApIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIG5vIGJhc2VsYXllciBpcyBhdHRhY2hlZCB5ZXQsIHdlIGNhbm5vdCBhY3RpdmF0ZSB0aGUgY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgaXQgdG8gbGlzdCBvZiBkZWZlcnJlZCBhY3RpdmF0aW9uc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZHMgPSB0aGlzLmRlZmVycmVkcyB8fCBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWRzLnB1c2goIGNvbXBvbmVudCApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFjdGl2YXRlIHRoZSBjb21wb25lbnRcclxuICAgICAgICAgICAgYWN0aXZhdGVDb21wb25lbnQoIHRoaXMsIGNvbXBvbmVudCApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYSBjb21wb25lbnQgZnJvbSB0aGUgbWFwLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNYXAucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0xheWVyfEF4aXN9IGNvbXBvbmVudCAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oIGNvbXBvbmVudCApIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLmJhc2VMYXllckluZGV4IDwgMCApIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIG5vIGJhc2VsYXllciBpcyBhdHRhY2hlZCB5ZXQsIHdlIGNhbm5vdCBkZWFjdGl2YXRlIHRoZSBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIHRoZSBsaXN0IG9mIGRlZmVycmVkIGFjdGl2YXRpb25zXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmVkcyA9IHRoaXMuZGVmZXJyZWRzIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZHMuc3BsaWNlKCB0aGlzLmRlZmVycmVkcy5pbmRleE9mKCBjb21wb25lbnQgKSwgMSApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFjdGl2YXRlIHRoZSBjb21wb25lbnRcclxuICAgICAgICAgICAgZGVhY3RpdmF0ZUNvbXBvbmVudCggdGhpcywgY29tcG9uZW50ICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5hYmxlcyB0aGUgcGFubmluZyBjb250cm9scyBmb3IgdGhlIG1hcC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBlbmFibGVOYXZpZ2F0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uQ29udHJvbHMuYWN0aXZhdGUoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgcGFubmluZyBjb250cm9scyBmb3IgdGhlIG1hcC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkaXNhYmxlTmF2aWdhdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbkNvbnRyb2xzLmRlYWN0aXZhdGUoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB0aWxla2V5IGZvciB0aGUgdGlsZSBjdXJyZW50bHkgdW5kZXIgdGhlIG1vdXNlLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNYXAucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdGlsZWtleSBjdXJyZW50bHkgdW5kZXIgdGhlIG1vdXNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFRpbGVGb2N1czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbGVGb2N1cztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBtdWx0aXBsZSBiYXNlbGF5ZXJzIGFyZSBhdHRhY2hlZCB0byB0aGUgbWFwLCB0aGlzIGZ1bmN0aW9uIGlzXHJcbiAgICAgICAgICogdXNlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnRseSBhY3RpdmUgb25lIGJ5IGluZGV4LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNYXAucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBiYXNlbGF5ZXIgdG8gc3dpdGNoIHRvLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldEJhc2VMYXllckluZGV4OiBmdW5jdGlvbiggaW5kZXggKSB7XHJcbiAgICAgICAgICAgIHZhciBvbGRCYXNlTGF5ZXIgPSB0aGlzLmJhc2VsYXllcnNbIHRoaXMuYmFzZUxheWVySW5kZXggXSxcclxuICAgICAgICAgICAgICAgIG5ld0Jhc2VMYXllciA9IHRoaXMuYmFzZWxheWVyc1sgaW5kZXggXTtcclxuICAgICAgICAgICAgaWYgKCAhbmV3QmFzZUxheWVyICkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yLCBubyBiYXNlbGF5ZXIgZm9yIHN1cHBsaWVkIGluZGV4OiBcIiArIGluZGV4ICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCBvbGRCYXNlTGF5ZXIgPT09IG5ld0Jhc2VMYXllciApIHtcclxuICAgICAgICAgICAgICAgIC8vIHNhbWUgbGF5ZXIsIGRvbid0IHN3aXRjaFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggb2xkQmFzZUxheWVyICkge1xyXG4gICAgICAgICAgICAgICAgb2xkQmFzZUxheWVyLmRlYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdCYXNlTGF5ZXIuYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5iYXNlTGF5ZXJJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgeiBpbmRleCwgc2luY2UgY2hhbmdpbmcgYmFzZWxheWVyIHJlc2V0cyB0aGVtXHJcbiAgICAgICAgICAgIHJlc2V0TGF5ZXJaSW5kaWNlcyggdGhpcyApO1xyXG4gICAgICAgICAgICBQdWJTdWIucHVibGlzaCggbmV3QmFzZUxheWVyLmdldENoYW5uZWwoKSwgeyBmaWVsZDogJ2Jhc2VMYXllckluZGV4JywgdmFsdWU6IGluZGV4IH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBhY3RpdmUgYmFzZWxheWVyIGluZGV4LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNYXAucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGN1cnJlbnRseSBhY3RpdmUgYmFzZWxheWVyIGluZGV4LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEJhc2VMYXllckluZGV4OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUxheWVySW5kZXg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IGFjdGl2ZSBiYXNlbGF5ZXIsIG9yIG51bGwgaWYgdGhlcmUgaXNuJ3Qgb25lLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNYXAucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7QmFzZUxheWVyfSBUaGUgY3VycmVudGx5IGFjdGl2ZSBiYXNlbGF5ZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0QWN0aXZlQmFzZUxheWVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLmJhc2VMYXllckluZGV4ID09PSAtMSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VsYXllcnNbIHRoaXMuYmFzZUxheWVySW5kZXggXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIHRoZW1lIG9mIHRoZSBtYXAuIEN1cnJlbnRseSByZXN0cmljdGVkIHRvIFwiZGFya1wiIGFuZCBcImxpZ2h0XCIuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1hcC5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0aGVtZSAtIFRoZSB0aGVtZSBpZGVudGlmaWNhdGlvbiBzdHJpbmcgb2YgdGhlIG1hcC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRUaGVtZTogZnVuY3Rpb24oIHRoZW1lICkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMudGhlbWUgPT09IHRoZW1lICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAvLyB0b2dnbGUgdGhlbWUgaW4gaHRtbFxyXG4gICAgICAgICAgICBpZiAoIHRoZW1lID09PSAnbGlnaHQnICkge1xyXG4gICAgICAgICAgICAgICAgJCggJ2JvZHknICkucmVtb3ZlQ2xhc3MoIFwiZGFyay10aGVtZVwiICkuYWRkQ2xhc3MoIFwibGlnaHQtdGhlbWVcIiApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgJCggJ2JvZHknICkucmVtb3ZlQ2xhc3MoIFwibGlnaHQtdGhlbWVcIiApLmFkZENsYXNzKCBcImRhcmstdGhlbWVcIiApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudGhlbWUgPSB0aGVtZTtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZW1lIGZvciBhbGwgYXR0YWNoZWQgbGF5ZXJzXHJcbiAgICAgICAgICAgIGlmICggdGhpcy5sYXllcnMgKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKCBpPTA7IGk8dGhpcy5sYXllcnMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLmxheWVyc1tpXS5zZXRUaGVtZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXllcnNbaV0uc2V0VGhlbWUoIHRoZW1lICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCB0aGVtZSBvZiB0aGUgbWFwLiBDdXJyZW50bHkgcmVzdHJpY3RlZCB0byBcImRhcmtcIlxyXG4gICAgICAgICAqIGFuZCBcImxpZ2h0XCIuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1hcC5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0aGVtZSBvZiB0aGUgbWFwLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFRoZW1lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbWFwIERPTSBlbGVtZW50LiBUaGlzIGlzIHRoZSBlbGVtZW50IHRvIHdoaWNoXHJcbiAgICAgICAgICogdGhlIG1hcCBvYmplY3QgaXMgJ2F0dGFjaGVkJy5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgTWFwLnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBUaGUgbWFwIGRpdiBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEVsZW1lbnQ6ICBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2xNYXAuZGl2O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIG1hcCB2aWV3cG9ydCBET00gZWxlbWVudC4gVGhpcyB0aGUgZWxlbWVudCB0aGF0IGVuY29tcGFzc2VzXHJcbiAgICAgICAgICogdGhlIHZpZXdhYmxlIHBvcnRpb24gb2YgdGhlIG1hcC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgTWFwLnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBUaGUgbWFwIHZpZXdwb3J0IGRpdiBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFZpZXdwb3J0RWxlbWVudDogIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbE1hcC52aWV3UG9ydERpdjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBtYXAgY29udGFpbmVyIERPTSBlbGVtZW50LiBUaGlzIGlzIHRoZSBlbGVtZW50IHRvIHdoaWNoIGFsbFxyXG4gICAgICAgICAqICdwYW5uYWJsZScgbGF5ZXJzIGFyZSBhdHRhY2hlZCB0by5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgTWFwLnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBUaGUgbWFwIGNvbnRhaW5lciBkaXYgZWxlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRDb250YWluZXJFbGVtZW50OiAgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9sTWFwLmxheWVyQ29udGFpbmVyRGl2O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBhIHB5cmFtaWQgdG8gdGhlIG1hcC4gQWxsIFRpbGUgaXRlcmF0b3JzIHJldHVybmVkIHByaW9yIHRvIHRoaXNcclxuICAgICAgICAgKiB3aWxsIGJlIGludmFsaWRhdGVkLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNYXAucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0FyZWFPZkludGVyZXN0VGlsZVB5cmFtaWR8V2ViTWVyY2F0b3JUaWxlUHlyYW1pZHxPYmplY3R9IHB5cmFtaWQgLSBUaGUgcHlyYW1pZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRQeXJhbWlkOiBmdW5jdGlvbiggcHlyYW1pZCApIHtcclxuICAgICAgICAgICAgaWYgKCAhcHlyYW1pZCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHlyYW1pZCA9IG5ldyBXZWJNZXJjYXRvclRpbGVQeXJhbWlkKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHB5cmFtaWQgaW5zdGFuY2VvZiBBcmVhT2ZJbnRlcmVzdFRpbGVQeXJhbWlkIHx8XHJcbiAgICAgICAgICAgICAgICBweXJhbWlkIGluc3RhbmNlb2YgV2ViTWVyY2F0b3JUaWxlUHlyYW1pZCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHlyYW1pZCA9IHB5cmFtaWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHB5cmFtaWQudHlwZSAmJiBweXJhbWlkLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJhcmVhb2ZpbnRlcmVzdFwiICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5weXJhbWlkID0gbmV3IEFyZWFPZkludGVyZXN0VGlsZVB5cmFtaWQoIHB5cmFtaWQgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHlyYW1pZCA9IG5ldyBXZWJNZXJjYXRvclRpbGVQeXJhbWlkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB0aWxlIHB5cmFtaWQgdXNlZCBieSB0aGUgbWFwLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNYXAucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJlYU9mSW50ZXJlc3RUaWxlUHlyYW1pZHxXZWJNZXJjYXRvclRpbGVQeXJhbWlkfSBUaGUgVGlsZVB5cmFtaWQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFB5cmFtaWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5weXJhbWlkO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBUaWxlSXRlcmF0b3Igb2JqZWN0LiBUaGlzIFRpbGVJdGVyYXRvciBjb250YWlucyBhbGwgdGlsZXMgY3VycmVudGx5XHJcbiAgICAgICAgICogdmlzaWJsZSBpbiB0aGUgbWFwLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNYXAucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7VGlsZUl0ZXJhdG9yfSBBIFRpbGVJdGVyYXRvciBvYmplY3QgY29udGFpbmluZyBhbGwgdmlzaWJsZSB0aWxlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRUaWxlSXRlcmF0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLm9sTWFwLmdldFpvb20oKSxcclxuICAgICAgICAgICAgICAgIC8vIEN1cnJlbnQgbWFwIGJvdW5kcywgaW4gbWV0ZXJzXHJcbiAgICAgICAgICAgICAgICBib3VuZHMgPSB0aGlzLm9sTWFwLmdldEV4dGVudCgpLFxyXG4gICAgICAgICAgICAgICAgLy8gVG90YWwgbWFwIGJvdW5kcywgaW4gbWV0ZXJzXHJcbiAgICAgICAgICAgICAgICBleHRlbnRzID0gdGhpcy5vbE1hcC5nZXRNYXhFeHRlbnQoKSxcclxuICAgICAgICAgICAgICAgIC8vIFB5cmFtaWQgZm9yIHRoZSB0b3RhbCBtYXAgYm91bmRzXHJcbiAgICAgICAgICAgICAgICBweXJhbWlkID0gbmV3IEFyZWFPZkludGVyZXN0VGlsZVB5cmFtaWQoe1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblg6IGV4dGVudHMubGVmdCxcclxuICAgICAgICAgICAgICAgICAgICBtaW5ZOiBleHRlbnRzLmJvdHRvbSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhYOiBleHRlbnRzLnJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIG1heFk6IGV4dGVudHMudG9wXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGFsbCB0aWxlcyBpbiB2aWV3XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGlsZUl0ZXJhdG9yKHtcclxuICAgICAgICAgICAgICAgIHB5cmFtaWQ6IHB5cmFtaWQsXHJcbiAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwsXHJcbiAgICAgICAgICAgICAgICBtaW5YOiBib3VuZHMubGVmdCxcclxuICAgICAgICAgICAgICAgIG1pblk6IGJvdW5kcy5ib3R0b20sXHJcbiAgICAgICAgICAgICAgICBtYXhYOiBib3VuZHMucmlnaHQsXHJcbiAgICAgICAgICAgICAgICBtYXhZOiBib3VuZHMudG9wXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRpbGVrZXlzIGN1cnJlbnRseSB2aXNpYmxlIGluIHRoZSBtYXAuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1hcC5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2YgdGlsZWtleSBzdHJpbmdzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFRpbGVzSW5WaWV3OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRpbGVzID0gdGhpcy5nZXRUaWxlSXRlcmF0b3IoKS5nZXRSZXN0KCksXHJcbiAgICAgICAgICAgICAgICBjdWxsZWRUaWxlcyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgbWF4VGlsZUluZGV4ID0gTWF0aC5wb3coMiwgdGhpcy5nZXRab29tKCkgKSxcclxuICAgICAgICAgICAgICAgIHRpbGUsXHJcbiAgICAgICAgICAgICAgICBpO1xyXG4gICAgICAgICAgICBmb3IgKGk9MDsgaTx0aWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGlsZSA9IHRpbGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCB0aWxlLnhJbmRleCA+PSAwICYmIHRpbGUueUluZGV4ID49IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICAgdGlsZS54SW5kZXggPCBtYXhUaWxlSW5kZXggJiYgdGlsZS55SW5kZXggPCBtYXhUaWxlSW5kZXggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGN1bGxlZFRpbGVzLnB1c2goIHRpbGUubGV2ZWwgKyBcIixcIiArIHRpbGUueEluZGV4ICsgXCIsXCIgKyB0aWxlLnlJbmRleCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjdWxsZWRUaWxlcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBab29tcyB0aGUgbWFwIHRvIGEgcGFydGljdWxhciBjb29yZGluYXRlIGFuZCB6b29tIGxldmVsLiBUaGVcclxuICAgICAgICAgKiB0cmFuc2l0aW9uIGlzIGluc3RhbnRhbmVvdXMuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1hcC5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZSAobG9uZ2l0dWRlIGZvciBnZW9zcGF0aWFsKS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGNvb3JkaW5hdGUgKGxhdGl0dWRlIGZvciBnZW9zcGF0aWFsKS5cclxuICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHpvb20gLSBUaGUgem9vbSBsZXZlbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB6b29tVG86IGZ1bmN0aW9uKCB4LCB5LCB6b29tICkge1xyXG4gICAgICAgICAgICB2YXIgdmlld3BvcnRQeCA9IE1hcFV0aWwuZ2V0Vmlld3BvcnRQaXhlbEZyb21Db29yZCggdGhpcywgeCwgeSApLFxyXG4gICAgICAgICAgICAgICAgbG9ubGF0ID0gdGhpcy5vbE1hcC5nZXRMb25MYXRGcm9tVmlld1BvcnRQeCggdmlld3BvcnRQeCApO1xyXG4gICAgICAgICAgICB0aGlzLm9sTWFwLnNldENlbnRlciggbG9ubGF0LCB6b29tICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogWm9vbXMgdGhlIG1hcCB0byBhIHBhcnRpY3VsYXIgYm91bmRpbmcgYm94LiBUaGUgdHJhbnNpdGlvbiBpc1xyXG4gICAgICAgICAqIGluc3RhbnRhbmVvdXMuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1hcC5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3VuZHMgLSBUaGUgYm91bmRpbmcgYm94IHRvIHpvb20gdG8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgem9vbVRvRXh0ZW50OiBmdW5jdGlvbiggYm91bmRzICkge1xyXG4gICAgICAgICAgICB2YXIgbWluVmlld3BvcnRQeCA9IE1hcFV0aWwuZ2V0Vmlld3BvcnRQaXhlbEZyb21Db29yZCggdGhpcywgYm91bmRzLm1pblgsIGJvdW5kcy5taW5ZICksXHJcbiAgICAgICAgICAgICAgICBtYXhWaWV3cG9ydFB4ID0gTWFwVXRpbC5nZXRWaWV3cG9ydFBpeGVsRnJvbUNvb3JkKCB0aGlzLCBib3VuZHMubWF4WCwgYm91bmRzLm1heFkgKSxcclxuICAgICAgICAgICAgICAgIG1pbkxvbkxhdCA9IHRoaXMub2xNYXAuZ2V0TG9uTGF0RnJvbVZpZXdQb3J0UHgoIG1pblZpZXdwb3J0UHggKSxcclxuICAgICAgICAgICAgICAgIG1heExvbkxhdCA9IHRoaXMub2xNYXAuZ2V0TG9uTGF0RnJvbVZpZXdQb3J0UHgoIG1heFZpZXdwb3J0UHggKSxcclxuICAgICAgICAgICAgICAgIG9sQm91bmRzID0gbmV3IE9wZW5MYXllcnMuQm91bmRzKCk7XHJcbiAgICAgICAgICAgIG9sQm91bmRzLmV4dGVuZCggbWluTG9uTGF0ICk7XHJcbiAgICAgICAgICAgIG9sQm91bmRzLmV4dGVuZCggbWF4TG9uTGF0ICk7XHJcbiAgICAgICAgICAgIHRoaXMub2xNYXAuem9vbVRvRXh0ZW50KCBvbEJvdW5kcyApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc3RyaWN0cyB0aGUgbWFwIGV4dGVudHMgdG8gYSBwYXJ0aWN1bGFyIGJvdW5kaW5nIGJveC4gSWYgbm8gYXJnIGlzXHJcbiAgICAgICAgICogcHJvdmlkZWQsIHRoaXMgcmVtb3ZlcyBwcmV2aW91cyByZXN0cmljdGlvbnMuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1hcC5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3VuZHMgLSBUaGUgYm91bmRpbmcgYm94IHRvIHpvb20gdG8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzdHJpY3RFeHRlbnQ6IGZ1bmN0aW9uKCBib3VuZHMgKSB7XHJcbiAgICAgICAgICAgIGlmICggIWJvdW5kcyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2xNYXAucmVzdHJpY3RlZEV4dGVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9sTWFwLnpvb21Ub01heEV4dGVudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtaW5WaWV3cG9ydFB4ID0gTWFwVXRpbC5nZXRWaWV3cG9ydFBpeGVsRnJvbUNvb3JkKCB0aGlzLCBib3VuZHMubWluWCwgYm91bmRzLm1pblkgKSxcclxuICAgICAgICAgICAgICAgIG1heFZpZXdwb3J0UHggPSBNYXBVdGlsLmdldFZpZXdwb3J0UGl4ZWxGcm9tQ29vcmQoIHRoaXMsIGJvdW5kcy5tYXhYLCBib3VuZHMubWF4WSApLFxyXG4gICAgICAgICAgICAgICAgbWluTG9uTGF0ID0gdGhpcy5vbE1hcC5nZXRMb25MYXRGcm9tVmlld1BvcnRQeCggbWluVmlld3BvcnRQeCApLFxyXG4gICAgICAgICAgICAgICAgbWF4TG9uTGF0ID0gdGhpcy5vbE1hcC5nZXRMb25MYXRGcm9tVmlld1BvcnRQeCggbWF4Vmlld3BvcnRQeCApLFxyXG4gICAgICAgICAgICAgICAgb2xCb3VuZHMgPSBuZXcgT3BlbkxheWVycy5Cb3VuZHMoKTtcclxuICAgICAgICAgICAgb2xCb3VuZHMuZXh0ZW5kKCBtaW5Mb25MYXQgKTtcclxuICAgICAgICAgICAgb2xCb3VuZHMuZXh0ZW5kKCBtYXhMb25MYXQgKTtcclxuICAgICAgICAgICAgdGhpcy5vbE1hcC5yZXN0cmljdGVkRXh0ZW50ID0gb2xCb3VuZHM7XHJcbiAgICAgICAgICAgIHRoaXMub2xNYXAuem9vbVRvRXh0ZW50KCBvbEJvdW5kcyApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhbnMgdGhlIG1hcCB0byBhIHBhcnRpY3VsYXIgY29vcmRpbmF0ZS4gVGhlIHRyYW5zaXRpb24gaXNcclxuICAgICAgICAgKiBhbmltYXRlZCBpZiB0aGUgcmVnaW9uIGlzIGN1cnJlbnRseSBpbiB2aWV3LCBpbnN0YW50YW5lb3VzIGlmXHJcbiAgICAgICAgICogbm90LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNYXAucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGNvb3JkaW5hdGUgKGxvbmdpdHVkZSBmb3IgZ2Vvc3BhdGlhbCkuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIChsYXRpdHVkZSBmb3IgZ2Vvc3BhdGlhbCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGFuVG86IGZ1bmN0aW9uKCB4LCB5ICkge1xyXG4gICAgICAgICAgICB2YXIgdmlld3BvcnRQeCA9IE1hcFV0aWwuZ2V0Vmlld3BvcnRQaXhlbEZyb21Db29yZCggdGhpcywgeCwgeSApLFxyXG4gICAgICAgICAgICAgICAgbG9ubGF0ID0gdGhpcy5vbE1hcC5nZXRMb25MYXRGcm9tVmlld1BvcnRQeCggdmlld3BvcnRQeCApO1xyXG4gICAgICAgICAgICB0aGlzLm9sTWFwLnBhblRvKCBsb25sYXQgKTtcclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG1hcmtlciBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIG9mIHRoZSBtYXAuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1hcC5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZSAobG9uZ2l0dWRlIGZvciBnZW9zcGF0aWFsKS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGNvb3JkaW5hdGUgKGxhdGl0dWRlIGZvciBnZW9zcGF0aWFsKS5cclxuICAgICAgICAgKiBAcGFyYW0ge01hcmtlcn0gbWFya2VyIC0gVGhlIE1hcmtlciBvYmplY3QgdG8gYWRkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge01hcmtlcn0gVGhlIGFkZGVkIG1hcmtlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBhZGRNYXJrZXI6IGZ1bmN0aW9uKCB4LCB5LCBtYXJrZXIgKSB7XHJcbiAgICAgICAgICAgIGlmICggIXRoaXMub2xNYXJrZXJzICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbE1hcmtlcnMgPSBuZXcgT3BlbkxheWVycy5MYXllci5NYXJrZXJzKCBcIk1hcmtlcnNcIiApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbE1hcC5hZGRMYXllciggdGhpcy5vbE1hcmtlcnMgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhbHdheXMgdXBkYXRlIHRoZSB6LWluZGV4IG9mIHRoaXMgZGl2XHJcbiAgICAgICAgICAgICQoIHRoaXMub2xNYXJrZXJzLmRpdiApLmNzcyggJ3otaW5kZXgnLCA1MDAwICk7XHJcbiAgICAgICAgICAgIG1hcmtlci5tYXAgPSB0aGlzO1xyXG4gICAgICAgICAgICBtYXJrZXIuYWN0aXZhdGUoIHgsIHkgKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hcmtlcjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGEgbWFya2VyIGZyb20gdGhlIG1hcC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7T3BlbkxheWVycy5NYXJrZXJ9IG1hcmtlciAtIFRoZSBtYXJrZXIgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlbW92ZU1hcmtlcjogZnVuY3Rpb24oIG1hcmtlciApIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLm9sTWFya2VycyApIHtcclxuICAgICAgICAgICAgICAgIG1hcmtlci5kZWFjdGl2YXRlKCk7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIubWFwID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYWxsIG1hcmtlcnMgZnJvbSB0aGUgbWFwLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsZWFyTWFya2VyczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5vbE1hcmtlcnMgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9sTWFya2Vycy5jbGVhck1hcmtlcnMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBlbnRpcmUgbWFwIGluIHBpeGVscy5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgTWFwLnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge2ludGVnZXJ9IFRoZSB3aWR0aCBvZiB0aGUgbWFwIGluIHBpeGVscy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUSUxFU0laRSAqIE1hdGgucG93KCAyLCB0aGlzLmdldFpvb20oKSApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgZW50aXJlIG1hcCBpbiBwaXhlbHMuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1hcC5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgaGVpZ2h0IG9mIHRoZSBtYXAgaW4gcGl4ZWxzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUSUxFU0laRSAqIE1hdGgucG93KCAyLCB0aGlzLmdldFpvb20oKSApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSB2aWV3cG9ydCBpbiBwaXhlbHMuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1hcC5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgd2lkdGggb2YgdGhlIHZpZXdwb3J0IGluIHBpeGVscy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRWaWV3cG9ydFdpZHRoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2xNYXAudmlld1BvcnREaXYuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydCBpbiBwaXhlbHMuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1hcC5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydCBpbiBwaXhlbHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0Vmlld3BvcnRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbE1hcC52aWV3UG9ydERpdi5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbWFwcyBjdXJyZW50IHpvb20gbGV2ZWwuIExldmVsIDAgaXMgY29udGFpbnMgdGhlIG1vc3RcclxuICAgICAgICAgKiBvZiBhZ2dyZWdhdGlvbi5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgTWFwLnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge2ludGVnZXJ9IFRoZSB6b29tIGxldmVsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFpvb206IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2xNYXAuZ2V0Wm9vbSgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXQgdGhlIGNlbnRyZSBvZiB0aGUgbWFwLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7T3BlbkxheWVycy5Mb25MYXR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0Q2VudGVyUHJvamVjdGVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hcFV0aWwuZ2V0Q29vcmRGcm9tVmlld3BvcnRQaXhlbChcclxuICAgICAgICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldFZpZXdwb3J0V2lkdGgoKSAvIDIsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldFZpZXdwb3J0SGVpZ2h0KCkgLyAyICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSB0b3AtbGVmdCBhbmQgYm90dG9tLXJpZ2h0IGV4dGVudHMgb2YgdGhlIHZpc2libGUgbWFwLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldE1hcEV4dGVudHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdG9wTGVmdDogTWFwVXRpbC5nZXRDb29yZEZyb21WaWV3cG9ydFBpeGVsKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAwICksXHJcbiAgICAgICAgICAgICAgICBib3R0b21SaWdodDogTWFwVXRpbC5nZXRDb29yZEZyb21WaWV3cG9ydFBpeGVsKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRWaWV3cG9ydFdpZHRoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRWaWV3cG9ydEhlaWdodCgpIClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgYSBtYXAgZXZlbnQgY2FsbGJhY2suIFN1cHBvcnRzIGFsbCBvZiB0aGUgZm9sbG93aW5nIE9wZW5MYXllcnMuTWFwIGV2ZW50czpcclxuICAgICAgICAgKiA8cHJlPlxyXG4gICAgICAgICAqICAgICBtb3Zlc3RhcnQgLSB0cmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0YXJ0IG9mIGEgZHJhZywgcGFuLCBvciB6b29tLiAgVGhlIGV2ZW50IG9iamVjdCBtYXkgaW5jbHVkZSBhIHpvb21DaGFuZ2VkIHByb3BlcnR5IHRoYXQgdGVsbHMgd2hldGhlciB0aGUgem9vbSBoYXMgY2hhbmdlZC5cclxuICAgICAgICAgKiAgICAgbW92ZSAtIHRyaWdnZXJlZCBhZnRlciBlYWNoIGRyYWcsIHBhbiwgb3Igem9vbVxyXG4gICAgICAgICAqICAgICBtb3ZlZW5kIC0gdHJpZ2dlcmVkIGFmdGVyIGEgZHJhZywgcGFuLCBvciB6b29tIGNvbXBsZXRlc1xyXG4gICAgICAgICAqICAgICB6b29tc3RhcnQgLSB0cmlnZ2VyZWQgd2hlbiBhIHpvb20gc3RhcnRzLiAgTGlzdGVuZXJzIHJlY2VpdmUgYW4gb2JqZWN0IHdpdGggY2VudGVyIGFuZCB6b29tIHByb3BlcnRpZXMsIGZvciB0aGUgdGFyZ2V0IGNlbnRlciBhbmQgem9vbSBsZXZlbC5cclxuICAgICAgICAgKiAgICAgem9vbWVuZCAtIHRyaWdnZXJlZCBhZnRlciBhIHpvb20gY29tcGxldGVzXHJcbiAgICAgICAgICogICAgIG1vdXNlb3ZlciAtIHRyaWdnZXJlZCBhZnRlciBtb3VzZW92ZXIgdGhlIG1hcFxyXG4gICAgICAgICAqICAgICBtb3VzZW91dCAtIHRyaWdnZXJlZCBhZnRlciBtb3VzZW91dCB0aGUgbWFwXHJcbiAgICAgICAgICogICAgIG1vdXNlbW92ZSAtIHRyaWdnZXJlZCBhZnRlciBtb3VzZW1vdmUgdGhlIG1hcFxyXG4gICAgICAgICAqIDwvcHJlPlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNYXAucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIC0gVGhlIGV2ZW50IHR5cGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb246IGZ1bmN0aW9uKCBldmVudFR5cGUsIGNhbGxiYWNrICkge1xyXG4gICAgICAgICAgICB0aGlzLm9sTWFwLmV2ZW50cy5yZWdpc3RlciggZXZlbnRUeXBlLCB0aGlzLm9sTWFwLCBjYWxsYmFjayApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZSBhIG1hcCBldmVudCBjYWxsYmFjay4gU3VwcG9ydHMgYWxsIG9mIHRoZSBmb2xsb3dpbmcgT3BlbkxheWVycy5NYXAgZXZlbnRzOlxyXG4gICAgICAgICAqIDxwcmU+XHJcbiAgICAgICAgICogICAgIG1vdmVzdGFydCAtIHRyaWdnZXJlZCBhZnRlciB0aGUgc3RhcnQgb2YgYSBkcmFnLCBwYW4sIG9yIHpvb20uICBUaGUgZXZlbnQgb2JqZWN0IG1heSBpbmNsdWRlIGEgem9vbUNoYW5nZWQgcHJvcGVydHkgdGhhdCB0ZWxscyB3aGV0aGVyIHRoZSB6b29tIGhhcyBjaGFuZ2VkLlxyXG4gICAgICAgICAqICAgICBtb3ZlIC0gdHJpZ2dlcmVkIGFmdGVyIGVhY2ggZHJhZywgcGFuLCBvciB6b29tXHJcbiAgICAgICAgICogICAgIG1vdmVlbmQgLSB0cmlnZ2VyZWQgYWZ0ZXIgYSBkcmFnLCBwYW4sIG9yIHpvb20gY29tcGxldGVzXHJcbiAgICAgICAgICogICAgIHpvb21zdGFydCAtIHRyaWdnZXJlZCB3aGVuIGEgem9vbSBzdGFydHMuICBMaXN0ZW5lcnMgcmVjZWl2ZSBhbiBvYmplY3Qgd2l0aCBjZW50ZXIgYW5kIHpvb20gcHJvcGVydGllcywgZm9yIHRoZSB0YXJnZXQgY2VudGVyIGFuZCB6b29tIGxldmVsLlxyXG4gICAgICAgICAqICAgICB6b29tZW5kIC0gdHJpZ2dlcmVkIGFmdGVyIGEgem9vbSBjb21wbGV0ZXNcclxuICAgICAgICAgKiAgICAgbW91c2VvdmVyIC0gdHJpZ2dlcmVkIGFmdGVyIG1vdXNlb3ZlciB0aGUgbWFwXHJcbiAgICAgICAgICogICAgIG1vdXNlb3V0IC0gdHJpZ2dlcmVkIGFmdGVyIG1vdXNlb3V0IHRoZSBtYXBcclxuICAgICAgICAgKiAgICAgbW91c2Vtb3ZlIC0gdHJpZ2dlcmVkIGFmdGVyIG1vdXNlbW92ZSB0aGUgbWFwXHJcbiAgICAgICAgICogPC9wcmU+XHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1hcC5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgLSBUaGUgZXZlbnQgdHlwZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBvZmY6IGZ1bmN0aW9uKCBldmVudFR5cGUsIGNhbGxiYWNrICkge1xyXG4gICAgICAgICAgICB0aGlzLm9sTWFwLmV2ZW50cy51bnJlZ2lzdGVyKCBldmVudFR5cGUsIHRoaXMub2xNYXAsIGNhbGxiYWNrICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJpZ2dlciBhIG1hcCBldmVudC4gU3VwcG9ydHMgYWxsIG9mIHRoZSBmb2xsb3dpbmcgT3BlbkxheWVycy5NYXAgZXZlbnRzOlxyXG4gICAgICAgICAqIDxwcmU+XHJcbiAgICAgICAgICogICAgIG1vdmVzdGFydCAtIHRyaWdnZXJlZCBhZnRlciB0aGUgc3RhcnQgb2YgYSBkcmFnLCBwYW4sIG9yIHpvb20uICBUaGUgZXZlbnQgb2JqZWN0IG1heSBpbmNsdWRlIGEgem9vbUNoYW5nZWQgcHJvcGVydHkgdGhhdCB0ZWxscyB3aGV0aGVyIHRoZSB6b29tIGhhcyBjaGFuZ2VkLlxyXG4gICAgICAgICAqICAgICBtb3ZlIC0gdHJpZ2dlcmVkIGFmdGVyIGVhY2ggZHJhZywgcGFuLCBvciB6b29tXHJcbiAgICAgICAgICogICAgIG1vdmVlbmQgLSB0cmlnZ2VyZWQgYWZ0ZXIgYSBkcmFnLCBwYW4sIG9yIHpvb20gY29tcGxldGVzXHJcbiAgICAgICAgICogICAgIHpvb21zdGFydCAtIHRyaWdnZXJlZCB3aGVuIGEgem9vbSBzdGFydHMuICBMaXN0ZW5lcnMgcmVjZWl2ZSBhbiBvYmplY3Qgd2l0aCBjZW50ZXIgYW5kIHpvb20gcHJvcGVydGllcywgZm9yIHRoZSB0YXJnZXQgY2VudGVyIGFuZCB6b29tIGxldmVsLlxyXG4gICAgICAgICAqICAgICB6b29tZW5kIC0gdHJpZ2dlcmVkIGFmdGVyIGEgem9vbSBjb21wbGV0ZXNcclxuICAgICAgICAgKiAgICAgbW91c2VvdmVyIC0gdHJpZ2dlcmVkIGFmdGVyIG1vdXNlb3ZlciB0aGUgbWFwXHJcbiAgICAgICAgICogICAgIG1vdXNlb3V0IC0gdHJpZ2dlcmVkIGFmdGVyIG1vdXNlb3V0IHRoZSBtYXBcclxuICAgICAgICAgKiAgICAgbW91c2Vtb3ZlIC0gdHJpZ2dlcmVkIGFmdGVyIG1vdXNlbW92ZSB0aGUgbWFwXHJcbiAgICAgICAgICogPC9wcmU+XHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1hcC5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgLSBUaGUgZXZlbnQgdHlwZS5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IHRvIGJlIHBhc3NlZCB0byB0aGUgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50VHlwZSwgZXZlbnQgKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2xNYXAuZXZlbnRzLnRyaWdnZXJFdmVudCggZXZlbnRUeXBlLCBldmVudCApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNYXA7XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgdXRpbGl0eSBuYW1lc3BhY2UgY29udGFpbmluZyBtYXAgY29vcmRpbmF0ZSBjb252ZXJzaW9uIGZ1bmN0aW9uYWxpdHkuXHJcbiAqL1xyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHJcblx0dmFyIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKSxcclxuICAgICAgICBnZXRNYXBNaW5BbmRNYXhJblZpZXdwb3J0UGl4ZWxzLFxyXG4gICAgICAgIFRJTEVTSVpFID0gMjU2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZTogUmV0dXJucyB0aGUgbWFwcyBtaW4gYW5kIG1heCBwaXhlbHMgaW4gdmlld3BvcnQgcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAge01hcH0gVGhlIG1hcCBvYmplY3QuXHJcbiAgICAgKiBOT1RFOiAgICB2aWV3cG9ydCBbMCwwXSBpcyBUT1AtTEVGVFxyXG4gICAgICogICAgICAgICAgbWFwIFswLDBdIGlzIEJPVFRPTS1MRUZUXHJcbiAgICAgKi9cclxuICAgIGdldE1hcE1pbkFuZE1heEluVmlld3BvcnRQaXhlbHMgPSBmdW5jdGlvbiggbWFwICkge1xyXG4gICAgICAgIHZhciBvbE1hcCA9IG1hcC5vbE1hcDtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdG1pbjogb2xNYXAuZ2V0Vmlld1BvcnRQeEZyb21Mb25MYXQoXHJcblx0XHRcdFx0XHRuZXcgT3BlbkxheWVycy5Mb25MYXQoXHJcblx0XHRcdFx0XHRcdG9sTWFwLm1heEV4dGVudC5sZWZ0LFxyXG5cdFx0XHRcdFx0XHRvbE1hcC5tYXhFeHRlbnQuYm90dG9tICkgKSxcclxuXHRcdFx0bWF4OiBvbE1hcC5nZXRWaWV3UG9ydFB4RnJvbUxvbkxhdChcclxuXHRcdFx0XHRcdG5ldyBPcGVuTGF5ZXJzLkxvbkxhdChcclxuXHRcdFx0XHRcdFx0b2xNYXAubWF4RXh0ZW50LnJpZ2h0LFxyXG5cdFx0XHRcdFx0XHRvbE1hcC5tYXhFeHRlbnQudG9wICkgKVxyXG5cdFx0fTtcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG5cdFx0ICogVHJhbnNmb3JtcyBhIHBvaW50IGZyb20gZGF0YSBjb29yZGluYXRlcyB0byB2aWV3cG9ydCBwaXhlbCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIG1hcCB7TWFwfSAgICBUaGUgbWFwIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0geCAgIHtudW1iZXJ9IFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIGRhdGEuXHJcbiAgICAgICAgICogQHBhcmFtIHkgICB7bnVtYmVyfSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBkYXRhLlxyXG5cdFx0ICogTk9URTogICAgdmlld3BvcnQgWzAsMF0gaXMgVE9QLUxFRlRcclxuXHRcdCAqICAgICAgICAgIGRhdGEgWzAsMF0gaXMgQk9UVE9NLUxFRlRcclxuXHRcdCAqL1xyXG5cdFx0Z2V0Vmlld3BvcnRQaXhlbEZyb21Db29yZDogZnVuY3Rpb24oIG1hcCwgeCwgeSApIHtcclxuXHRcdFx0dmFyIG1hcFBpeGVsID0gdGhpcy5nZXRNYXBQaXhlbEZyb21Db29yZCggbWFwLCB4LCB5ICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldFZpZXdwb3J0UGl4ZWxGcm9tTWFwUGl4ZWwoIG1hcCwgbWFwUGl4ZWwueCwgbWFwUGl4ZWwueSApO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRyYW5zZm9ybXMgYSBwb2ludCBmcm9tIG1hcCBwaXhlbCBjb29yZGluYXRlcyB0byB2aWV3cG9ydCBwaXhlbCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIG1hcCB7TWFwfSAgICBUaGUgbWFwIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0gbXggIHtudW1iZXJ9IFRoZSB4IHBpeGVsIGNvb3JkaW5hdGUgb2YgdGhlIG1hcC5cclxuICAgICAgICAgKiBAcGFyYW0gbXkgIHtudW1iZXJ9IFRoZSB5IHBpeGVsIGNvb3JkaW5hdGUgb2YgdGhlIG1hcC5cclxuXHRcdCAqIE5PVEU6ICAgIHZpZXdwb3J0IFswLDBdIGlzIFRPUC1MRUZUXHJcblx0XHQgKiAgICAgICAgICBtYXAgWzAsMF0gaXMgQk9UVE9NLUxFRlRcclxuXHRcdCAqL1xyXG5cdFx0Z2V0Vmlld3BvcnRQaXhlbEZyb21NYXBQaXhlbDogZnVuY3Rpb24oIG1hcCwgbXgsIG15ICkge1xyXG5cdFx0XHR2YXIgdmlld3BvcnRNaW5NYXggPSBnZXRNYXBNaW5BbmRNYXhJblZpZXdwb3J0UGl4ZWxzKCBtYXAgKTtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR4OiBteCArIHZpZXdwb3J0TWluTWF4Lm1pbi54LFxyXG5cdFx0XHRcdHk6IG1hcC5nZXRXaWR0aCgpIC0gbXkgKyB2aWV3cG9ydE1pbk1heC5tYXgueVxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRyYW5zZm9ybXMgYSBwb2ludCBmcm9tIGRhdGEgY29vcmRpbmF0ZXMgdG8gbWFwIHBpeGVsIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gbWFwIHtNYXB9IFRoZSBtYXAgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAge2ludH0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0geSAgIHtpbnR9IFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGRhdGEuXHJcblx0XHQgKiBOT1RFOiAgICBkYXRhIGFuZCBtYXAgWzAsMF0gYXJlIGJvdGggQk9UVE9NLUxFRlRcclxuXHRcdCAqL1xyXG5cdFx0Z2V0TWFwUGl4ZWxGcm9tQ29vcmQ6IGZ1bmN0aW9uKCBtYXAsIHgsIHkgKSB7XHJcblx0XHRcdHZhciB0aWxlID0gbWFwLnB5cmFtaWQucm9vdFRvRnJhY3Rpb25hbFRpbGUoIHgsIHksIG1hcC5nZXRab29tKCksIFRJTEVTSVpFICksXHJcblx0XHRcdCAgICBiaW4gPSBtYXAucHlyYW1pZC5yb290VG9GcmFjdGlvbmFsQmluKCB4LCB5LCB0aWxlKTtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR4OiB0aWxlLnhJbmRleCAqIFRJTEVTSVpFICsgYmluLngsXHJcblx0XHRcdFx0eTogdGlsZS55SW5kZXggKiBUSUxFU0laRSArIFRJTEVTSVpFIC0gMSAtIGJpbi55XHJcblx0XHRcdH07XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVHJhbnNmb3JtcyBhIHBvaW50IGZyb20gdmlld3BvcnQgcGl4ZWwgY29vcmRpbmF0ZXMgdG8gbWFwIHBpeGVsIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gbWFwIHtNYXB9IFRoZSBtYXAgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB2eCAge2ludH0gVGhlIHggcGl4ZWwgY29vcmRpbmF0ZSBvZiB0aGUgdmlld3BvcnQuXHJcbiAgICAgICAgICogQHBhcmFtIHZ5ICB7aW50fSBUaGUgeSBwaXhlbCBjb29yZGluYXRlIG9mIHRoZSB2aWV3cG9ydC5cclxuXHRcdCAqIE5PVEU6ICAgIHZpZXdwb3J0IFswLDBdIGlzIFRPUC1MRUZUXHJcblx0XHQgKiAgICAgICAgICBtYXAgWzAsMF0gaXMgQk9UVE9NLUxFRlRcclxuXHRcdCAqL1xyXG5cdFx0Z2V0TWFwUGl4ZWxGcm9tVmlld3BvcnRQaXhlbDogZnVuY3Rpb24oIG1hcCwgdngsIHZ5ICkge1xyXG4gICAgICAgICAgICB2YXIgdmlld3BvcnRNaW5NYXggPSBnZXRNYXBNaW5BbmRNYXhJblZpZXdwb3J0UGl4ZWxzKCBtYXAgKSxcclxuXHRcdFx0ICAgIHRvdGFsUGl4ZWxTcGFuID0gbWFwLmdldFdpZHRoKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcblx0XHRcdFx0eDogdG90YWxQaXhlbFNwYW4gKyB2eCAtIHZpZXdwb3J0TWluTWF4Lm1heC54LFxyXG5cdFx0XHRcdHk6IHRvdGFsUGl4ZWxTcGFuIC0gdnkgKyB2aWV3cG9ydE1pbk1heC5tYXgueVxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRyYW5zZm9ybXMgYSBwb2ludCBmcm9tIG1hcCBwaXhlbCBjb29yZGluYXRlcyB0byBkYXRhIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gbWFwIHtNYXB9ICAgIFRoZSBtYXAgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSBteCAge251bWJlcn0gVGhlIHggcGl4ZWwgY29vcmRpbmF0ZSBvZiB0aGUgbWFwLlxyXG4gICAgICAgICAqIEBwYXJhbSBteSAge251bWJlcn0gVGhlIHkgcGl4ZWwgY29vcmRpbmF0ZSBvZiB0aGUgbWFwLlxyXG5cdFx0ICogTk9URTogICAgZGF0YSBhbmQgbWFwIFswLDBdIGFyZSBib3RoIEJPVFRPTS1MRUZUXHJcblx0XHQgKi9cclxuXHRcdGdldENvb3JkRnJvbU1hcFBpeGVsOiBmdW5jdGlvbiggbWFwLCBteCwgbXkgKSB7XHJcbiAgICAgICAgICAgIHZhciB0aWxlQW5kQmluID0gdGhpcy5nZXRUaWxlQW5kQmluRnJvbU1hcFBpeGVsKCBtYXAsIG14LCBteSwgVElMRVNJWkUsIFRJTEVTSVpFICksXHJcblx0XHRcdCAgICBib3VuZHMgPSBtYXAucHlyYW1pZC5nZXRCaW5Cb3VuZHMoIHRpbGVBbmRCaW4udGlsZSwgdGlsZUFuZEJpbi5iaW4gKTtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR4OiBib3VuZHMubWluWCxcclxuXHRcdFx0XHR5OiBib3VuZHMubWluWVxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRyYW5zZm9ybXMgYSBwb2ludCBmcm9tIHZpZXdwb3J0IHBpeGVsIGNvb3JkaW5hdGVzIHRvIGRhdGEgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBtYXAge01hcH0gVGhlIG1hcCBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHZ4ICB7aW50fSBUaGUgeCBwaXhlbCBjb29yZGluYXRlIG9mIHRoZSB2aWV3cG9ydC5cclxuICAgICAgICAgKiBAcGFyYW0gdnkgIHtpbnR9IFRoZSB5IHBpeGVsIGNvb3JkaW5hdGUgb2YgdGhlIHZpZXdwb3J0LlxyXG5cdFx0ICogTk9URTogICAgdmlld3BvcnQgWzAsMF0gaXMgVE9QLUxFRlRcclxuXHRcdCAqICAgICAgICAgIGRhdGEgWzAsMF0gaXMgQk9UVE9NLUxFRlRcclxuXHRcdCAqL1xyXG5cdFx0Z2V0Q29vcmRGcm9tVmlld3BvcnRQaXhlbDogZnVuY3Rpb24oIG1hcCwgdngsIHZ5ICkge1xyXG5cdFx0XHR2YXIgbWFwUGl4ZWwgPSB0aGlzLmdldE1hcFBpeGVsRnJvbVZpZXdwb3J0UGl4ZWwoIG1hcCwgdngsIHZ5ICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldENvb3JkRnJvbU1hcFBpeGVsKCBtYXAsIG1hcFBpeGVsLngsIG1hcFBpeGVsLnkgKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIHRoZSB0aWxlIGFuZCBiaW4gaW5kZXggY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gdmlld3BvcnQgcGl4ZWwgY29vcmRpbmF0ZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIG1hcCB7TWFwfSBUaGUgbWFwIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0gdnggIHtpbnR9IFRoZSB4IHBpeGVsIGNvb3JkaW5hdGUgb2YgdGhlIHZpZXdwb3J0LlxyXG4gICAgICAgICAqIEBwYXJhbSB2eSAge2ludH0gVGhlIHkgcGl4ZWwgY29vcmRpbmF0ZSBvZiB0aGUgdmlld3BvcnQuXHJcbiAgICAgICAgICogQHBhcmFtIHhCaW5Db3VudCB7aW50fSBUaGUgbnVtYmVyIG9mIGJpbnMgaW4gdGhlIHggZGltZW5zaW9uIG9mIHRoZSB0aWxlLlxyXG4gICAgICAgICAqIEBwYXJhbSB5QmluQ291bnQge2ludH0gVGhlIG51bWJlciBvZiBiaW5zIGluIHRoZSB5IGRpbWVuc2lvbiBvZiB0aGUgdGlsZS5cclxuXHRcdCAqL1xyXG5cdFx0Z2V0VGlsZUFuZEJpbkZyb21WaWV3cG9ydFBpeGVsOiBmdW5jdGlvbiggbWFwLCB2eCwgdnksIHhCaW5Db3VudCwgeUJpbkNvdW50ICkge1xyXG5cdFx0XHR2YXIgbWFwUGl4ZWwgPSB0aGlzLmdldE1hcFBpeGVsRnJvbVZpZXdwb3J0UGl4ZWwoIG1hcCwgdngsIHZ5ICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldFRpbGVBbmRCaW5Gcm9tTWFwUGl4ZWwoIG1hcCwgbWFwUGl4ZWwueCwgbWFwUGl4ZWwueSwgeEJpbkNvdW50LCB5QmluQ291bnQgKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgdGlsZSBhbmQgYmluIGluZGV4IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIG1hcCBwaXhlbCBjb29yZGluYXRlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gbWFwIHtNYXB9ICAgIFRoZSBtYXAgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSBteCAge251bWJlcn0gVGhlIHggcGl4ZWwgY29vcmRpbmF0ZSBvZiB0aGUgbWFwLlxyXG4gICAgICAgICAqIEBwYXJhbSBteSAge251bWJlcn0gVGhlIHkgcGl4ZWwgY29vcmRpbmF0ZSBvZiB0aGUgbWFwLlxyXG4gICAgICAgICAqIEBwYXJhbSB4QmluQ291bnQge2ludH0gVGhlIG51bWJlciBvZiBiaW5zIGluIHRoZSB4IGRpbWVuc2lvbiBvZiB0aGUgdGlsZS5cclxuICAgICAgICAgKiBAcGFyYW0geUJpbkNvdW50IHtpbnR9IFRoZSBudW1iZXIgb2YgYmlucyBpbiB0aGUgeSBkaW1lbnNpb24gb2YgdGhlIHRpbGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0VGlsZUFuZEJpbkZyb21NYXBQaXhlbDogZnVuY3Rpb24oIG1hcCwgbXgsIG15LCB4QmluQ291bnQsIHlCaW5Db3VudCApIHtcclxuICAgICAgICAgICAgdmFyIHRpbGVJbmRleFggPSBNYXRoLmZsb29yKCBteCAvIFRJTEVTSVpFICksXHJcbiAgICAgICAgICAgICAgICB0aWxlSW5kZXhZID0gTWF0aC5mbG9vciggbXkgLyBUSUxFU0laRSApLFxyXG4gICAgICAgICAgICAgICAgdGlsZVBpeGVsWCA9IFV0aWwubW9kKCBteCAsIFRJTEVTSVpFICksXHJcbiAgICAgICAgICAgICAgICB0aWxlUGl4ZWxZID0gVXRpbC5tb2QoIG15LCBUSUxFU0laRSApO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdGlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsIDogbWFwLmdldFpvb20oKSxcclxuICAgICAgICAgICAgICAgICAgICB4SW5kZXggOiB0aWxlSW5kZXhYLFxyXG4gICAgICAgICAgICAgICAgICAgIHlJbmRleCA6IHRpbGVJbmRleFksXHJcbiAgICAgICAgICAgICAgICAgICAgeEJpbkNvdW50IDogeEJpbkNvdW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHlCaW5Db3VudCA6IHlCaW5Db3VudFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJpbjoge1xyXG4gICAgICAgICAgICAgICAgICAgIHggOiBNYXRoLmZsb29yKCB0aWxlUGl4ZWxYIC8gKFRJTEVTSVpFIC8geEJpbkNvdW50ICkgKSxcclxuICAgICAgICAgICAgICAgICAgICB5IDogKHlCaW5Db3VudCAtIDEpIC0gTWF0aC5mbG9vciggdGlsZVBpeGVsWSAvIChUSUxFU0laRSAvIHlCaW5Db3VudCkgKSAvLyBiaW4gWzAsMF0gaXMgdG9wIGxlZnRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuXHRcdCAqIFJldHVybnMgdGhlIHRpbGUgYW5kIGJpbiBpbmRleCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBkYXRhIGNvb3JkaW5hdGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBtYXAge01hcH0gVGhlIG1hcCBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHggICB7aW50fSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBkYXRhLlxyXG4gICAgICAgICAqIEBwYXJhbSB5ICAge2ludH0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0geEJpbkNvdW50IHtpbnR9IFRoZSBudW1iZXIgb2YgYmlucyBpbiB0aGUgeCBkaW1lbnNpb24gb2YgdGhlIHRpbGUuXHJcbiAgICAgICAgICogQHBhcmFtIHlCaW5Db3VudCB7aW50fSBUaGUgbnVtYmVyIG9mIGJpbnMgaW4gdGhlIHkgZGltZW5zaW9uIG9mIHRoZSB0aWxlLlxyXG5cdFx0ICovXHJcblx0XHRnZXRUaWxlQW5kQmluRnJvbUNvb3JkOiBmdW5jdGlvbiggbWFwLCB4LCB5LCB4QmluQ291bnQsIHlCaW5Db3VudCApIHtcclxuXHRcdFx0dmFyIG1hcFBpeGVsID0gdGhpcy5nZXRNYXBQaXhlbEZyb21Db29yZCggbWFwLCB4LCB5ICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldFRpbGVBbmRCaW5Gcm9tTWFwUGl4ZWwoIG1hcCwgbWFwUGl4ZWwueCwgbWFwUGl4ZWwueSwgeEJpbkNvdW50LCB5QmluQ291bnQgKTtcclxuXHRcdH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHRvcCBsZWZ0IHBpeGVsIGxvY2F0aW9uIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzIGZyb20gYSB0aWxla2V5Li5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBtYXAgICAgIHtNYXB9ICAgIFRoZSBtYXAgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB0aWxla2V5IHtzdHJpbmd9IFRoZSB0aWxla2V5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFRvcExlZnRWaWV3cG9ydFBpeGVsRm9yVGlsZTogZnVuY3Rpb24oIG1hcCwgdGlsZWtleSApIHtcclxuICAgICAgICAgICAgdmFyIG1hcFBpeGVsID0gdGhpcy5nZXRUb3BMZWZ0TWFwUGl4ZWxGb3JUaWxlKCBtYXAsIHRpbGVrZXkgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Vmlld3BvcnRQaXhlbEZyb21NYXBQaXhlbCggbWFwLCBtYXBQaXhlbC54LCBtYXBQaXhlbC55ICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgdG9wIGxlZnQgcGl4ZWwgbG9jYXRpb24gaW4gdmlld3BvcnQgY29vcmQgZnJvbSBhIHRpbGUgaW5kZXguXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gbWFwICAgICB7TWFwfSAgICBUaGUgbWFwIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0gdGlsZWtleSB7c3RyaW5nfSBUaGUgdGlsZWtleS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRUb3BMZWZ0TWFwUGl4ZWxGb3JUaWxlOiBmdW5jdGlvbiggbWFwLCB0aWxla2V5ICkge1xyXG4gICAgICAgICAgICB2YXIgcGFyc2VkVmFsdWVzID0gdGlsZWtleS5zcGxpdCggJywnICksXHJcbiAgICAgICAgICAgICAgICB4ID0gcGFyc2VJbnQoIHBhcnNlZFZhbHVlc1sxXSwgMTAgKSxcclxuICAgICAgICAgICAgICAgIHkgPSBwYXJzZUludCggcGFyc2VkVmFsdWVzWzJdLCAxMCApLFxyXG4gICAgICAgICAgICAgICAgbXggPSB4ICogVElMRVNJWkUsXHJcbiAgICAgICAgICAgICAgICBteSA9IHkgKiBUSUxFU0laRSArIFRJTEVTSVpFO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeCA6IG14LFxyXG4gICAgICAgICAgICAgICAgeSA6IG15XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZGF0YSBjb29yZGluYXRlIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHRvcCBsZWZ0IHBpeGVsIG9mIHRoZSB0aWxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gbWFwICAgICB7TWFwfSAgICBUaGUgbWFwIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0gdGlsZWtleSB7c3RyaW5nfSBUaGUgdGlsZWtleS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRUb3BMZWZ0Q29vcmRGb3JUaWxlOiBmdW5jdGlvbiggbWFwLCB0aWxla2V5ICkge1xyXG4gICAgICAgICAgICB2YXIgbWFwUGl4ZWwgPSB0aGlzLmdldFRvcExlZnRNYXBQaXhlbEZvclRpbGUoIG1hcCwgdGlsZWtleSApO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb29yZEZyb21NYXBQaXhlbCggbWFwLCBtYXBQaXhlbC54LCBtYXBQaXhlbC55ICk7XHJcbiAgICAgICAgfVxyXG5cclxuXHR9O1xyXG59KCkpO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIE1hcFV0aWwgPSByZXF1aXJlKCcuL01hcFV0aWwnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbnRpYXRlIGEgTWFya2VyIG9iamVjdC5cclxuICAgICAqIEBjbGFzcyBNYXJrZXJcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBtYXJrZXIgb2JqZWN0IHRoYXQgaXMgcGlubmVkIHRvIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIE1hcmtlciggaW1nVXJsLCBpbWdXaWR0aCwgaW1nSGVpZ2h0ICkge1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBpbWdXaWR0aCB8fCA1MDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGltZ0hlaWdodCB8fCA1MDtcclxuICAgICAgICB0aGlzLmljb24gPSBuZXcgT3BlbkxheWVycy5JY29uKFxyXG4gICAgICAgICAgICBpbWdVcmwsXHJcbiAgICAgICAgICAgIG5ldyBPcGVuTGF5ZXJzLlNpemUoIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0ICksXHJcbiAgICAgICAgICAgIG5ldyBPcGVuTGF5ZXJzLlBpeGVsKCAtdGhpcy53aWR0aC8yLCAtdGhpcy5oZWlnaHQgKSApO1xyXG4gICAgfVxyXG5cclxuICAgIE1hcmtlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFjdGl2YXRlcyB0aGUgbWFya2VyIG9iamVjdC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbiggeCwgeSApIHtcclxuICAgICAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICAgICAgdmFyIHZpZXdwb3J0UHggPSBNYXBVdGlsLmdldFZpZXdwb3J0UGl4ZWxGcm9tQ29vcmQoIHRoaXMubWFwLCB4LCB5ICksXHJcbiAgICAgICAgICAgICAgICBsb25sYXQgPSB0aGlzLm1hcC5vbE1hcC5nZXRMb25MYXRGcm9tVmlld1BvcnRQeCggdmlld3BvcnRQeCApO1xyXG4gICAgICAgICAgICB0aGlzLm9sTWFya2VyID0gbmV3IE9wZW5MYXllcnMuTWFya2VyKCBsb25sYXQsIHRoaXMuaWNvbi5jbG9uZSgpICk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLm9sTWFya2Vycy5hZGRNYXJrZXIoIHRoaXMub2xNYXJrZXIgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZS1hY3RpdmF0ZXMgdGhlIG1hcmtlciBvYmplY3QuIFRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCBtYW51YWxseS5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWFjdGl2YXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLm9sTWFya2VyICYmIHRoaXMubWFwLm9sTWFya2VycyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwLm9sTWFya2Vycy5yZW1vdmVNYXJrZXIoIHRoaXMub2xNYXJrZXIgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub2xNYXJrZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbE1hcmtlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy55ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIG1hcmtlcnMgZGl2IGVsZW1lbnQuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1hcC5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIG1hcmtlciBkaXYuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5vbE1hcmtlciApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9sTWFya2VyLmljb24uaW1hZ2VEaXY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNYXJrZXI7XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgQW5ub3RhdGlvblNlcnZpY2VcclxuICogQGNsYXNzZGVzYyBBIHV0aWxpdHkgbmFtZXNwYWNlIHRoYXQgcHJvdmlkZXMgYW5ub3RhdGlvbiBzZXJ2aWNlIFJFU1QgZnVuY3Rpb25hbGl0eS5cclxuICovXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGEgdGlsZXMgd29ydGggb2YgYW5ub3RhdGlvbnMgZnJvbSB0aGUgc2VydmVyLiBVcG9uIHN1Y2Nlc3MsIHdpbGwgZXhlY3V0ZSBzdWNjZXNzXHJcbiAgICAgICAgICogY2FsbGJhY2sgZnVuY3Rpb24gcGFzc2luZyB0aGUgcmVzdWx0aW5nIG9iamVjdCBhcyBmaXJzdCBhcmd1bWVudC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgQW5ub3RhdGlvblNlcnZpY2VcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsYXllcklkIC0gVGhlIGFubm90YXRpb24gbGF5ZXIgaWRlbnRpZmljYXRpb24gc3RyaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gbGV2ZWwgLSBUaGUgem9vbSBsZXZlbC5cclxuICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHggLSBUaGUgdGlsZSB4IGluZGV4LlxyXG4gICAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0geSAtIFRoZSB0aWxlIHkgaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBxdWVyeSBwYXJhbWV0ZXIgY29uZmlndXJhdGlvbiBvdmVycmlkZXMgKG9wdGlvbmFsKS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIGFmdGVyIHN1Y2Nlc3MgcmVjZWl2ZWQgKG9wdGlvbmFsKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRUaWxlSlNPTjogZnVuY3Rpb24oIGxheWVySWQsIGxldmVsLCB4LCB5LCBwYXJhbXMsIHN1Y2Nlc3MgKSB7XHJcbiAgICAgICAgICAgIHZhciBfcGFyYW1zID0gKCB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkgPyBwYXJhbXMgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgX3N1Y2Nlc3MgPSAoIHR5cGVvZiBzdWNjZXNzID09PSBcImZ1bmN0aW9uXCIgKVxyXG4gICAgICAgICAgICAgICAgICAgID8gc3VjY2Vzc1xyXG4gICAgICAgICAgICAgICAgICAgIDogKCB0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCIgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgICQuZ2V0KFxyXG4gICAgICAgICAgICAgICAgJ3Jlc3QvdjEuMC9hbm5vdGF0aW9uLydcclxuICAgICAgICAgICAgICAgICsgbGF5ZXJJZCArIFwiL1wiXHJcbiAgICAgICAgICAgICAgICArIGxldmVsICsgXCIvXCJcclxuICAgICAgICAgICAgICAgICsgeCArIFwiL1wiXHJcbiAgICAgICAgICAgICAgICArIHkgKyBcIi5qc29uXCIgKyBVdGlsLmVuY29kZVF1ZXJ5UGFyYW1zKCBfcGFyYW1zIClcclxuICAgICAgICAgICAgKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgX3N1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICBVdGlsLmhhbmRsZUhUVFBFcnJvclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlIGFuIGFubm90YXRpb24gdG8gdGhlIHNlcnZlci4gVXBvbiBzdWNjZXNzLCB3aWxsIGV4ZWN1dGUgc3VjY2Vzc1xyXG4gICAgICAgICAqIGNhbGxiYWNrIGZ1bmN0aW9uIHBhc3NpbmcgdGhlIHJlc3VsdGluZyBjZXJ0aWZpY2F0ZSBhcyBmaXJzdCBhcmd1bWVudC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgQW5ub3RhdGlvblNlcnZpY2VcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsYXllcklkIC0gVGhlIGFubm90YXRpb24gbGF5ZXIgaWRlbnRpZmljYXRpb24gc3RyaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbm5vdGF0aW9uIC0gVGhlIGFubm90YXRpb24gdG8gYmUgd3JpdHRlbi5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIGFmdGVyIHN1Y2Nlc3MgcmVjZWl2ZWQgKG9wdGlvbmFsKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB3cml0ZUFubm90YXRpb246IGZ1bmN0aW9uKCBsYXllcklkLCBhbm5vdGF0aW9uLCBzdWNjZXNzICkge1xyXG4gICAgICAgICAgICB2YXIgX3N1Y2Nlc3MgPSAoIHR5cGVvZiBzdWNjZXNzID09PSBcImZ1bmN0aW9uXCIgKSA/IHN1Y2Nlc3MgOiBudWxsO1xyXG4gICAgICAgICAgICAkLnBvc3QoXHJcbiAgICAgICAgICAgICAgICAncmVzdC92MS4wL2Fubm90YXRpb24nLFxyXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwid3JpdGVcIixcclxuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiBsYXllcklkXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBfc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIFV0aWwuaGFuZGxlSFRUUEVycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTW9kaWZ5IGFuIGFubm90YXRpb24gb24gdGhlIHNlcnZlci4gVXBvbiBzdWNjZXNzLCB3aWxsIGV4ZWN1dGUgc3VjY2Vzc1xyXG4gICAgICAgICAqIGNhbGxiYWNrIGZ1bmN0aW9uIHBhc3NpbmcgdGhlIHJlc3VsdGluZyBjZXJ0aWZpY2F0ZSBhcyBmaXJzdCBhcmd1bWVudC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgQW5ub3RhdGlvblNlcnZpY2VcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsYXllcklkIC0gVGhlIGFubm90YXRpb24gbGF5ZXIgaWRlbnRpZmljYXRpb24gc3RyaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbm5vdGF0aW9uIC0gVGhlIGFubm90YXRpb24gdG8gYmUgbW9kaWZpZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBleGVjdXRlZCBhZnRlciBzdWNjZXNzIHJlY2VpdmVkIChvcHRpb25hbCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbW9kaWZ5QW5ub3RhdGlvbjogZnVuY3Rpb24oIGxheWVySWQsIGFubm90YXRpb24sIHN1Y2Nlc3MgKSB7XHJcbiAgICAgICAgICAgIHZhciBfc3VjY2VzcyA9ICggdHlwZW9mIHN1Y2Nlc3MgPT09IFwiZnVuY3Rpb25cIiApID8gc3VjY2VzcyA6IG51bGw7XHJcbiAgICAgICAgICAgICQucG9zdChcclxuICAgICAgICAgICAgICAgICdyZXN0L3YxLjAvYW5ub3RhdGlvbicsXHJcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJtb2RpZnlcIixcclxuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiBsYXllcklkXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBfc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIFV0aWwuaGFuZGxlSFRUUEVycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlIGFuIGFubm90YXRpb24gZnJvbSB0aGUgc2VydmVyLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBBbm5vdGF0aW9uU2VydmljZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGxheWVySWQgLSBUaGUgYW5ub3RhdGlvbiBsYXllciBpZGVudGlmaWNhdGlvbiBzdHJpbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNlcnRpZmljYXRlIC0gVGhlIGNlcnRpZmljYXRlIG9mIHRoZSBhbm5vdGF0aW9uIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBleGVjdXRlZCBhZnRlciBzdWNjZXNzIHJlY2VpdmVkIChvcHRpb25hbCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVtb3ZlQW5ub3RhdGlvbjogZnVuY3Rpb24oIGxheWVySWQsIGNlcnRpZmljYXRlLCBzdWNjZXNzICkge1xyXG4gICAgICAgICAgICB2YXIgX3N1Y2Nlc3MgPSAoIHR5cGVvZiBzdWNjZXNzID09PSBcImZ1bmN0aW9uXCIgKSA/IHN1Y2Nlc3MgOiBudWxsO1xyXG4gICAgICAgICAgICAkLnBvc3QoXHJcbiAgICAgICAgICAgICAgICAncmVzdC92MS4wL2Fubm90YXRpb24nLFxyXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVtb3ZlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgY2VydGlmaWNhdGU6IGNlcnRpZmljYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiBsYXllcklkXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBfc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIFV0aWwuaGFuZGxlSFRUUEVycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgTGF5ZXJTZXJ2aWNlXHJcbiAqIEBjbGFzc2Rlc2MgQSB1dGlsaXR5IG5hbWVzcGFjZSB0aGF0IHByb3ZpZGVzIGxheWVyIHNlcnZpY2UgUkVTVCBmdW5jdGlvbmFsaXR5LlxyXG4gKi9cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvVXRpbCcpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXF1ZXN0IGFsbCBsYXllcnMgZnJvbSB0aGUgc2VydmVyLiBVcG9uIHN1Y2Nlc3MsIHdpbGwgZXhlY3V0ZSBzdWNjZXNzXHJcbiAgICAgICAgICogY2FsbGJhY2sgZnVuY3Rpb24gcGFzc2luZyB0aGUgcmVzdWx0aW5nIG9iamVjdCBhcyBmaXJzdCBhcmd1bWVudC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgTGF5ZXJTZXJ2aWNlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIGFmdGVyIHN1Y2Nlc3MgcmVjZWl2ZWQgKG9wdGlvbmFsKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRMYXllcnM6IGZ1bmN0aW9uKCBzdWNjZXNzICkge1xyXG4gICAgICAgICAgICB2YXIgX3N1Y2Nlc3MgPSAoIHR5cGVvZiBzdWNjZXNzID09PSBcImZ1bmN0aW9uXCIgKSA/IHN1Y2Nlc3MgOiBudWxsO1xyXG4gICAgICAgICAgICAkLmdldChcclxuICAgICAgICAgICAgICAgICdyZXN0L3YxLjAvbGF5ZXJzJ1xyXG4gICAgICAgICAgICApLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBfc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIFV0aWwuaGFuZGxlSFRUUEVycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVxdWVzdCBhIHNwZWNpZmljIGxheWVyIGZyb20gdGhlIHNlcnZlci4gVXBvbiBzdWNjZXNzLCB3aWxsIGV4ZWN1dGUgc3VjY2Vzc1xyXG4gICAgICAgICAqIGNhbGxiYWNrIGZ1bmN0aW9uIHBhc3NpbmcgdGhlIHJlc3VsdGluZyBvYmplY3QgYXMgZmlyc3QgYXJndW1lbnQuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIExheWVyU2VydmljZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGxheWVySWQgLSBUaGUgbGF5ZXIgaWRlbnRpZmljYXRpb24gc3RyaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgYWZ0ZXIgc3VjY2VzcyByZWNlaXZlZCAob3B0aW9uYWwpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldExheWVyOiBmdW5jdGlvbiggbGF5ZXJJZCwgc3VjY2VzcyApIHtcclxuICAgICAgICAgICAgdmFyIF9zdWNjZXNzID0gKCB0eXBlb2Ygc3VjY2VzcyA9PT0gXCJmdW5jdGlvblwiICkgPyBzdWNjZXNzIDogbnVsbDtcclxuICAgICAgICAgICAgJC5nZXQoXHJcbiAgICAgICAgICAgICAgICAncmVzdC92MS4wL2xheWVycy8nICsgbGF5ZXJJZFxyXG4gICAgICAgICAgICApLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBfc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIFV0aWwuaGFuZGxlSFRUUEVycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RvcmUgYSBjb25maWd1cmF0aW9uIHN0YXRlIG9uIHRoZSBzZXJ2ZXIuIFVwb24gc3VjY2Vzcywgd2lsbCBleGVjdXRlIHN1Y2Nlc3NcclxuICAgICAgICAgKiBjYWxsYmFjayBmdW5jdGlvbiBwYXNzaW5nIHRoZSByZXN1bHRpbmcgb2JqZWN0IGFzIGZpcnN0IGFyZ3VtZW50LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBMYXllclNlcnZpY2VcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsYXllcklkIC0gVGhlIGxheWVyIGlkZW50aWZpY2F0aW9uIHN0cmluZy5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlciBjb25maWd1cmF0aW9uIG92ZXJyaWRlcyAob3B0aW9uYWwpLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgYWZ0ZXIgc3VjY2VzcyByZWNlaXZlZCAob3B0aW9uYWwpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNhdmVMYXllclN0YXRlOiBmdW5jdGlvbiggbGF5ZXJJZCwgcGFyYW1zLCBzdWNjZXNzICkge1xyXG4gICAgICAgICAgICB2YXIgX3N1Y2Nlc3MgPSAoIHR5cGVvZiBzdWNjZXNzID09PSBcImZ1bmN0aW9uXCIgKSA/IHN1Y2Nlc3MgOiBudWxsO1xyXG4gICAgICAgICAgICAkLnBvc3QoXHJcbiAgICAgICAgICAgICAgICAncmVzdC92MS4wL2xheWVycy8nICsgbGF5ZXJJZCArICcvc3RhdGVzJyxcclxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KCBwYXJhbXMgKVxyXG4gICAgICAgICAgICApLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBfc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIFV0aWwuaGFuZGxlSFRUUEVycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGFsbCBjb25maWd1cmF0aW9uIHN0YXRlcyBmb3IgYSBsYXllciBvbiB0aGUgc2VydmVyLiBVcG9uIHN1Y2Nlc3MsIHdpbGwgZXhlY3V0ZVxyXG4gICAgICAgICAqIHN1Y2Nlc3MgY2FsbGJhY2sgZnVuY3Rpb24gcGFzc2luZyB0aGUgcmVzdWx0aW5nIG9iamVjdCBhcyBmaXJzdCBhcmd1bWVudC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgTGF5ZXJTZXJ2aWNlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGF5ZXJJZCAtIFRoZSBsYXllciBpZGVudGlmaWNhdGlvbiBzdHJpbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBleGVjdXRlZCBhZnRlciBzdWNjZXNzIHJlY2VpdmVkIChvcHRpb25hbCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0TGF5ZXJTdGF0ZXM6IGZ1bmN0aW9uKCBsYXllcklkLCBzdWNjZXNzICkge1xyXG4gICAgICAgICAgICB2YXIgX3N1Y2Nlc3MgPSAoIHR5cGVvZiBzdWNjZXNzID09PSBcImZ1bmN0aW9uXCIgKSA/IHN1Y2Nlc3MgOiBudWxsO1xyXG4gICAgICAgICAgICAkLmdldChcclxuICAgICAgICAgICAgICAgICdyZXN0L3YxLjAvbGF5ZXJzLycgKyBsYXllcklkICsgJy9zdGF0ZXMnXHJcbiAgICAgICAgICAgICkudGhlbihcclxuICAgICAgICAgICAgICAgIF9zdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgVXRpbC5oYW5kbGVIVFRQRXJyb3JcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgYSBjb25maWd1cmF0aW9uIHN0YXRlIGZvciBhIGxheWVyIG9uIHRoZSBzZXJ2ZXIgYnkgc3RhdGUgaWQuIFVwb24gc3VjY2VzcyxcclxuICAgICAgICAgKiB3aWxsIGV4ZWN1dGUgc3VjY2VzcyBjYWxsYmFjayBmdW5jdGlvbiBwYXNzaW5nIHRoZSByZXN1bHRpbmcgb2JqZWN0IGFzIGZpcnN0IGFyZ3VtZW50LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBMYXllclNlcnZpY2VcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsYXllcklkIC0gVGhlIGxheWVyIGlkZW50aWZpY2F0aW9uIHN0cmluZy5cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RhdGVJZCAtIFRoZSBzdGF0ZSBpZGVudGlmaWNhdGlvbiBzdHJpbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBleGVjdXRlZCBhZnRlciBzdWNjZXNzIHJlY2VpdmVkIChvcHRpb25hbCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0TGF5ZXJTdGF0ZTogZnVuY3Rpb24oIGxheWVySWQsIHN0YXRlSWQsIHN1Y2Nlc3MgKSB7XHJcbiAgICAgICAgICAgIHZhciBfc3VjY2VzcyA9ICggdHlwZW9mIHN1Y2Nlc3MgPT09IFwiZnVuY3Rpb25cIiApID8gc3VjY2VzcyA6IG51bGw7XHJcbiAgICAgICAgICAgICQuZ2V0KFxyXG4gICAgICAgICAgICAgICAgJ3Jlc3QvdjEuMC9sYXllcnMvJyArIGxheWVySWQgKyAnL3N0YXRlcy8nICsgc3RhdGVJZFxyXG4gICAgICAgICAgICApLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBfc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIFV0aWwuaGFuZGxlSFRUUEVycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xyXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cclxuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG4gKiBTT0ZUV0FSRS5cclxuICovXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIExlZ2VuZFNlcnZpY2VcclxuICogQGNsYXNzZGVzYyBBIHV0aWxpdHkgbmFtZXNwYWNlIHRoYXQgcHJvdmlkZXMgbGVnZW5kIHNlcnZpY2UgUkVTVCBmdW5jdGlvbmFsaXR5LlxyXG4gKi9cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvVXRpbCcpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgYW4gZW5jb2RlZCBpbWFnZSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByZW5kZXJpbmcgbGVnZW5kLiBVcG9uIHN1Y2Nlc3MsXHJcbiAgICAgICAgICogd2lsbCBleGVjdXRlIHN1Y2Nlc3MgY2FsbGJhY2sgZnVuY3Rpb24gcGFzc2luZyB0aGUgcmVzdWx0aW5nIHN0cmluZyBhcyBmaXJzdFxyXG4gICAgICAgICAqIGFyZ3VtZW50LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBMZWdlbmRTZXJ2aWNlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGF5ZXJJZCAtIFRoZSBsYXllciBpZGVudGlmaWNhdGlvbiBzdHJpbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBxdWVyeSBwYXJhbWV0ZXIgY29uZmlndXJhdGlvbiBvdmVycmlkZXMgKG9wdGlvbmFsKS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIGFmdGVyIHN1Y2Nlc3MgcmVjZWl2ZWQgKG9wdGlvbmFsKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRFbmNvZGVkSW1hZ2U6IGZ1bmN0aW9uKCBsYXllcklkLCBwYXJhbXMsIHN1Y2Nlc3MgKSB7XHJcbiAgICAgICAgICAgIHZhciBfcGFyYW1zID0gKCB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkgPyBwYXJhbXMgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgX3N1Y2Nlc3MgPSAoIHR5cGVvZiBzdWNjZXNzID09PSBcImZ1bmN0aW9uXCIgKVxyXG4gICAgICAgICAgICAgICAgICAgID8gc3VjY2Vzc1xyXG4gICAgICAgICAgICAgICAgICAgIDogKCB0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCIgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgICQuZ2V0KFxyXG4gICAgICAgICAgICAgICAgJ3Jlc3QvdjEuMC9sZWdlbmQvJyArIGxheWVySWQgKyBVdGlsLmVuY29kZVF1ZXJ5UGFyYW1zKCBfcGFyYW1zIClcclxuICAgICAgICAgICAgKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgX3N1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICBVdGlsLmhhbmRsZUhUVFBFcnJvclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhIHBuZyBpbWFnZSByZXByZXNlbnRpbmcgdGhlIHJlbmRlcmluZyBsZWdlbmQuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIExlZ2VuZFNlcnZpY2VcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsYXllcklkIC0gVGhlIGxheWVyIGlkZW50aWZpY2F0aW9uIHN0cmluZy5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHF1ZXJ5IHBhcmFtZXRlciBjb25maWd1cmF0aW9uIG92ZXJyaWRlcyAob3B0aW9uYWwpLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgYWZ0ZXIgc3VjY2VzcyByZWNlaXZlZCAob3B0aW9uYWwpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEltYWdlOiBmdW5jdGlvbiggbGF5ZXJJZCwgcGFyYW1zLCBzdWNjZXNzICkge1xyXG4gICAgICAgICAgICB2YXIgX3BhcmFtcyA9ICggdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApID8gcGFyYW1zIDoge30sXHJcbiAgICAgICAgICAgICAgICBfc3VjY2VzcyA9ICggdHlwZW9mIHN1Y2Nlc3MgPT09IFwiZnVuY3Rpb25cIiApXHJcbiAgICAgICAgICAgICAgICAgICAgPyBzdWNjZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgOiAoIHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIiApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgLy8gZXhwbGljaXRseSBzZXQgb3V0cHV0IHR5cGUgdG8gcG5nIGltYWdlXHJcbiAgICAgICAgICAgIF9wYXJhbXMub3V0cHV0ID0gJ3BuZyc7XHJcbiAgICAgICAgICAgICQuZ2V0KFxyXG4gICAgICAgICAgICAgICAgJ3Jlc3QvdjEuMC9sZWdlbmQvJyArIGxheWVySWQgKyBVdGlsLmVuY29kZVF1ZXJ5UGFyYW1zKCBfcGFyYW1zIClcclxuICAgICAgICAgICAgKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgX3N1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICBVdGlsLmhhbmRsZUhUVFBFcnJvclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgVGlsZVNlcnZpY2VcclxuICogQGNsYXNzZGVzYyBBIHV0aWxpdHkgbmFtZXNwYWNlIHRoYXQgcHJvdmlkZXMgdGlsZSBzZXJ2aWNlIFJFU1QgZnVuY3Rpb25hbGl0eS5cclxuICovXHJcbiggZnVuY3Rpb24oKSB7XHJcbiAgICBcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhIHRpbGUgd29ydGggb2YgZGF0YSBpbiBKU09OIGZvcm1hdC4gVXBvbiBzdWNjZXNzLCB3aWxsIGV4ZWN1dGUgc3VjY2Vzc1xyXG4gICAgICAgICAqIGNhbGxiYWNrIGZ1bmN0aW9uIHBhc3NpbmcgdGhlIHJlc3VsdGluZyBvYmplY3QgYXMgZmlyc3QgYXJndW1lbnQuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFRpbGVTZXJ2aWNlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGF5ZXJJZCAtIFRoZSBsYXllciBpZGVudGlmaWNhdGlvbiBzdHJpbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBsZXZlbCAtIFRoZSB6b29tIGxldmVsLlxyXG4gICAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0geCAtIFRoZSB0aWxlIHggaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSB5IC0gVGhlIHRpbGUgeSBpbmRleC5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHF1ZXJ5IHBhcmFtZXRlciBjb25maWd1cmF0aW9uIG92ZXJyaWRlcyAob3B0aW9uYWwpLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgYWZ0ZXIgc3VjY2VzcyByZWNlaXZlZCAob3B0aW9uYWwpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFRpbGVKU09OOiBmdW5jdGlvbiggbGF5ZXJJZCwgbGV2ZWwsIHgsIHksIHBhcmFtcywgc3VjY2VzcyApIHtcclxuICAgICAgICAgICAgdmFyIF9wYXJhbXMgPSAoIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSA/IHBhcmFtcyA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBfc3VjY2VzcyA9ICggdHlwZW9mIHN1Y2Nlc3MgPT09IFwiZnVuY3Rpb25cIiApXHJcbiAgICAgICAgICAgICAgICAgICAgPyBzdWNjZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgOiAoIHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIiApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgJC5nZXQoXHJcbiAgICAgICAgICAgICAgICAncmVzdC92MS4wL3RpbGUvJ1xyXG4gICAgICAgICAgICAgICAgKyBsYXllcklkICsgXCIvXCJcclxuICAgICAgICAgICAgICAgICsgbGV2ZWwgKyBcIi9cIlxyXG4gICAgICAgICAgICAgICAgKyB4ICsgXCIvXCJcclxuICAgICAgICAgICAgICAgICsgeSArIFwiLmpzb25cIiArIFV0aWwuZW5jb2RlUXVlcnlQYXJhbXMoIF9wYXJhbXMgKVxyXG4gICAgICAgICAgICApLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBfc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIFV0aWwuaGFuZGxlSFRUUEVycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGEgdGlsZSByZW5kZXJlZCBhcyBhbiBpbWFnZS4gVXBvbiBzdWNjZXNzLCB3aWxsIGV4ZWN1dGUgc3VjY2Vzc1xyXG4gICAgICAgICAqIGNhbGxiYWNrIGZ1bmN0aW9uIHBhc3NpbmcgdGhlIHJlc3VsdGluZyBvYmplY3QgYXMgZmlyc3QgYXJndW1lbnQuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFRpbGVTZXJ2aWNlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGF5ZXJJZCAtIFRoZSBsYXllciBpZGVudGlmaWNhdGlvbiBzdHJpbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBsZXZlbCAtIFRoZSB6b29tIGxldmVsLlxyXG4gICAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0geCAtIFRoZSB0aWxlIHggaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSB5IC0gVGhlIHRpbGUgeSBpbmRleC5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHF1ZXJ5IHBhcmFtZXRlciBjb25maWd1cmF0aW9uIG92ZXJyaWRlcyAob3B0aW9uYWwpLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgYWZ0ZXIgc3VjY2VzcyByZWNlaXZlZCAob3B0aW9uYWwpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFRpbGVJbWFnZTogZnVuY3Rpb24oIGxheWVySWQsIGxldmVsLCB4LCB5LCBwYXJhbXMsIHN1Y2Nlc3MgKSB7XHJcbiAgICAgICAgICAgIHZhciBfcGFyYW1zID0gKCB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkgPyBwYXJhbXMgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgX3N1Y2Nlc3MgPSAoIHR5cGVvZiBzdWNjZXNzID09PSBcImZ1bmN0aW9uXCIgKVxyXG4gICAgICAgICAgICAgICAgICAgID8gc3VjY2Vzc1xyXG4gICAgICAgICAgICAgICAgICAgIDogKCB0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCIgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgICQuZ2V0KFxyXG4gICAgICAgICAgICAgICAgJ3Jlc3QvdjEuMC90aWxlLydcclxuICAgICAgICAgICAgICAgICsgbGF5ZXJJZCArIFwiL1wiXHJcbiAgICAgICAgICAgICAgICArIGxldmVsICsgXCIvXCJcclxuICAgICAgICAgICAgICAgICsgeCArIFwiL1wiXHJcbiAgICAgICAgICAgICAgICArIHkgKyBcIi5wbmdcIiArIFV0aWwuZW5jb2RlUXVlcnlQYXJhbXMoIF9wYXJhbXMgKVxyXG4gICAgICAgICAgICApLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBfc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIFV0aWwuaGFuZGxlSFRUUEVycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICogXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICogXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqIFxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICogXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIFB1YlN1YiA9IHJlcXVpcmUoJy4uL3V0aWwvUHViU3ViJyk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBjb2Fyc2VuZXNzIGRyb3Bkb3duIG1lbnUgYW5kIGJpbmRzIGl0IHRvIHRoZSBwcm92aWRlZCBsYXllci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gVGhlIGxheWVyIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtKUXVlcnl9IC0gVGhlIEpRdWVyeSBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24oIGxheWVyICkge1xyXG4gICAgICAgICAgICB2YXIgJGNvYXJzZW5lc3NDb250cm9scyA9ICQoICc8ZGl2IGNsYXNzPVwiY29hcnNlbmVzcy1jb250cm9sc1wiPjwvZGl2PicgKSxcclxuICAgICAgICAgICAgICAgICRjb2Fyc2VuZXNzTGFiZWwgPSAkKCAnPGRpdiBjbGFzcz1cImNvbnRyb2xzLWxhYmVsXCI+Q29hcnNlbmVzczwvZGl2PicgKSxcclxuICAgICAgICAgICAgICAgICRjb2Fyc2VuZXNzTWVudSA9ICQoICc8ZGl2IGNsYXNzPVwiY29udHJvbC1tZW51XCI+JyApLFxyXG4gICAgICAgICAgICAgICAgJG1lbnVJdGVtcyA9ICQoJzx1bCBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIj48L3VsPicpLFxyXG4gICAgICAgICAgICAgICAgc2V0Q29hcnNlbmVzcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnNldENvYXJzZW5lc3MoICQoIHRoaXMgKS5kYXRhKCAnY29hcnNlbmVzcycgKSApO1xyXG4gICAgICAgICAgICAgICAgICAgICRtZW51SXRlbXMuY2hpbGRyZW4oKS5lYWNoKCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJCggdGhpcyApLnJlbW92ZUNsYXNzKCAnYWN0aXZlJyApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICQoIHRoaXMgKS5hZGRDbGFzcyggJ2FjdGl2ZScgKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVNZW51ID0gZnVuY3Rpb24oIGNvYXJzZW5lc3MgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJG1lbnVJdGVtcy5jaGlsZHJlbigpLmVhY2goIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCB0aGlzICkucmVtb3ZlQ2xhc3MoICdhY3RpdmUnICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggJCggdGhpcyApLmRhdGEoICdjb2Fyc2VuZXNzJyApID09PSBjb2Fyc2VuZXNzICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCggdGhpcyApLmFkZENsYXNzKCAnYWN0aXZlJyApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaXRlbXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCIxeDFcIlxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCIyeDJcIlxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogMyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCI0eDRcIlxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogNCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCI4eDhcIlxyXG4gICAgICAgICAgICAgICAgICAgIH1dLFxyXG4gICAgICAgICAgICAgICAgJGl0ZW0sXHJcbiAgICAgICAgICAgICAgICBpO1xyXG4gICAgICAgICAgICAkbWVudUl0ZW1zLmNsaWNrKCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICRtZW51SXRlbXMudG9nZ2xlQ2xhc3MoXCJkcm9wZG93bi1tZW51LW9wZW5cIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmb3IgKCBpPTA7IGk8aXRlbXMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAkaXRlbSA9ICQoIFxyXG4gICAgICAgICAgICAgICAgICAgICc8bGkgY2xhc3M9XCJtZW51LWl0ZW1cIj4nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGEgaHJlZj1cIiNcIiBjbGFzcz1cIm1lbnUtaXRlbS1saW5rXCI+JytpdGVtc1tpXS5uYW1lKyc8L2E+JytcclxuICAgICAgICAgICAgICAgICAgICAnPC9saT4nICk7XHJcbiAgICAgICAgICAgICAgICAkaXRlbS5kYXRhKCAnY29hcnNlbmVzcycsIGl0ZW1zW2ldLmlkICk7XHJcbiAgICAgICAgICAgICAgICAkaXRlbS5jbGljayggc2V0Q29hcnNlbmVzcyApO1xyXG4gICAgICAgICAgICAgICAgJG1lbnVJdGVtcy5hcHBlbmQoICRpdGVtICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXBkYXRlTWVudSggbGF5ZXIuZ2V0Q29hcnNlbmVzcygpICk7XHJcbiAgICAgICAgICAgIFB1YlN1Yi5zdWJzY3JpYmUoIGxheWVyLmdldENoYW5uZWwoKSwgZnVuY3Rpb24oIG1lc3NhZ2UgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIG1lc3NhZ2UuZmllbGQgPT09IFwiY29hcnNlbmVzc1wiICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZU1lbnUoIG1lc3NhZ2UudmFsdWUgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICRjb2Fyc2VuZXNzQ29udHJvbHMuYXBwZW5kKCAkY29hcnNlbmVzc0xhYmVsICk7XHJcbiAgICAgICAgICAgICRjb2Fyc2VuZXNzQ29udHJvbHMuYXBwZW5kKCAkY29hcnNlbmVzc01lbnUuYXBwZW5kKCAkbWVudUl0ZW1zICkgKTtcclxuICAgICAgICAgICAgcmV0dXJuICRjb2Fyc2VuZXNzQ29udHJvbHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG59KCkpOyIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIFNsaWRlclV0aWwgPSByZXF1aXJlKCcuL1NsaWRlclV0aWwnKSxcclxuICAgICAgICBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyksXHJcbiAgICAgICAgQXhpc1V0aWwgPSByZXF1aXJlKCcuLi9tYXAvQXhpc1V0aWwnKSxcclxuICAgICAgICBQdWJTdWIgPSByZXF1aXJlKCcuLi91dGlsL1B1YlN1YicpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbHRlckF4aXMoIG1pbk1heCwgdHJhbnNmb3JtICkge1xyXG4gICAgICAgIHZhciBOVU1fTUFKT1JfTUFSS0VSUyA9IDU7XHJcbiAgICAgICAgcmV0dXJuICQoICc8ZGl2IGNsYXNzPVwiZmlsdGVyLWF4aXNcIj48L2Rpdj4nIClcclxuICAgICAgICAgICAgLmFwcGVuZCggY3JlYXRlQXhpc01hcmtlcnMoIE5VTV9NQUpPUl9NQVJLRVJTICkgKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCBjcmVhdGVBeGlzTGFiZWxzKCBOVU1fTUFKT1JfTUFSS0VSUywgbWluTWF4LCB0cmFuc2Zvcm0gKSApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUF4aXNNYXJrZXJzKCBudW1NYWpvck1hcmtlcnMgKSB7XHJcbiAgICAgICAgdmFyICRjb250YWluZXIgPSAkKCc8ZGl2IGNsYXNzPVwiZmlsdGVyLWF4aXMtdGlja3MtY29udGFpbmVyXCI+PC9kaXY+JyksXHJcbiAgICAgICAgICAgIG51bU1hcmtlcnMgPSAobnVtTWFqb3JNYXJrZXJzLTEpKjIsXHJcbiAgICAgICAgICAgIG1hcmdpbiA9IDEwMC9udW1NYXJrZXJzLFxyXG4gICAgICAgICAgICBpc01ham9yID0gdHJ1ZSxcclxuICAgICAgICAgICAgaTtcclxuICAgICAgICBmb3IoIGkgPSAwOyBpPG51bU1hcmtlcnM7IGkrKyApIHtcclxuICAgICAgICAgICAgaWYgKCBpc01ham9yICkge1xyXG4gICAgICAgICAgICAgICAgJGNvbnRhaW5lci5hcHBlbmQoICc8ZGl2IGNsYXNzPVwiZmlsdGVyLWF4aXMtbWFya2VyIGZpbHRlci1tYWpvci1tYXJrZXJcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDpjYWxjKCcrbWFyZ2luKyclIC0gMXB4KTtcIj48L2Rpdj4nICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAkY29udGFpbmVyLmFwcGVuZCggJzxkaXYgY2xhc3M9XCJmaWx0ZXItYXhpcy1tYXJrZXIgZmlsdGVyLW1pbm9yLW1hcmtlclwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OmNhbGMoJyttYXJnaW4rJyUgLSAxcHgpO1wiPjwvZGl2PicgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpc01ham9yID0gIWlzTWFqb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICRjb250YWluZXIuYXBwZW5kKCAnPGRpdiBjbGFzcz1cImZpbHRlci1heGlzLW1hcmtlciBmaWx0ZXItbWFqb3ItbWFya2VyXCIgc3R5bGU9XCJtYXJnaW4tbGVmdDotMXB4O1wiPjwvZGl2PicgKTtcclxuICAgICAgICByZXR1cm4gJGNvbnRhaW5lcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVBeGlzTGFiZWxzKCBudW1NYWpvck1hcmtlcnMsIG1pbk1heCwgdHJhbnNmb3JtICl7XHJcbiAgICAgICAgdmFyICRjb250YWluZXIgPSAkKCc8ZGl2IGNsYXNzPVwiZmlsdGVyLWF4aXMtbGFiZWwtY29udGFpbmVyXCI+PC9kaXY+JyksXHJcbiAgICAgICAgICAgIG1hcmdpbiA9IDEwMC8obnVtTWFqb3JNYXJrZXJzLTEpLFxyXG4gICAgICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgJ3N0ZXBEb3duJyA6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAnZGVjaW1hbHMnIDogMSxcclxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2InXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHZhbCxcclxuICAgICAgICAgICAgaTtcclxuICAgICAgICBmb3IgKCBpID0gMDsgaTxudW1NYWpvck1hcmtlcnM7IGkrKyApIHtcclxuICAgICAgICAgICAgdmFsID0gVXRpbC5kZW5vcm1hbGl6ZVZhbHVlKCBpIC8gKG51bU1ham9yTWFya2Vycy0xKSwgbWluTWF4LCB0cmFuc2Zvcm0gKTtcclxuICAgICAgICAgICAgJGNvbnRhaW5lci5hcHBlbmQoXHJcbiAgICAgICAgICAgICAgICAkKCAnPGRpdiBjbGFzcz1cImZpbHRlci1heGlzLWxhYmVsXCIgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTsgbGVmdDonKyhtYXJnaW4qaSkrJyU7IHdpZHRoOicrbWFyZ2luKyclOyBtYXJnaW4tbGVmdDotJysobWFyZ2luLzIpKyclO1wiPicrXHJcbiAgICAgICAgICAgICAgICAgICAgICBBeGlzVXRpbC5mb3JtYXRUZXh0KCB2YWwsIG9wdGlvbnMgKSArXHJcbiAgICAgICAgICAgICAgICAgICc8L2Rpdj4nIClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICRjb250YWluZXI7XHJcbiAgICB9XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBmaWx0ZXIganF1ZXJ5LXVpIHNsaWRlciBhbmQgYmluZHMgaXQgdG8gdGhlIHByb3ZpZGVkIGxheWVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge0pRdWVyeX0gLSBUaGUgSlF1ZXJ5IGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiggbGF5ZXIgKSB7XHJcbiAgICAgICAgICAgIHZhciAkZmlsdGVyQ29udHJvbHMgPSAkKCAnPGRpdiBjbGFzcz1cImZpbHRlci1jb250cm9sc1wiPjwvZGl2PicgKSxcclxuICAgICAgICAgICAgICAgICRmaWx0ZXJMYWJlbCA9ICQoICc8ZGl2IGNsYXNzPVwiY29udHJvbHMtbGFiZWxcIj5GaWx0ZXI8L2Rpdj4nICksXHJcbiAgICAgICAgICAgICAgICAkc2xpZGVyQm9yZGVyID0gJCggJzxkaXYgY2xhc3M9XCJzbGlkZXItYm9yZGVyXCI+JyApLFxyXG4gICAgICAgICAgICAgICAgJGZpbHRlclNsaWRlciA9ICQoICc8ZGl2IGNsYXNzPVwiZmlsdGVyLXNsaWRlclwiPjwvZGl2PicgKSxcclxuICAgICAgICAgICAgICAgIE1JTl9WQUwgPSAwLFxyXG4gICAgICAgICAgICAgICAgTUFYX1ZBTCA9IDEwMDtcclxuICAgICAgICAgICAgJGZpbHRlclNsaWRlci5zbGlkZXIoe1xyXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBtaW46IE1JTl9WQUwsXHJcbiAgICAgICAgICAgICAgICBtYXg6IE1BWF9WQUwsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICBsYXllci5nZXRSYW5nZU1pblBlcmNlbnRhZ2UoKSAqIE1BWF9WQUwsXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZ2V0UmFuZ2VNYXhQZXJjZW50YWdlKCkgKiBNQVhfVkFMXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgY2hhbmdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICQoIHRoaXMgKS5zbGlkZXIoIFwib3B0aW9uXCIsIFwidmFsdWVzXCIgKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgYnkgcGVyY2VudGFnZVxyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnNldFJhbmdlTWluUGVyY2VudGFnZSggcmVzdWx0WzBdIC8gTUFYX1ZBTCApO1xyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnNldFJhbmdlTWF4UGVyY2VudGFnZSggcmVzdWx0WzFdIC8gTUFYX1ZBTCApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNsaWRlOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVJbmRleCA9ICQoIHVpLmhhbmRsZSApLmluZGV4KCkgLSAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB1aS52YWx1ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gVXRpbC5kZW5vcm1hbGl6ZVZhbHVlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzWyBoYW5kbGVJbmRleCBdIC8gTUFYX1ZBTCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLmdldExldmVsTWluTWF4KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllci5nZXRWYWx1ZVRyYW5zZm9ybVR5cGUoKSApO1xyXG4gICAgICAgICAgICAgICAgICAgIFNsaWRlclV0aWwuY3JlYXRlTGFiZWwoICQoICRmaWx0ZXJTbGlkZXJbMF0uY2hpbGRyZW5bIDEgKyBoYW5kbGVJbmRleCBdICksIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUluZGV4ID0gJCh1aS5oYW5kbGUpLmluZGV4KCkgLSAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB1aS52YWx1ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gVXRpbC5kZW5vcm1hbGl6ZVZhbHVlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzWyBoYW5kbGVJbmRleCBdIC8gTUFYX1ZBTCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLmdldExldmVsTWluTWF4KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllci5nZXRWYWx1ZVRyYW5zZm9ybVR5cGUoKSApO1xyXG4gICAgICAgICAgICAgICAgICAgIFNsaWRlclV0aWwuY3JlYXRlTGFiZWwoICQoICRmaWx0ZXJTbGlkZXJbMF0uY2hpbGRyZW5bIDEgKyBoYW5kbGVJbmRleCBdICksIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlSW5kZXggPSAkKHVpLmhhbmRsZSkuaW5kZXgoKSAtIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRoYW5kbGUgPSAkKCAkZmlsdGVyU2xpZGVyWzBdLmNoaWxkcmVuWyAxICsgaGFuZGxlSW5kZXggXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggISRoYW5kbGUuaXMoJzpob3ZlcicpICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWxseSB0aGlzIGxhYmVsIGlzIHJlbW92ZWQgb24gbW91c2Ugb3V0LCBpbiB0aGUgY2FzZSB0aGF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB1c2VyIGhhcyBtb3VzZWQgb3V0IHdoaWxlIGRyYWdnaW5nLCB0aGlzIHdpbGwgY2F1c2UgdGhlIGxhYmVsIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgU2xpZGVyVXRpbC5yZW1vdmVMYWJlbCggJGhhbmRsZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGJpbmQgc2xpZGVyIGxhYmVsIG1vdXNlb3ZlciBhbmQgbW91c2VvdXQgY2FsbGJhY2tzIHRvIGVhY2ggaGFuZGxlIG9mIHRoZSBzbGlkZXJcclxuICAgICAgICAgICAgJGZpbHRlclNsaWRlci5maW5kKCAnLnVpLXNsaWRlci1oYW5kbGUnICkuZWFjaCggZnVuY3Rpb24oIGluZGV4LCBlbGVtICkge1xyXG4gICAgICAgICAgICAgICAgJCggZWxlbSApLm1vdXNlb3ZlciggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gKCBpbmRleCA9PT0gMCApID8gbGF5ZXIuZ2V0UmFuZ2VNaW5WYWx1ZSgpIDogbGF5ZXIuZ2V0UmFuZ2VNYXhWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIFNsaWRlclV0aWwuY3JlYXRlTGFiZWwoICQoIHRoaXMgKSwgdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgJCggZWxlbSApLm1vdXNlb3V0KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBTbGlkZXJVdGlsLnJlbW92ZUxhYmVsKCAkKCB0aGlzICkgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgJGZpbHRlclNsaWRlci5hcHBlbmQoIGNyZWF0ZUZpbHRlckF4aXMoIGxheWVyLmdldExldmVsTWluTWF4KCksIGxheWVyLmdldFZhbHVlVHJhbnNmb3JtVHlwZSgpICkgKTtcclxuICAgICAgICAgICAgJGZpbHRlclNsaWRlci5maW5kKCAnLnVpLXNsaWRlci1oYW5kbGUnICkuZmlyc3QoKS5hZGRDbGFzcyggXCJmaWx0ZXItbWluLWhhbmRsZVwiICk7XHJcbiAgICAgICAgICAgICRmaWx0ZXJTbGlkZXIuZmluZCggJy51aS1zbGlkZXItaGFuZGxlJyApLmxhc3QoKS5hZGRDbGFzcyggXCJmaWx0ZXItbWF4LWhhbmRsZVwiICk7XHJcbiAgICAgICAgICAgICRmaWx0ZXJDb250cm9scy5hcHBlbmQoICRmaWx0ZXJMYWJlbCApO1xyXG4gICAgICAgICAgICAkZmlsdGVyQ29udHJvbHMuYXBwZW5kKCAkc2xpZGVyQm9yZGVyLmFwcGVuZCggJGZpbHRlclNsaWRlciApICk7XHJcbiAgICAgICAgICAgIFB1YlN1Yi5zdWJzY3JpYmUoIGxheWVyLmdldENoYW5uZWwoKSwgZnVuY3Rpb24oIG1lc3NhZ2UgKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKCBtZXNzYWdlLmZpZWxkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdyYW5nZU1pbic6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkZmlsdGVyU2xpZGVyLnNsaWRlciggJ3ZhbHVlcycsIDAsIGxheWVyLmdldFJhbmdlTWluUGVyY2VudGFnZSgpICogTUFYX1ZBTCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFuZ2VNYXgnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgJGZpbHRlclNsaWRlci5zbGlkZXIoICd2YWx1ZXMnLCAxLCBsYXllci5nZXRSYW5nZU1heFBlcmNlbnRhZ2UoKSAqIE1BWF9WQUwgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhbXBJbWFnZVVybCc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkZmlsdGVyU2xpZGVyLmZpbmQoIFwiLnVpLXNsaWRlci1yYW5nZVwiICkuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZFwiOiBcInVybChcIiArIG1lc3NhZ2UudmFsdWUgKyBcIilcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1zaXplXCI6IFwiY29udGFpblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGV2ZWxNaW5NYXgnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgJGZpbHRlclNsaWRlci5maW5kKCBcIi5maWx0ZXItYXhpc1wiICkucmVwbGFjZVdpdGgoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVGaWx0ZXJBeGlzKCBsYXllci5nZXRMZXZlbE1pbk1heCgpLCBsYXllci5nZXRWYWx1ZVRyYW5zZm9ybVR5cGUoKSApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuICRmaWx0ZXJDb250cm9scztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICogXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICogXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqIFxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICogXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIExheWVyRW50cnkgPSByZXF1aXJlKCcuL0xheWVyRW50cnknKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbWluaW1hbCBsYXllciBjb250cm9scyBVSSBjb21wb25lbnQgYW5kIGJpbmRzIGl0IHRvIGFsbCBwcm92aWRlZCBsYXllcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBsYXllcnMgLSBUaGUgYXJyYXkgb2YgbGF5ZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge0pRdWVyeX0gVGhlIGxheWVycyBjb250cm9sIGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24oIGxheWVycyApIHtcclxuICAgICAgICAgICAgdmFyICRjb250cm9scyA9ICQoICc8ZGl2IGNsYXNzPVwidGlsZXMtbGF5ZXItY29udHJvbHNcIj48L2Rpdj4nICk7XHJcbiAgICAgICAgICAgIF8uZm9yRWFjaCggbGF5ZXJzLCBmdW5jdGlvbiggbGF5ZXIgKSB7XHJcbiAgICAgICAgICAgICAgICAkY29udHJvbHMuYXBwZW5kKCBMYXllckVudHJ5LmNyZWF0ZSggbGF5ZXIgKSApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuICRjb250cm9scztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxufSgpKTsiLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKiBcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKiBcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICogXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKiBcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgTGF5ZXJFbnRyeUhlYWQgPSByZXF1aXJlKCcuL0xheWVyRW50cnlIZWFkJyksXHJcbiAgICAgICAgTGF5ZXJFbnRyeUJvZHkgPSByZXF1aXJlKCcuL0xheWVyRW50cnlCb2R5JyksXHJcbiAgICAgICAgUHViU3ViID0gcmVxdWlyZSgnLi4vdXRpbC9QdWJTdWInKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyB0aGUgVUkgY29tcG9uZW50IHRoYXQgaG9sZHMgdGhlIGNvbnRyb2xzIGhlYWRlciBhbmQgYm9keSBmb3IgYSBsYXllci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gVGhlIGxheWVyIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtKUXVlcnl9IC0gVGhlIEpRdWVyeSBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24oIGxheWVyICkge1xyXG4gICAgICAgICAgICB2YXIgJGxheWVyRW50cnkgPSAkKCAnPGRpdiBjbGFzcz1cImxheWVyLWVudHJ5XCI+PC9kaXY+JyApLFxyXG4gICAgICAgICAgICAgICAgJGxheWVySGVhZGVyID0gTGF5ZXJFbnRyeUhlYWQuY3JlYXRlKCBsYXllciApLFxyXG4gICAgICAgICAgICAgICAgJGxheWVyQm9keSA9IExheWVyRW50cnlCb2R5LmNyZWF0ZSggbGF5ZXIgKTtcclxuICAgICAgICAgICAgUHViU3ViLnN1YnNjcmliZSggbGF5ZXIuZ2V0Q2hhbm5lbCgpLCBmdW5jdGlvbiggbWVzc2FnZSApIHtcclxuICAgICAgICAgICAgICAgIGlmICggbWVzc2FnZS5maWVsZCA9PT0gXCJlbmFibGVkXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtZXNzYWdlLnZhbHVlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkbGF5ZXJCb2R5LmNzcyggJ2Rpc3BsYXknLCBcIlwiICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGxheWVyQm9keS5jc3MoICdkaXNwbGF5JywgXCJub25lXCIgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIGxheWVyLmlzRW5hYmxlZCgpICkge1xyXG4gICAgICAgICAgICAgICAgJGxheWVyQm9keS5jc3MoICdkaXNwbGF5JywgXCJcIiApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgJGxheWVyQm9keS5jc3MoICdkaXNwbGF5JywgXCJub25lXCIgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAkbGF5ZXJFbnRyeS5hcHBlbmQoICRsYXllckhlYWRlciApO1xyXG4gICAgICAgICAgICAkbGF5ZXJFbnRyeS5hcHBlbmQoICRsYXllckJvZHkgKTtcclxuICAgICAgICAgICAgcmV0dXJuICRsYXllckVudHJ5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxufSgpKTsiLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKiBcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKiBcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICogXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKiBcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgT3BhY2l0eUNvbnRyb2xzID0gcmVxdWlyZSgnLi9PcGFjaXR5Q29udHJvbHMnKSxcclxuICAgICAgICBGaWx0ZXJDb250cm9scyA9IHJlcXVpcmUoJy4vRmlsdGVyQ29udHJvbHMnKSxcclxuICAgICAgICBDb2Fyc2VuZXNzQ29udHJvbHMgPSByZXF1aXJlKCcuL0NvYXJzZW5lc3NDb250cm9scycpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIHRoZSBVSSBjb21wb25lbnQgdGhhdCBob2xkcyB0aGUgY29udHJvbHMgZm9yIGEgbGF5ZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0xheWVyfSBsYXllciAtIFRoZSBsYXllciBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7SlF1ZXJ5fSAtIFRoZSBKUXVlcnkgZWxlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uKCBsYXllciApIHtcclxuICAgICAgICAgICAgdmFyICRlbnRyeUJvZHkgPSAkKCAnPGRpdiBjbGFzcz1cImxheWVyLWVudHJ5LWJvZHlcIj48L2Rpdj4nICk7XHJcbiAgICAgICAgICAgIGlmICggbGF5ZXIuZG9tYWluID09PSBcImNsaWVudFwiIHx8IGxheWVyLmRvbWFpbiA9PT0gXCJhbm5vdGF0aW9uXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAkZW50cnlCb2R5LmFwcGVuZCggT3BhY2l0eUNvbnRyb2xzLmNyZWF0ZSggbGF5ZXIgKS5hZGRDbGFzcyggJ29wYWNpdHktY29udHJvbHMtY2xpZW50JyApICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAkZW50cnlCb2R5LmFwcGVuZCggT3BhY2l0eUNvbnRyb2xzLmNyZWF0ZSggbGF5ZXIgKS5hZGRDbGFzcyggJ29wYWNpdHktY29udHJvbHMtc2VydmVyJyApICk7XHJcbiAgICAgICAgICAgICAgICAkZW50cnlCb2R5LmFwcGVuZCggRmlsdGVyQ29udHJvbHMuY3JlYXRlKCBsYXllciApICk7XHJcbiAgICAgICAgICAgICAgICAkZW50cnlCb2R5LmFwcGVuZCggQ29hcnNlbmVzc0NvbnRyb2xzLmNyZWF0ZSggbGF5ZXIgKSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICRlbnRyeUJvZHkuYXBwZW5kKCAnPGRpdiBjbGFzcz1cImNsZWFyXCI+PC9kaXY+Jyk7XHJcbiAgICAgICAgICAgIHJldHVybiAkZW50cnlCb2R5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxufSgpKTsiLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgT2N1bHVzIEluZm8gSW5jLlxyXG4gKiBodHRwOi8vd3d3Lm9jdWx1c2luZm8uY29tL1xyXG4gKiBcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKiBcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICogXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKiBcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgUHViU3ViID0gcmVxdWlyZSgnLi4vdXRpbC9QdWJTdWInKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyB0aGUgVUkgY29tcG9uZW50IHRoYXQgaG9sZHMgdGhlIGxheWVyIGNvbnRyb2xzIGhlYWRlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gVGhlIGxheWVyIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtKUXVlcnl9IC0gVGhlIEpRdWVyeSBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24oIGxheWVyICkge1xyXG4gICAgICAgICAgICB2YXIgRU5BQkxFRF9DTEFTUyA9ICdmYS1jaGVjay1zcXVhcmUtbycsXHJcbiAgICAgICAgICAgICAgICBESVNBQkxFRF9DTEFTUyA9ICdmYS1zcXVhcmUtbycsXHJcbiAgICAgICAgICAgICAgICBpY29uQ2xhc3MgPSBsYXllci5pc0VuYWJsZWQoKSA/IEVOQUJMRURfQ0xBU1MgOiBESVNBQkxFRF9DTEFTUyxcclxuICAgICAgICAgICAgICAgICRsYXllckhlYWRlciA9ICQoICc8ZGl2IGNsYXNzPVwibGF5ZXItZW50cnktaGVhZFwiPjwvZGl2PicgKSxcclxuICAgICAgICAgICAgICAgICRsYXllclRvZ2dsZUljb24gPSAkKCAnPGkgY2xhc3M9XCJmYSAnK2ljb25DbGFzcysnXCI+PC9pPicpLFxyXG4gICAgICAgICAgICAgICAgJGxheWVyVG9nZ2xlQnV0dG9uID0gJCgnPGRpdiBjbGFzcz1cImxheWVyLXRvZ2dsZVwiPjwvZGl2PicpLFxyXG4gICAgICAgICAgICAgICAgJGxheWVyVGl0bGUgPSAkKCAnPGRpdiBjbGFzcz1cImxheWVyLXRpdGxlXCI+JytsYXllci5zb3VyY2UubmFtZSsnPC9kaXY+Jyk7XHJcblxyXG4gICAgICAgICAgICAkbGF5ZXJIZWFkZXIuY2xpY2soIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBsYXllci5pc0VuYWJsZWQoKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXllci5zZXRFbmFibGVkKCBmYWxzZSApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXllci5zZXRFbmFibGVkKCB0cnVlICk7XHJcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFB1YlN1Yi5zdWJzY3JpYmUoIGxheWVyLmdldENoYW5uZWwoKSwgZnVuY3Rpb24oIG1lc3NhZ2UgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIG1lc3NhZ2UuZmllbGQgPT09IFwiZW5hYmxlZFwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWVzc2FnZS52YWx1ZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGxheWVyVG9nZ2xlSWNvbi5yZW1vdmVDbGFzcyggRElTQUJMRURfQ0xBU1MgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGxheWVyVG9nZ2xlSWNvbi5hZGRDbGFzcyggRU5BQkxFRF9DTEFTUyApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRsYXllclRvZ2dsZUljb24ucmVtb3ZlQ2xhc3MoIEVOQUJMRURfQ0xBU1MgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGxheWVyVG9nZ2xlSWNvbi5hZGRDbGFzcyggRElTQUJMRURfQ0xBU1MgKTtcclxuICAgICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgJGxheWVySGVhZGVyLmFwcGVuZCggJGxheWVyVG9nZ2xlQnV0dG9uLmFwcGVuZCggJGxheWVyVG9nZ2xlSWNvbiApICk7XHJcbiAgICAgICAgICAgICRsYXllckhlYWRlci5hcHBlbmQoICRsYXllclRpdGxlICk7XHJcbiAgICAgICAgICAgIHJldHVybiAkbGF5ZXJIZWFkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbn0oKSk7IiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IE9jdWx1cyBJbmZvIEluYy5cclxuICogaHR0cDovL3d3dy5vY3VsdXNpbmZvLmNvbS9cclxuICogXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICogXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXHJcbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXHJcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xyXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqIFxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICogXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIFNsaWRlclV0aWwgPSByZXF1aXJlKCcuL1NsaWRlclV0aWwnKSxcclxuICAgICAgICBQdWJTdWIgPSByZXF1aXJlKCcuLi91dGlsL1B1YlN1YicpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuIG9wYWNpdHkganF1ZXJ5LXVpIHNsaWRlciBhbmQgYmluZHMgaXQgdG8gdGhlIHByb3ZpZGVkIGxheWVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge0pRdWVyeX0gLSBUaGUgSlF1ZXJ5IGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiggbGF5ZXIgKSB7XHJcbiAgICAgICAgICAgIHZhciAkb3BhY2l0eUNvbnRyb2xzID0gJCggJzxkaXYgY2xhc3M9XCJvcGFjaXR5LWNvbnRyb2xzXCI+PC9kaXY+JyApLFxyXG4gICAgICAgICAgICAgICAgJG9wYWNpdHlMYWJlbCA9ICQoICc8ZGl2IGNsYXNzPVwiY29udHJvbHMtbGFiZWxcIj5PcGFjaXR5PC9kaXY+JyApLFxyXG4gICAgICAgICAgICAgICAgJHNsaWRlckJvcmRlciA9ICQoICc8ZGl2IGNsYXNzPVwic2xpZGVyLWJvcmRlclwiPicgKSxcclxuICAgICAgICAgICAgICAgICRvcGFjaXR5U2xpZGVyID0gJCggJzxkaXYgY2xhc3M9XCJvcGFjaXR5LXNsaWRlclwiPjwvZGl2PicgKSxcclxuICAgICAgICAgICAgICAgIE1JTl9WQUwgPSAwLFxyXG4gICAgICAgICAgICAgICAgTUFYX1ZBTCA9IDEwMDtcclxuICAgICAgICAgICAgJG9wYWNpdHlTbGlkZXIuc2xpZGVyKHtcclxuICAgICAgICAgICAgICAgIHJhbmdlOiBcIm1pblwiLFxyXG4gICAgICAgICAgICAgICAgbWluOiBNSU5fVkFMLFxyXG4gICAgICAgICAgICAgICAgbWF4OiBNQVhfVkFMLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxheWVyLmdldE9wYWNpdHkoKSAqIE1BWF9WQUwsXHJcbiAgICAgICAgICAgICAgICBzbGlkZTogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcclxuICAgICAgICAgICAgICAgICAgICAkKCAnLm9sVGlsZUltYWdlJyApLmFkZENsYXNzKCAnbm8tdHJhbnNpdGlvbicgKTtcclxuICAgICAgICAgICAgICAgICAgICAkKCAnLm9sVGlsZUh0bWwnICkuYWRkQ2xhc3MoICduby10cmFuc2l0aW9uJyApO1xyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnNldE9wYWNpdHkoIHVpLnZhbHVlIC8gTUFYX1ZBTCApO1xyXG4gICAgICAgICAgICAgICAgICAgIFNsaWRlclV0aWwuY3JlYXRlTGFiZWwoICQoIHRoaXMgKS5maW5kKFwiLnVpLXNsaWRlci1oYW5kbGVcIiksIHVpLnZhbHVlIC8gTUFYX1ZBTCApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIFNsaWRlclV0aWwuY3JlYXRlTGFiZWwoICQoIHRoaXMgKS5maW5kKFwiLnVpLXNsaWRlci1oYW5kbGVcIiksIHVpLnZhbHVlIC8gTUFYX1ZBTCApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAkaGFuZGxlID0gJCggdGhpcyApLmZpbmQoXCIudWktc2xpZGVyLWhhbmRsZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoICEkaGFuZGxlLmlzKCc6aG92ZXInKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsbHkgdGhpcyBsYWJlbCBpcyByZW1vdmVkIG9uIG1vdXNlIG91dCwgaW4gdGhlIGNhc2UgdGhhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdXNlciBoYXMgbW91c2VkIG91dCB3aGlsZSBkcmFnZ2luZywgdGhpcyB3aWxsIGNhdXNlIHRoZSBsYWJlbCB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiZSByZW1vdmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNsaWRlclV0aWwucmVtb3ZlTGFiZWwoICRoYW5kbGUgKTtcclxuICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAkKCAnLm9sVGlsZUltYWdlJyApLnJlbW92ZUNsYXNzKCAnbm8tdHJhbnNpdGlvbicgKTtcclxuICAgICAgICAgICAgICAgICAgICAkKCAnLm9sVGlsZUh0bWwnICkucmVtb3ZlQ2xhc3MoICduby10cmFuc2l0aW9uJyApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTsgICBcclxuICAgICAgICAgICAgLy8gYmluZCBzbGlkZXIgbGFiZWwgbW91c2VvdmVyIGFuZCBtb3VzZW91dCBjYWxsYmFja3NcclxuICAgICAgICAgICAgJG9wYWNpdHlTbGlkZXIuZmluZCggXCIudWktc2xpZGVyLWhhbmRsZVwiICkubW91c2VvdmVyKCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIFNsaWRlclV0aWwuY3JlYXRlTGFiZWwoICQoIHRoaXMgKSwgbGF5ZXIuZ2V0T3BhY2l0eSgpICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAkb3BhY2l0eVNsaWRlci5maW5kKCBcIi51aS1zbGlkZXItaGFuZGxlXCIgKS5tb3VzZW91dCggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBTbGlkZXJVdGlsLnJlbW92ZUxhYmVsKCAkKCB0aGlzICkgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFB1YlN1Yi5zdWJzY3JpYmUoIGxheWVyLmdldENoYW5uZWwoKSwgZnVuY3Rpb24oIG1lc3NhZ2UgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIG1lc3NhZ2UuZmllbGQgPT09IFwib3BhY2l0eVwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICRvcGFjaXR5U2xpZGVyLnNsaWRlcigndmFsdWUnLCBsYXllci5nZXRPcGFjaXR5KCkqTUFYX1ZBTCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgJG9wYWNpdHlDb250cm9scy5hcHBlbmQoICRvcGFjaXR5TGFiZWwgKTtcclxuICAgICAgICAgICAgJG9wYWNpdHlDb250cm9scy5hcHBlbmQoICRzbGlkZXJCb3JkZXIuYXBwZW5kKCAkb3BhY2l0eVNsaWRlciApICk7XHJcbiAgICAgICAgICAgIHJldHVybiAkb3BhY2l0eUNvbnRyb2xzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG59KCkpOyIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHZhciBBeGlzVXRpbCA9IHJlcXVpcmUoJy4uL21hcC9BeGlzVXRpbCcpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuZCBhcHBlbmRzIGEgbGFiZWwgdG8gdGhlIHN1cHBsaWVkIGVsZW1lbnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSBUaGUgZWxlbWVudCB0byB3aGljaCB0aGUgbGFiZWwgaXMgYXBwZW5kZWQgb250by5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbiBvbiB0aGUgbGFiZWwuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlTGFiZWw6IGZ1bmN0aW9uKCAkZWxlbSwgdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICdzdGVwRG93bicgOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICdkZWNpbWFscycgOiAyLFxyXG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2InXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgJGxhYmVsID0gJCgnPGRpdiBjbGFzcz1cImhvdmVyLWxhYmVsXCIgc3R5bGU9XCJsZWZ0OicrICgkZWxlbS53aWR0aCgpLzIpICsncHg7IHRvcDowcHg7XCI+JytcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJob3Zlci1sYWJlbC10ZXh0XCI+JysgQXhpc1V0aWwuZm9ybWF0VGV4dCggdmFsdWUsIG9wdGlvbnMgKSArJzwvZGl2PicrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nKTtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIHByZXZpb3VzIGxhYmVsIGlmIGl0IGV4aXN0c1xyXG4gICAgICAgICAgICAkZWxlbS5maW5kKCcuaG92ZXItbGFiZWwnKS5maW5pc2goKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgLy8gYWRkIG5ldyBsYWJlbFxyXG4gICAgICAgICAgICAkZWxlbS5hcHBlbmQoICRsYWJlbCApO1xyXG4gICAgICAgICAgICAvLyByZXBvc2l0aW9uIHRvIGJlIGNlbnRyZWQgYWJvdmUgY3Vyc29yXHJcbiAgICAgICAgICAgICRsYWJlbC5jc3MoIHtcIm1hcmdpbi10b3BcIjogLSRsYWJlbC5vdXRlckhlaWdodCgpKjEuMiwgXCJtYXJnaW4tbGVmdFwiOiAtJGxhYmVsLm91dGVyV2lkdGgoKS8yIH0gKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGEgbGFiZWwgZnJvbSB0aGUgZWxlbWVudC4gRmFkZXMgdGhlIGVsZW1lbnQgb3V0IGZpcnN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gVGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGxhYmVsIGlzIGFwcGVuZGVkIG9udG8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVtb3ZlTGFiZWw6IGZ1bmN0aW9uKCAkZWxlbSApIHtcclxuICAgICAgICAgICAgJGVsZW0uZmluZCgnLmhvdmVyLWxhYmVsJykuYW5pbWF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRlbGVtLmZpbmQoJy5ob3Zlci1sYWJlbCcpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDgwMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgUHViU3ViXHJcbiAqIEBjbGFzc2Rlc2MgQSBoaWVyYXJjaGljYWwgcHVibGlzaCBhbmQgc3Vic2NyaWJlIG5hbWVzcGFjZS4gQ2hhbm5lbHMgY29uc2lzdCBvZiBzdHJpbmdzLCBzdWItY2hhbm5lbHNcclxuICogYXJlIHNlcGFyYXRlZCB3aXRoIGEgcGVyaW9kICgnLicpLiBQdWJsaXNoaW5nIHRvIGEgdGFyZ2V0IGNoYW5uZWwgd2lsbCBwcm9wYWdhdGUgdGhlIG1lc3NhZ2VcclxuICogYnJlYWR0aCBmaXJzdCBmcm9tIHRoZSByb290IG9mIHRoZSBoaWVyYXJjaHkgdG8gdGhlIHRhcmdldCBjaGFubmVsLCB0aGVuIGZyb20gdGhlIHRhcmdldCBjaGFubmVsIHRvXHJcbiAqIGFsbCBpdHMgZXhpc3Rpbmcgc3ViLWNoYW5uZWxzLlxyXG4gKiA8cHJlPlxyXG4gKiBFeC5cclxuICpcclxuICogICAgIEhpZXJhcmNoeTpcclxuICpcclxuICogICAgICAgICBsYXllciAtPiBzZXJ2ZXIgLT4gYWJjMjhkMDUtOWI5ZC00ZTAzLTlmNTMtOWY4OGNmNzA3OGM3XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZiOTQzY2NhLWNhYzMtNGJiZi1iYTAzLTkxYTE1NTlmZWUyOFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA2N2ZkNTViNS1kYzNhLTQwY2YtOGFkYy05ZTYzNGI4MmQ0NzRcclxuICogICAgICAgICAgICAgICAgICBjbGllbnQgLT4gMzM5MjEwM2YtN2Y1MC00NDIyLWFlNTktMmMyYzA5NzE5NTFmXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDdiYzMzYzgxLWMzNDctNGJlYS05Y2ZiLWMyMjMyOGJjYjY0OFxyXG4gKlxyXG4gKiAgICAgUHVibGlzaGluZyB0byAnbGF5ZXIuc2VydmVyJyB3aWxsIHB1Ymxpc2g6XHJcbiAqXHJcbiAqICAgICAgICAgRnJvbSByb290IHRvIHRhcmdldDpcclxuICpcclxuICogICAgICAgICAgICAgMSkgbGF5ZXJcclxuICpcclxuICogICAgIEZyb20gdGFyZ2V0IHRvIGFsbCBzdWItY2hhbm5lbHM6XHJcbiAqXHJcbiAqICAgICAgICAgICAgIDIpIGxheWVyLnNlcnZlclxyXG4gKiAgICAgICAgICAgICAzKSBsYXllci5zZXJ2ZXIuYWJjMjhkMDUtOWI5ZC00ZTAzLTlmNTMtOWY4OGNmNzA3OGM3XHJcbiAqICAgICAgICAgICAgIDQpIGxheWVyLnNlcnZlci5mYjk0M2NjYS1jYWMzLTRiYmYtYmEwMy05MWExNTU5ZmVlMjhcclxuICogICAgICAgICAgICAgNSkgbGF5ZXIuc2VydmVyLjY3ZmQ1NWI1LWRjM2EtNDBjZi04YWRjLTllNjM0YjgyZDQ3NFxyXG4gKlxyXG4gKiAgICAgUHVibGlzaGluZyB0byAnbGF5ZXIuY2xpZW50LjMzOTIxMDNmLTdmNTAtNDQyMi1hZTU5LTJjMmMwOTcxOTUxZicgd2lsbCBwdWJsaXNoOlxyXG4gKlxyXG4gKiAgICAgICAgIEZyb20gcm9vdCB0byB0YXJnZXQ6XHJcbiAqXHJcbiAqICAgICAgICAgICAgIDEpIGxheWVyXHJcbiAqICAgICAgICAgICAgIDIpIGxheWVyLmNsaWVudFxyXG4gKlxyXG4gKiAgICAgICAgIEZyb20gdGFyZ2V0IHRvIGFsbCBzdWItY2hhbm5lbHM6XHJcbiAqXHJcbiAqICAgICAgICAgICAgIDMpIGxheWVyLmNsaWVudC4zMzkyMTAzZi03ZjUwLTQ0MjItYWU1OS0yYzJjMDk3MTk1MWZcclxuICogPC9wcmU+XHJcbiAqL1xyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNoYW5uZWwoIHBhdGggKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcGF0aCA6IHBhdGgsXHJcbiAgICAgICAgICAgIHN1YnNjcmliZXJzIDogW10sXHJcbiAgICAgICAgICAgIGNoaWxkcmVuIDoge31cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdWJzY3JpYmUgYSBsaXN0ZW5lciBmdW5jdGlvbiB0byB0aGUgc3BlY2lmaWMgY2hhbm5lbCBwYXRoLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQdWJTdWJcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBjaGFubmVsUGF0aCB7c3RyaW5nfSAgIEEgJy4nIGRlbGltaXRlZCBjaGFubmVsIHBhdGguXHJcbiAgICAgICAgICogQHBhcmFtIHN1YnNjcmliZXIgIHtGdW5jdGlvbn0gVGhlIHN1YnNjcmliZXIgZnVuY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBwYXRoLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24oIGNoYW5uZWxQYXRoLCBzdWJzY3JpYmVyICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHBhdGhzID0gY2hhbm5lbFBhdGguc3BsaXQoJy4nKSxcclxuICAgICAgICAgICAgICAgIHBhdGgsXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGF0aCA9ICcnLFxyXG4gICAgICAgICAgICAgICAgY2hhbm5lbDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzIHx8IHtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzIDogW10sXHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA6IHt9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBjaGFubmVsID0gdGhpcy5jaGFubmVscztcclxuXHJcbiAgICAgICAgICAgIHdoaWxlICggcGF0aHMubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRocy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhdGggKz0gKCBjdXJyZW50UGF0aC5sZW5ndGggPiAwICkgPyAnLicgKyBwYXRoIDogcGF0aDtcclxuICAgICAgICAgICAgICAgIGlmICggIWNoYW5uZWwuY2hpbGRyZW5bIHBhdGggXSApIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNoaWxkcmVuWyBwYXRoIF0gPSBjcmVhdGVDaGFubmVsKCBjdXJyZW50UGF0aCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2hhbm5lbCA9IGNoYW5uZWwuY2hpbGRyZW5bIHBhdGggXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGFubmVsLnN1YnNjcmliZXJzLnB1c2goIHN1YnNjcmliZXIgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbnN1YnNjcmliZSBhIGxpc3RlbmVyIGZ1bmN0aW9uIGZyb20gdGhlIHNwZWNpZmljIGNoYW5uZWwgcGF0aC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgUHViU3ViXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gY2hhbm5lbFBhdGgge3N0cmluZ30gICBBICcuJyBkZWxpbWl0ZWQgY2hhbm5lbCBwYXRoLlxyXG4gICAgICAgICAqIEBwYXJhbSBzdWJzY3JpYmVyICB7RnVuY3Rpb259IFRoZSBzdWJzY3JpYmVyIGZ1bmN0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgcGF0aC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24oIGNoYW5uZWxQYXRoLCBzdWJzY3JpYmVyICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHBhdGhzID0gY2hhbm5lbFBhdGguc3BsaXQoJy4nKSxcclxuICAgICAgICAgICAgICAgIHBhdGgsXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGF0aCA9ICcnLFxyXG4gICAgICAgICAgICAgICAgY2hhbm5lbDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzIHx8IHtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzIDogW10sXHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA6IHt9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBjaGFubmVsID0gdGhpcy5jaGFubmVscztcclxuXHJcbiAgICAgICAgICAgIHdoaWxlICggcGF0aHMubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRocy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhdGggKz0gKCBjdXJyZW50UGF0aC5sZW5ndGggPiAwICkgPyAnLicgKyBwYXRoIDogcGF0aDtcclxuICAgICAgICAgICAgICAgIGlmICggIWNoYW5uZWwuY2hpbGRyZW5bIHBhdGggXSApIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNoaWxkcmVuWyBwYXRoIF0gPSBjcmVhdGVDaGFubmVsKCBjdXJyZW50UGF0aCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2hhbm5lbCA9IGNoYW5uZWwuY2hpbGRyZW5bIHBhdGggXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBjaGFubmVsLnN1YnNjcmliZXJzLmluZGV4T2YoIHN1YnNjcmliZXIgKTtcclxuICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gLTEgKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsLnN1YnNjcmliZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFB1Ymxpc2ggYSBtZXNzYWdlIHRvIGEgY2hhbm5lbCBwYXRoLiBQdWJsaXNoaW5nIHRvIGEgdGFyZ2V0IGNoYW5uZWwgd2lsbCBwcm9wYWdhdGUgdGhlIG1lc3NhZ2VcclxuICAgICAgICAgKiBicmVhZHRoIGZpcnN0IGZyb20gdGhlIHJvb3Qgb2YgdGhlIGhpZXJhcmNoeSB0byB0aGUgdGFyZ2V0IGNoYW5uZWwsIHRoZW4gZnJvbSB0aGUgdGFyZ2V0IGNoYW5uZWxcclxuICAgICAgICAgKiB0byBhbGwgZXhpc3Rpbmcgc3ViLWNoYW5uZWxzXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFB1YlN1YlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGNoYW5uZWxQYXRoIHtzdHJpbmd9ICAgQSAnLicgZGVsaW1pdGVkIGNoYW5uZWwgcGF0aC5cclxuICAgICAgICAgKiBAcGFyYW0gbWVzc2FnZSAgeyp9ICAgICAgIFRoZSBtZXNzc2FnZSB0byBiZSBwdWJsaXNoZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVibGlzaDogZnVuY3Rpb24oIGNoYW5uZWxQYXRoLCBtZXNzYWdlICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHBhdGhzID0gY2hhbm5lbFBhdGguc3BsaXQoJy4nKSxcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnMsXHJcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IFtdLFxyXG4gICAgICAgICAgICAgICAgcGF0aCwgaSwgc3ViLFxyXG4gICAgICAgICAgICAgICAgbGVhZkNoYW5uZWwsXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGF0aCA9ICcnLFxyXG4gICAgICAgICAgICAgICAgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMgfHwge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzIDogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gOiB7fVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIGZpbmQgY2hhbm5lbFxyXG4gICAgICAgICAgICB3aGlsZSAoIHBhdGhzLmxlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXRoICs9ICggY3VycmVudFBhdGgubGVuZ3RoID4gMCApID8gJy4nICsgcGF0aCA6IHBhdGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoICFjaGFubmVsLmNoaWxkcmVuWyBwYXRoIF0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5jaGlsZHJlblsgcGF0aCBdID0gY3JlYXRlQ2hhbm5lbCggY3VycmVudFBhdGggKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBjaGFubmVsLmNoaWxkcmVuWyBwYXRoIF07XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKCBjaGFubmVsICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxlYWZDaGFubmVsID0gcXVldWUucG9wKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBicmVhZHRoIGZpcnN0IHB1Ymxpc2hpbmcgZnJvbSByb290IHRvIHRhcmdldFxyXG4gICAgICAgICAgICB3aGlsZSAoIHF1ZXVlLmxlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsID0gcXVldWUuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzID0gY2hhbm5lbC5zdWJzY3JpYmVycztcclxuICAgICAgICAgICAgICAgIC8vIHB1Ymxpc2ggdG8gY3VycmVudCBjaGFubmVsXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBpPTA7IGk8c3Vic2NyaWJlcnMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnNbaV0oIG1lc3NhZ2UsIGNoYW5uZWxQYXRoICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHF1ZXVlID0gWyBsZWFmQ2hhbm5lbCBdO1xyXG5cclxuICAgICAgICAgICAgLy8gYnJlYWR0aCBmaXJzdCBwdWJsaXNoaW5nIGZyb20gdGFyZ2V0IHRvIGFsbCBjaGlsZHJlblxyXG4gICAgICAgICAgICB3aGlsZSAoIHF1ZXVlLmxlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsID0gcXVldWUuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzID0gY2hhbm5lbC5zdWJzY3JpYmVycztcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gY2hhbm5lbC5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIC8vIHB1Ymxpc2ggdG8gY3VycmVudCBjaGFubmVsXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBpPTA7IGk8c3Vic2NyaWJlcnMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnNbaV0oIG1lc3NhZ2UsIGNoYW5uZWxQYXRoICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZSB1cCBjaGlsZHJlbiBmb3IgbGVhZiBjaGFubmVsXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBzdWIgaW4gY2hpbGRyZW4gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eSggc3ViICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goIGNoaWxkcmVuWyBzdWIgXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0oKSk7XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBPY3VsdXMgSW5mbyBJbmMuXHJcbiAqIGh0dHA6Ly93d3cub2N1bHVzaW5mby5jb20vXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXHJcbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcclxuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXHJcbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuICogU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgdXRpbGl0eSBuYW1lc3BhY2UgY29udGFpbmluZyBjb21tb25seSB1c2VkIGZ1bmN0aW9uYWxpdHkuXHJcbiAqL1xyXG4oIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBwcm9wYWdhdGVFdmVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByaXZhdGU6IEEgcHJvcGFnYXRpb24gaGFuZGxlciB0aGF0IHdpbGwgdGVtcG9yYXJpbHkgZGUtYWN0aXZhdGUgdGhlXHJcbiAgICAgKiBET00gZWxlbWVudCBhbmQgcHJvcGFnYXRlIHRoZSBldmVudCB0aHJvdWdoIHRvIGFueSB1bmRlcmx5aW5nIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgZXZlbnQgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBwcm9wYWdhdGVFdmVudCA9IGZ1bmN0aW9uKCBldmVudCApIHtcclxuICAgICAgICB2YXIgbmV3RXZlbnQgPSBuZXcgZXZlbnQuY29uc3RydWN0b3IoIGV2ZW50LnR5cGUsIGV2ZW50ICksXHJcbiAgICAgICAgICAgIGVsZW1lbnQsXHJcbiAgICAgICAgICAgIGJlZm9yZSxcclxuICAgICAgICAgICAgYmVsb3c7XHJcbiAgICAgICAgZWxlbWVudCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XHJcbiAgICAgICAgYmVmb3JlID0gZWxlbWVudC5zdHlsZVsncG9pbnRlci1ldmVudHMnXTtcclxuICAgICAgICBlbGVtZW50LnN0eWxlWydwb2ludGVyLWV2ZW50cyddID0gJ25vbmUnO1xyXG4gICAgICAgIGJlbG93ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xyXG4gICAgICAgIGlmICggYmVsb3cgKSB7XHJcbiAgICAgICAgICAgIGJlbG93LmRpc3BhdGNoRXZlbnQoIG5ld0V2ZW50ICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnQuc3R5bGVbJ3BvaW50ZXItZXZlbnRzJ10gPSBiZWZvcmU7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZW5lcmF0ZXMgYW4gUkZDNDEyMiB2ZXJzaW9uIDQgY29tcGxpYW50IFVVSUQgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZW5lcmF0ZVV1aWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkqMTZ8MCwgdiA9IChjID09PSAneCcpID8gciA6IChyJjB4M3wweDgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGxvd3MgdGhlIGdpdmVuIERPTSBlbGVtZW50IG9yIGpRdWVyeSBvYmplY3QgZXZlbnRzIHRvIHByb3BhZ2F0ZSB0aHJvdWdoXHJcbiAgICAgICAgICogYW5kIGludGVyYWN0IHdpdGggdW5kZXJseWluZyBlbGVtZW50c1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGVsZW0gICAgIHtIVE1MRWxlbWVudCB8IGpRdWVyeX0gVGhlIERPTSBlbGVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSBbZXZlbnRzXSB7QXJyYXl9ICAgICAgICAgICAgICAgICBBcnJheSBvZiBldmVudHMgdG8gcHJvcGFnYXRlIHRocm91Z2ggKG9wdGlvbmFsKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBlbmFibGVFdmVudFByb3BhZ2F0aW9uOiBmdW5jdGlvbiggZWxlbSwgZXZlbnRzICkge1xyXG4gICAgICAgICAgICB2YXIgZG9tRWxlbWVudCA9ICggZWxlbSBpbnN0YW5jZW9mICQgKSA/IGVsZW1bMF0gOiBlbGVtLFxyXG4gICAgICAgICAgICAgICAgaTtcclxuICAgICAgICAgICAgaWYgKCAhZXZlbnRzICkge1xyXG4gICAgICAgICAgICAgICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgcHJvcGFnYXRlRXZlbnQgKTtcclxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBwcm9wYWdhdGVFdmVudCApO1xyXG4gICAgICAgICAgICAgICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgcHJvcGFnYXRlRXZlbnQgKTtcclxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3doZWVsJywgcHJvcGFnYXRlRXZlbnQgKTtcclxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3Njcm9sbCcsIHByb3BhZ2F0ZUV2ZW50ICk7XHJcbiAgICAgICAgICAgICAgICBkb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIHByb3BhZ2F0ZUV2ZW50ICk7XHJcbiAgICAgICAgICAgICAgICBkb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdkYmxjbGljaycsIHByb3BhZ2F0ZUV2ZW50ICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBldmVudHMgPSAoIGV2ZW50cyBpbnN0YW5jZW9mIEFycmF5ICkgPyBldmVudHMgOiBbIGV2ZW50cyBdO1xyXG4gICAgICAgICAgICAgICAgZm9yICggaT0wOyBpPGV2ZW50cy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIGV2ZW50c1tpXSwgcHJvcGFnYXRlRXZlbnQgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgcHJldmlvdXNseSBlbmFibGVkIGV2ZW50IHByb3BhZ2F0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGVsZW0gICAgIHtIVE1MRWxlbWVudCB8IGpRdWVyeX0gVGhlIERPTSBlbGVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSBbZXZlbnRzXSB7QXJyYXl9ICAgICAgICAgICAgICAgQXJyYXkgb2YgZXZlbnRzIHRvIHJlbW92ZSAob3B0aW9uYWwpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRpc2FibGVFdmVudFByb3BhZ2F0aW9uOiBmdW5jdGlvbiggZWxlbSwgZXZlbnRzICkge1xyXG4gICAgICAgICAgICB2YXIgZG9tRWxlbWVudCA9ICggZWxlbSBpbnN0YW5jZW9mICQgKSA/IGVsZW1bMF0gOiBlbGVtLFxyXG4gICAgICAgICAgICAgICAgaTtcclxuICAgICAgICAgICAgaWYgKCAhZXZlbnRzICkge1xyXG4gICAgICAgICAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgcHJvcGFnYXRlRXZlbnQgKTtcclxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBwcm9wYWdhdGVFdmVudCApO1xyXG4gICAgICAgICAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgcHJvcGFnYXRlRXZlbnQgKTtcclxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3doZWVsJywgcHJvcGFnYXRlRXZlbnQgKTtcclxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3Njcm9sbCcsIHByb3BhZ2F0ZUV2ZW50ICk7XHJcbiAgICAgICAgICAgICAgICBkb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIHByb3BhZ2F0ZUV2ZW50ICk7XHJcbiAgICAgICAgICAgICAgICBkb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkYmxjbGljaycsIHByb3BhZ2F0ZUV2ZW50ICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBldmVudHMgPSAoIGV2ZW50cyBpbnN0YW5jZW9mIEFycmF5ICkgPyBldmVudHMgOiBbIGV2ZW50cyBdO1xyXG4gICAgICAgICAgICAgICAgZm9yICggaT0wOyBpPGV2ZW50cy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIGV2ZW50c1tpXSwgcHJvcGFnYXRlRXZlbnQgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBwcm9wZXIgbW9kdWxvIGFzIHRoZSAlIG9wZXJhdG9yIGluIGphdmFzY3JpcHQgaXMgdGhlICdyZW1haW5kZXInIG9wZXJhdG9yLlxyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWVcclxuICAgICAgICAgKiBAcGFyYW0gbiAgICAge251bWJlcn0gdGhlIGRpdmlzb3JcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG1vZDogZnVuY3Rpb24oIHZhbHVlLCBuICkge1xyXG4gICAgICAgICAgIHJldHVybiAoICh2YWx1ZSAlIG4pICsgbikgJSBuO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJvdW5kcyBhIG51bWJlciB0b3dhcmRzIGFub3RoZXIgbnVtYmVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgICByb3VuZFRvd2FyZHM6IGZ1bmN0aW9uKCB2YWx1ZSwgbnVtICkge1xyXG4gICAgICAgICAgICBpZiAoIHZhbHVlIDwgbnVtICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbCggdmFsdWUgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vciggdmFsdWUgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSb3VuZHMgYSBnaXZlbiB2YWx1ZSB0byBhIHNldCBudW1iZXIgb2YgZGVjaW1hbHMuIERlZmF1bHRzIHRvIDIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgICAge251bWJlcn0gdmFsdWUgdG8gcm91bmRcclxuICAgICAgICAgKiBAcGFyYW0gZGVjaW1hbHMge2ludH0gICAgbnVtYmVyIG9mIGRlY2ltYWxzXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gcm91bmRlZCB2YWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJvdW5kVG9EZWNpbWFsczogZnVuY3Rpb24oIHZhbHVlLCBkZWNpbWFscyApIHtcclxuICAgICAgICAgICAgdmFyIG51bURlYyA9IGRlY2ltYWxzIHx8IDIsXHJcbiAgICAgICAgICAgICAgICBwb3cxMCA9IE1hdGgucG93KCAxMCwgbnVtRGVjICk7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KCBNYXRoLnJvdW5kKCB2YWx1ZSAqIHBvdzEwICkgLyBwb3cxMCApLnRvRml4ZWQoIGRlY2ltYWxzICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSB2YWx1ZSBmcm9tIHRoZSByYW5nZSBbMCwgMV0gdG8gYSB2YWx1ZSBmcm9tIHRoZVxyXG4gICAgICAgICAqIHJhbmdlIFttaW5NYXgubWluLCBtaW5NYXgubWF4XSBiYXNlZCBvbiBhIHZhbHVlIHRyYW5zZm9ybSBmdW5jdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwZXJjZW50YWdlIC0gVGhlIHJhbmdlIHBlcmNlbnRhZ2UgaW4gcmFuZ2UgWzAsIDFdLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtaW5NYXggLSBUaGUgbWluIGFuZCBtYXggdmFsdWVzIG9mIHRoZSByYW5nZS5cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNmb3JtIC0gVGhlIHRyYW5zZm9ybSB0eXBlLCBlaXRoZXIgJ2xvZzEwJyBvciAnbGluZWFyJy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB2YWx1ZSBmcm9tIFttaW5NYXgubWluLCBtaW5NYXgubWF4XS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkZW5vcm1hbGl6ZVZhbHVlOiBmdW5jdGlvbiggcGVyY2VudGFnZSwgbWluTWF4LCB0cmFuc2Zvcm0gKSB7XHJcbiAgICAgICAgICAgIHZhciByYW5nZSA9IG1pbk1heC5tYXhpbXVtLSBtaW5NYXgubWluaW11bSxcclxuICAgICAgICAgICAgICAgIHZhbDtcclxuICAgICAgICAgICAgZnVuY3Rpb24gbG9nMTAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5sb2codmFsKSAvIE1hdGguTE4xMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2l0ZXJhdGUgb3ZlciB0aGUgaW5uZXIgbGFiZWxzXHJcbiAgICAgICAgICAgIGlmICggdHJhbnNmb3JtID09PSBcImxvZzEwXCIgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9nTWluID0gKG1pbk1heC5taW5pbXVtID09PSAwKSA/IDAgOiBsb2cxMChtaW5NYXgubWluaW11bSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9nTWF4ID0gKG1pbk1heC5tYXhpbXVtID09PSAwKSA/IDAgOiBsb2cxMChtaW5NYXgubWF4aW11bSk7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSAgTWF0aC5wb3coMTAsIGxvZ01pbiArIChsb2dNYXggLSBsb2dNaW4pICogcGVyY2VudGFnZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBwZXJjZW50YWdlICogcmFuZ2UgKyBtaW5NYXgubWluaW11bTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgdmFsdWUgZnJvbSB0aGUgcmFuZ2UgW21pbk1heC5taW4sIG1pbk1heC5tYXhdIHRvIGEgdmFsdWUgaW5cclxuICAgICAgICAgKiB0aGUgcmFuZ2UgWzAsIDFdIGJhc2VkIG9uIGEgdmFsdWUgdHJhbnNmb3JtIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHJhbmdlIHBlcmNlbnRhZ2UgaW4gcmFuZ2UgW21pbk1heC5taW4sIG1pbk1heC5tYXhdLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtaW5NYXggLSBUaGUgbWluIGFuZCBtYXggdmFsdWVzIG9mIHRoZSByYW5nZS5cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNmb3JtIC0gVGhlIHRyYW5zZm9ybSB0eXBlLCBlaXRoZXIgJ2xvZzEwJyBvciAnbGluZWFyJy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB2YWx1ZSBwZXJjZW50YWdlIGZyb20gWzAsIDFdLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG5vcm1hbGl6ZVZhbHVlOiBmdW5jdGlvbiggdmFsdWUsIG1pbk1heCwgdHJhbnNmb3JtICkge1xyXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBtaW5NYXgubWF4aW11bSAtIG1pbk1heC5taW5pbXVtLFxyXG4gICAgICAgICAgICAgICAgdmFsO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBsb2cxMCh2YWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjEwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrTG9nSW5wdXQoIHZhbHVlICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICggdmFsdWUgPT09IDAgfHwgdmFsdWUgPT09IDEgKSA/IDAgOiBsb2cxMCggdmFsdWUgKSAvIGxvZzEwKCB2YWx1ZSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vaXRlcmF0ZSBvdmVyIHRoZSBpbm5lciBsYWJlbHNcclxuICAgICAgICAgICAgaWYgKCB0cmFuc2Zvcm0gPT09IFwibG9nMTBcIiApIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IGNoZWNrTG9nSW5wdXQoIG1pbk1heC5tYXhpbXVtICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSAoICggdmFsdWUgLSBtaW5NYXgubWluaW11bSApIC8gcmFuZ2UgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVycyBhIGNsaWNrIGhhbmRsZXIgdGhhdCBvbmx5IGZpcmVzIGlmIHRoZSBjbGljayBpc24ndCBwYXJ0IG9mXHJcbiAgICAgICAgICogYSBkb3VibGUgY2xpY2suXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZWxlbWVudCAge0hUTUxFbGVtZW50fSBUaGUgRE9NIGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBldmVudC5cclxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sge0Z1bmN0aW9ufSAgICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgICAgICogQHBhcmFtIFt0aW1vdXRdIHtpbnR9ICAgICAgICAgICAgVGhlIHRpbWVvdXQgaW4gbXMgKG9wdGlvbmFsKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aW1lU2Vuc2l0aXZlQ2xpY2s6IGZ1bmN0aW9uKCBlbGVtZW50LCBjYWxsYmFjaywgdGltZW91dCApIHtcclxuICAgICAgICAgICAgdmFyIGNsaWNrcyA9IDA7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJjbGlja1wiLCBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0XHQgICAgXHRjbGlja3MrKztcclxuXHRcdCAgICBcdGlmICggY2xpY2tzID09PSAxICkge1xyXG5cdFx0ICAgICAgICBcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xyXG5cdFx0ICAgICAgICBcdFx0aWYgKCBjbGlja3MgPT09IDEgKSB7XHJcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCggZWxlbWVudCwgZXZlbnQgKTtcclxuXHRcdFx0XHQgICAgICAgIH1cclxuXHRcdCAgICAgICAgXHRcdGNsaWNrcyA9IDA7XHJcblx0XHQgICAgICAgIFx0fSwgdGltZW91dCB8fCAzMDApO1xyXG5cdFx0XHQgICAgfVxyXG5cdFx0ICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVycyBhIGNsaWNrIGhhbmRsZXIgdGhhdCBvbmx5IGZpcmVzIGlmIHRoZSBjbGljayBkaWRuJ3RcclxuICAgICAgICAgKiBpbnZvbHZlIGEgbWFwIGRyYWcuIFNpbmNlIHRoZSBtYXAgaXMgbW92aW5nIHVuZGVyIHRoZSBtb3VzZSBjdXJzb3JcclxuICAgICAgICAgKiB0aGUgYnJvd3NlciB3aWxsIHN0aWxsIHJlZ2lzdGVyIGEgY2xpY2sgZGVzcGl0ZSBtb3VzZSBtb3ZlbWVudC4gVGhpc1xyXG4gICAgICAgICAqIGd1YXJkcyBhZ2FpbnN0IHRoYXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZWxlbWVudCAgICAge0hUTUxFbGVtZW50fSBUaGUgRE9NIGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBldmVudC5cclxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgICAge0Z1bmN0aW9ufSAgICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgICAgICogQHBhcmFtIFt0aHJlc2hvbGRdIHtpbnR9ICAgICAgICAgVGhlIG1vdmVtZW50IHRocmVzaG9sZCAob3B0aW9uYWwpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRyYWdTZW5zaXRpdmVDbGljazogZnVuY3Rpb24oIGVsZW1lbnQsIGNhbGxiYWNrLCB0aHJlc2hvbGQgKSB7XHJcbiAgICAgICAgICAgIHZhciBkcmFnU3RhcnQgPSB7eDogbnVsbCwgeTogbnVsbH07XHJcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAxMDtcclxuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbiggZXZ0ICkge1xyXG4gICAgICAgICAgICAgICAgZHJhZ1N0YXJ0LnggPSBldnQucGFnZVg7XHJcbiAgICAgICAgICAgICAgICBkcmFnU3RhcnQueSA9IGV2dC5wYWdlWTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJjbGlja1wiLCBmdW5jdGlvbiggZXZ0ICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKCBkcmFnU3RhcnQueCAtIGV2dC5wYWdlWCApIDwgdGhyZXNob2xkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoIGRyYWdTdGFydC55IC0gZXZ0LnBhZ2VZICkgPCB0aHJlc2hvbGQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCggdGhpcywgZXZ0ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVycyBhIGNsaWNrIGhhbmRsZXIgdGhhdCBvbmx5IGZpcmVzIGlmIHRoZSBjbGljayBkaWRuJ3RcclxuICAgICAgICAgKiBpbnZvbHZlIGEgbWFwIGRyYWcgYW5kIHdhcyBub3QgcGFydCBvZiBhIGRvdWJsZSBjbGljay5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBlbGVtZW50ICAgICB7SFRNTEVsZW1lbnR9IFRoZSBET00gZWxlbWVudCB0byBhdHRhY2ggdGhlIGV2ZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAgICB7RnVuY3Rpb259ICAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkcmFnQW5kVGltZVNlbnNpdGl2ZUNsaWNrOiBmdW5jdGlvbiggZWxlbWVudCwgY2FsbGJhY2sgKSB7XHJcbiAgICAgICAgICAgIHZhciBkcmFnU3RhcnQgPSB7eDogbnVsbCwgeTogbnVsbH0sXHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQgPSB0aHJlc2hvbGQgfHwgMTA7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oIGV2dCApIHtcclxuICAgICAgICAgICAgICAgIGRyYWdTdGFydC54ID0gZXZ0LnBhZ2VYO1xyXG4gICAgICAgICAgICAgICAgZHJhZ1N0YXJ0LnkgPSBldnQucGFnZVk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVTZW5zaXRpdmVDbGljayggZWxlbWVudCwgZnVuY3Rpb24oIGV2dCApIHtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyggZHJhZ1N0YXJ0LnggLSBldnQucGFnZVggKSA8IHRocmVzaG9sZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKCBkcmFnU3RhcnQueSAtIGV2dC5wYWdlWSApIDwgdGhyZXNob2xkICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoIHRoaXMsIGV2dCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHBhcmFtZXRlcnMgYW5kIHZhbHVlcyBpbiB0aGUgY3VycmVudFxyXG4gICAgICAgICAqIFVSTC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0VVJMUGFyYW1ldGVyczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSxcclxuICAgICAgICAgICAgICAgIHVybFZhcnMgPSB1cmwuc3BsaXQoJyYnKSxcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9LFxyXG4gICAgICAgICAgICAgICAga2V5VmFsdWUsXHJcbiAgICAgICAgICAgICAgICBpO1xyXG4gICAgICAgICAgICBmb3IgKCBpPTA7IGk8dXJsVmFycy5sZW5ndGg7ICsraSApIHtcclxuICAgICAgICAgICAgICAgIGtleVZhbHVlID0gdXJsVmFyc1tpXS5zcGxpdCgnPScpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0WyBrZXlWYWx1ZVswXSBdID0ga2V5VmFsdWVbMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWMgcGFyYW1ldGVycyBpbiB0aGUgY3VycmVudCBVUkwuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ga2V5IHtzdHJpbmd9IFRoZSB1cmwgcGFyYW1ldGVyIGtleS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFVSTFBhcmFtZXRlcjogZnVuY3Rpb24oIGtleSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VVJMUGFyYW1ldGVycygpWyBrZXkgXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIVFRQIFJFU1QgRXJyb3IgaGFuZGxpbmcgZnVuY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0geGhyIHtYbWxIdHRwUmVxdWVzdH0gWG1sSHR0cFJlcXVlc3Qgb2JqZWN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaGFuZGxlSFRUUEVycm9yOiBmdW5jdGlvbiggeGhyICkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCB4aHIucmVzcG9uc2VUZXh0ICk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIHhociApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgb2YgYW4gb2JqZWN0IGluIHF1ZXJ5IHBhcmFtZXRlciBkb3Qgbm90YXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIHtPYmplY3R9IFRoZSBxdWVyeSBwYXJhbWV0ZXIgb2JqZWN0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW5jb2RlUXVlcnlQYXJhbXM6IGZ1bmN0aW9uKCBwYXJhbXMgKSB7XHJcbiAgICAgICAgICAgIHZhciBxdWVyeTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gdHJhdmVyc2VQYXJhbXMoIHBhcmFtcywgcXVlcnkgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIF8uZm9ySW4oIHBhcmFtcywgZnVuY3Rpb24oIHZhbHVlLCBrZXkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBxdWVyeSArIGtleSArICc9JyArIHZhbHVlICsgXCImXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRyYXZlcnNlUGFyYW1zKCBwYXJhbXNbIGtleSBdLCBxdWVyeSArIGtleSArIFwiLlwiICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBzdHJpbmcgZW5kcyBpbiBcIi5cIiwgaXQgcmVzdWx0ZWQgaW4gYW4gZW1wdHkgbGVhZiBub2RlLCByZXR1cm5cclxuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgaW4gdGhhdCBjYXNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCByZXN1bHRbMF0gIT09IFwiLlwiICkgPyByZXN1bHQgOiBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHF1ZXJ5ID0gXCI/XCIgKyB0cmF2ZXJzZVBhcmFtcyggcGFyYW1zLCAnJyApO1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgbGFzdCAnJicgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgIHJldHVybiBxdWVyeS5zbGljZSggMCwgcXVlcnkubGVuZ3RoIC0gMSApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYW5kIGZpbGxzIGFuIGFycmF5IHdpdGggdGhlIHByb3ZpZGVkIHZhbHVlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsbC4gRGVmYXVsdHMgdG8gMC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGZpbGxlZCBhcnJheS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmaWxsQXJyYXk6IGZ1bmN0aW9uKCBsZW5ndGgsIHZhbHVlICkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IDA7XHJcbiAgICAgICAgICAgIHZhciBhcnIgPSBbXSxcclxuICAgICAgICAgICAgICAgIGk7XHJcbiAgICAgICAgICAgIGZvciAoIGk9MDsgaTxsZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKCB2YWx1ZSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICAgfSxcclxuXHJcblx0XHRcdCAgICAvKipcclxuXHRcdFx0ICAgICAqIENyZWF0ZXMgYW5kIGZpbGxzIGFuIGFycmF5IHdpdGggdGhlIHByb3ZpZGVkIHZhbHVlLlxyXG5cdFx0XHQgICAgICpcclxuXHRcdFx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggLSBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cclxuXHRcdFx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsbC4gRGVmYXVsdHMgdG8gMC5cclxuXHRcdFx0ICAgICAqXHJcblx0XHRcdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBmaWxsZWQgYXJyYXkuXHJcblx0XHRcdCAgICAgKi9cclxuXHRcdFx0ICAgIGZpbGxBcnJheUJ5RnVuYzogZnVuY3Rpb24oIGxlbmd0aCwgZnVuYyApIHtcclxuXHRcdFx0XHQgICAgdmFyIGFyciA9IFtdLFxyXG5cdFx0XHRcdFx0ICAgIGk7XHJcblx0XHRcdFx0ICAgIGZvciAoIGk9MDsgaTxsZW5ndGg7IGkrKyApIHtcclxuXHRcdFx0XHRcdCAgICBhcnIucHVzaCggZnVuYygpICk7XHJcblx0XHRcdFx0ICAgIH1cclxuXHRcdFx0XHQgICAgcmV0dXJuIGFycjtcclxuXHRcdFx0ICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBvYmplY3QgaGFzIG5vIHBhcmFtZXRlcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gb2JqIHtPYmplY3R9IFRoZSBvYmplY3QuXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24oIG9iaiApIHtcclxuICAgICAgICAgICAgdmFyIHByb3A7XHJcbiAgICAgICAgICAgIGZvciAoIHByb3AgaW4gb2JqICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBvYmouaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXh0ZW5kIGNsYXNzIGEgYnkgY2xhc3MgYi4gRG9lcyBub3QgcmVjdXJzZSwgc2ltcGx5IG92ZXJsYXlzIHRvcCBhdHRyaWJ1dGVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGEgLSBPYmplY3QgYSB3aGljaCBpcyBleHRlbmRlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYiAtIE9iamVjdCBiIHdoaWNoIGV4dGVuZHMgYS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBleHRlbmRlZCBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiggYSwgYiApIHtcclxuICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgZm9yKCBrZXkgaW4gYiApIHtcclxuICAgICAgICAgICAgICAgIGlmKCBiLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBhWyBrZXkgXSA9IGJbIGtleSBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgIH07XHJcbn0oKSk7XHJcbiJdfQ==
